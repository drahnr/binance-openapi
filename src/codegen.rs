
    #![allow(dead_code, deprecated)]
    #![allow(clippy::needless_lifetimes, clippy::too_many_arguments, clippy::from_str_radix_10, clippy::vec_init_then_push)]
    
    use crate::datetimerfc3339::*;
    #[allow(unused_imports)]
pub use progenitor_client::{ByteStream, Error, ResponseValue};
#[allow(unused_imports)]
use progenitor_client::{encode_path, RequestBuilderExt};
#[allow(unused_imports)]
use reqwest::header::{HeaderMap, HeaderValue};
/// Types used as operation parameters and responses.
#[allow(clippy::all)]
pub mod types {
    use serde::{Deserialize, Serialize};
    #[allow(unused_imports)]
    use std::convert::TryFrom;
    /// Error types.
    pub mod error {
        /// Error from a TryFrom or FromStr implementation.
        pub struct ConversionError(std::borrow::Cow<'static, str>);
        impl std::error::Error for ConversionError {}
        impl std::fmt::Display for ConversionError {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> Result<(), std::fmt::Error> {
                std::fmt::Display::fmt(&self.0, f)
            }
        }
        impl std::fmt::Debug for ConversionError {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> Result<(), std::fmt::Error> {
                std::fmt::Debug::fmt(&self.0, f)
            }
        }
        impl From<&'static str> for ConversionError {
            fn from(value: &'static str) -> Self {
                Self(value.into())
            }
        }
        impl From<String> for ConversionError {
            fn from(value: String) -> Self {
                Self(value.into())
            }
        }
    }
    ///Account
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "accountType",
    ///    "balances",
    ///    "brokered",
    ///    "buyerCommission",
    ///    "canDeposit",
    ///    "canTrade",
    ///    "canWithdraw",
    ///    "commissionRates",
    ///    "makerCommission",
    ///    "permissions",
    ///    "preventSor",
    ///    "requireSelfTradePrevention",
    ///    "sellerCommission",
    ///    "takerCommission",
    ///    "uid",
    ///    "updateTime"
    ///  ],
    ///  "properties": {
    ///    "accountType": {
    ///      "examples": [
    ///        "SPOT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "balances": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "asset",
    ///          "free",
    ///          "locked"
    ///        ],
    ///        "properties": {
    ///          "asset": {
    ///            "examples": [
    ///              "BTC"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "free": {
    ///            "examples": [
    ///              "4723846.89208129"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "locked": {
    ///            "examples": [
    ///              "0.00000000"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "brokered": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "buyerCommission": {
    ///      "examples": [
    ///        0
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "canDeposit": {
    ///      "type": "boolean"
    ///    },
    ///    "canTrade": {
    ///      "type": "boolean"
    ///    },
    ///    "canWithdraw": {
    ///      "type": "boolean"
    ///    },
    ///    "commissionRates": {
    ///      "type": "object",
    ///      "required": [
    ///        "buyer",
    ///        "maker",
    ///        "seller",
    ///        "taker"
    ///      ],
    ///      "properties": {
    ///        "buyer": {
    ///          "examples": [
    ///            "0.00000000"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "maker": {
    ///          "examples": [
    ///            "0.00150000"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "seller": {
    ///          "examples": [
    ///            "0.00000000"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "taker": {
    ///          "examples": [
    ///            "0.00150000"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "makerCommission": {
    ///      "examples": [
    ///        15
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "permissions": {
    ///      "type": "array",
    ///      "items": {
    ///        "examples": [
    ///          "SPOT"
    ///        ],
    ///        "type": "string"
    ///      }
    ///    },
    ///    "preventSor": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "requireSelfTradePrevention": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "sellerCommission": {
    ///      "examples": [
    ///        0
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "takerCommission": {
    ///      "examples": [
    ///        15
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "uid": {
    ///      "examples": [
    ///        354937868
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "updateTime": {
    ///      "examples": [
    ///        123456789
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct Account {
        #[serde(rename = "accountType")]
        pub account_type: String,
        pub balances: Vec<AccountBalancesItem>,
        pub brokered: bool,
        #[serde(rename = "buyerCommission")]
        pub buyer_commission: i64,
        #[serde(rename = "canDeposit")]
        pub can_deposit: bool,
        #[serde(rename = "canTrade")]
        pub can_trade: bool,
        #[serde(rename = "canWithdraw")]
        pub can_withdraw: bool,
        #[serde(rename = "commissionRates")]
        pub commission_rates: AccountCommissionRates,
        #[serde(rename = "makerCommission")]
        pub maker_commission: i64,
        pub permissions: Vec<String>,
        #[serde(rename = "preventSor")]
        pub prevent_sor: bool,
        #[serde(rename = "requireSelfTradePrevention")]
        pub require_self_trade_prevention: bool,
        #[serde(rename = "sellerCommission")]
        pub seller_commission: i64,
        #[serde(rename = "takerCommission")]
        pub taker_commission: i64,
        pub uid: i64,
        #[serde(rename = "updateTime")]
        pub update_time: i64,
    }
    impl From<&Account> for Account {
        fn from(value: &Account) -> Self {
            value.clone()
        }
    }
    ///AccountApiRestrictionsResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "createTime",
    ///    "enableFutures",
    ///    "enableInternalTransfer",
    ///    "enableMargin",
    ///    "enableReading",
    ///    "enableSpotAndMarginTrading",
    ///    "enableVanillaOptions",
    ///    "enableWithdrawals",
    ///    "ipRestrict",
    ///    "permitsUniversalTransfer",
    ///    "tradingAuthorityExpirationTime"
    ///  ],
    ///  "properties": {
    ///    "createTime": {
    ///      "examples": [
    ///        1623840271000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "enableFutures": {
    ///      "description": "API Key created before your futures account opened does not support futures API service",
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "enableInternalTransfer": {
    ///      "description": "This option authorizes this key to transfer funds between your master account and your sub account instantly",
    ///      "type": "boolean"
    ///    },
    ///    "enableMargin": {
    ///      "description": "This option can be adjusted after the Cross Margin account transfer is completed",
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "enablePortfolioMarginTrading": {
    ///      "description": "API Key created before your activate portfolio margin does not support portfolio margin API service",
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "enableReading": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "enableSpotAndMarginTrading": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "enableVanillaOptions": {
    ///      "description": "Authorizes this key to Vanilla options trading",
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "enableWithdrawals": {
    ///      "description": "This option allows you to withdraw via API. You must apply the IP Access Restriction filter in order to enable withdrawals",
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "ipRestrict": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "permitsUniversalTransfer": {
    ///      "description": "Authorizes this key to be used for a dedicated universal transfer API to transfer multiple supported currencies. Each business's own transfer API rights are not affected by this authorization",
    ///      "type": "boolean"
    ///    },
    ///    "tradingAuthorityExpirationTime": {
    ///      "description": "Expiration time for spot and margin trading permission",
    ///      "examples": [
    ///        1628985600000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct AccountApiRestrictionsResponse {
        #[serde(rename = "createTime")]
        pub create_time: i64,
        ///API Key created before your futures account opened does not support futures API service
        #[serde(rename = "enableFutures")]
        pub enable_futures: bool,
        ///This option authorizes this key to transfer funds between your master account and your sub account instantly
        #[serde(rename = "enableInternalTransfer")]
        pub enable_internal_transfer: bool,
        ///This option can be adjusted after the Cross Margin account transfer is completed
        #[serde(rename = "enableMargin")]
        pub enable_margin: bool,
        ///API Key created before your activate portfolio margin does not support portfolio margin API service
        #[serde(
            rename = "enablePortfolioMarginTrading",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub enable_portfolio_margin_trading: Option<bool>,
        #[serde(rename = "enableReading")]
        pub enable_reading: bool,
        #[serde(rename = "enableSpotAndMarginTrading")]
        pub enable_spot_and_margin_trading: bool,
        ///Authorizes this key to Vanilla options trading
        #[serde(rename = "enableVanillaOptions")]
        pub enable_vanilla_options: bool,
        ///This option allows you to withdraw via API. You must apply the IP Access Restriction filter in order to enable withdrawals
        #[serde(rename = "enableWithdrawals")]
        pub enable_withdrawals: bool,
        #[serde(rename = "ipRestrict")]
        pub ip_restrict: bool,
        ///Authorizes this key to be used for a dedicated universal transfer API to transfer multiple supported currencies. Each business's own transfer API rights are not affected by this authorization
        #[serde(rename = "permitsUniversalTransfer")]
        pub permits_universal_transfer: bool,
        ///Expiration time for spot and margin trading permission
        #[serde(rename = "tradingAuthorityExpirationTime")]
        pub trading_authority_expiration_time: i64,
    }
    impl From<&AccountApiRestrictionsResponse> for AccountApiRestrictionsResponse {
        fn from(value: &AccountApiRestrictionsResponse) -> Self {
            value.clone()
        }
    }
    ///AccountApiTradingStatusResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "data"
    ///  ],
    ///  "properties": {
    ///    "data": {
    ///      "type": "object",
    ///      "required": [
    ///        "indicators",
    ///        "isLocked",
    ///        "plannedRecoverTime",
    ///        "triggerCondition",
    ///        "updateTime"
    ///      ],
    ///      "properties": {
    ///        "indicators": {
    ///          "description": "The indicators updated every 30 seconds",
    ///          "type": "object",
    ///          "required": [
    ///            "BTCUSDT"
    ///          ],
    ///          "properties": {
    ///            "BTCUSDT": {
    ///              "type": "array",
    ///              "items": {
    ///                "type": "object",
    ///                "required": [
    ///                  "c",
    ///                  "i",
    ///                  "t",
    ///                  "v"
    ///                ],
    ///                "properties": {
    ///                  "c": {
    ///                    "description": "Count of all orders",
    ///                    "examples": [
    ///                      20
    ///                    ],
    ///                    "type": "integer",
    ///                    "format": "int64"
    ///                  },
    ///                  "i": {
    ///                    "description": "Unfilled Ratio (UFR)",
    ///                    "examples": [
    ///                      "UFR"
    ///                    ],
    ///                    "type": "string"
    ///                  },
    ///                  "t": {
    ///                    "description": "Trigger UFR value",
    ///                    "examples": [
    ///                      0.99
    ///                    ],
    ///                    "type": "number",
    ///                    "format": "float"
    ///                  },
    ///                  "v": {
    ///                    "description": "Current UFR value",
    ///                    "examples": [
    ///                      0.05
    ///                    ],
    ///                    "type": "number",
    ///                    "format": "float"
    ///                  }
    ///                }
    ///              }
    ///            }
    ///          }
    ///        },
    ///        "isLocked": {
    ///          "description": "API trading function is locked or not",
    ///          "examples": [
    ///            false
    ///          ],
    ///          "type": "boolean"
    ///        },
    ///        "plannedRecoverTime": {
    ///          "description": "If API trading function is locked, this is the planned recover time",
    ///          "examples": [
    ///            0
    ///          ],
    ///          "type": "integer",
    ///          "format": "int64"
    ///        },
    ///        "triggerCondition": {
    ///          "type": "object",
    ///          "required": [
    ///            "GCR",
    ///            "IFER",
    ///            "UFR"
    ///          ],
    ///          "properties": {
    ///            "GCR": {
    ///              "description": "Number of GTC orders",
    ///              "examples": [
    ///                150
    ///              ],
    ///              "type": "integer",
    ///              "format": "int64"
    ///            },
    ///            "IFER": {
    ///              "description": "Number of FOK/IOC orders",
    ///              "examples": [
    ///                150
    ///              ],
    ///              "type": "integer",
    ///              "format": "int64"
    ///            },
    ///            "UFR": {
    ///              "description": "Number of orders",
    ///              "examples": [
    ///                300
    ///              ],
    ///              "type": "integer",
    ///              "format": "int64"
    ///            }
    ///          }
    ///        },
    ///        "updateTime": {
    ///          "examples": [
    ///            1547630471725
    ///          ],
    ///          "type": "integer",
    ///          "format": "int64"
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct AccountApiTradingStatusResponse {
        pub data: AccountApiTradingStatusResponseData,
    }
    impl From<&AccountApiTradingStatusResponse> for AccountApiTradingStatusResponse {
        fn from(value: &AccountApiTradingStatusResponse) -> Self {
            value.clone()
        }
    }
    ///AccountApiTradingStatusResponseData
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "indicators",
    ///    "isLocked",
    ///    "plannedRecoverTime",
    ///    "triggerCondition",
    ///    "updateTime"
    ///  ],
    ///  "properties": {
    ///    "indicators": {
    ///      "description": "The indicators updated every 30 seconds",
    ///      "type": "object",
    ///      "required": [
    ///        "BTCUSDT"
    ///      ],
    ///      "properties": {
    ///        "BTCUSDT": {
    ///          "type": "array",
    ///          "items": {
    ///            "type": "object",
    ///            "required": [
    ///              "c",
    ///              "i",
    ///              "t",
    ///              "v"
    ///            ],
    ///            "properties": {
    ///              "c": {
    ///                "description": "Count of all orders",
    ///                "examples": [
    ///                  20
    ///                ],
    ///                "type": "integer",
    ///                "format": "int64"
    ///              },
    ///              "i": {
    ///                "description": "Unfilled Ratio (UFR)",
    ///                "examples": [
    ///                  "UFR"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "t": {
    ///                "description": "Trigger UFR value",
    ///                "examples": [
    ///                  0.99
    ///                ],
    ///                "type": "number",
    ///                "format": "float"
    ///              },
    ///              "v": {
    ///                "description": "Current UFR value",
    ///                "examples": [
    ///                  0.05
    ///                ],
    ///                "type": "number",
    ///                "format": "float"
    ///              }
    ///            }
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "isLocked": {
    ///      "description": "API trading function is locked or not",
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "plannedRecoverTime": {
    ///      "description": "If API trading function is locked, this is the planned recover time",
    ///      "examples": [
    ///        0
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "triggerCondition": {
    ///      "type": "object",
    ///      "required": [
    ///        "GCR",
    ///        "IFER",
    ///        "UFR"
    ///      ],
    ///      "properties": {
    ///        "GCR": {
    ///          "description": "Number of GTC orders",
    ///          "examples": [
    ///            150
    ///          ],
    ///          "type": "integer",
    ///          "format": "int64"
    ///        },
    ///        "IFER": {
    ///          "description": "Number of FOK/IOC orders",
    ///          "examples": [
    ///            150
    ///          ],
    ///          "type": "integer",
    ///          "format": "int64"
    ///        },
    ///        "UFR": {
    ///          "description": "Number of orders",
    ///          "examples": [
    ///            300
    ///          ],
    ///          "type": "integer",
    ///          "format": "int64"
    ///        }
    ///      }
    ///    },
    ///    "updateTime": {
    ///      "examples": [
    ///        1547630471725
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct AccountApiTradingStatusResponseData {
        pub indicators: AccountApiTradingStatusResponseDataIndicators,
        ///API trading function is locked or not
        #[serde(rename = "isLocked")]
        pub is_locked: bool,
        ///If API trading function is locked, this is the planned recover time
        #[serde(rename = "plannedRecoverTime")]
        pub planned_recover_time: i64,
        #[serde(rename = "triggerCondition")]
        pub trigger_condition: AccountApiTradingStatusResponseDataTriggerCondition,
        #[serde(rename = "updateTime")]
        pub update_time: i64,
    }
    impl From<&AccountApiTradingStatusResponseData>
    for AccountApiTradingStatusResponseData {
        fn from(value: &AccountApiTradingStatusResponseData) -> Self {
            value.clone()
        }
    }
    ///The indicators updated every 30 seconds
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The indicators updated every 30 seconds",
    ///  "type": "object",
    ///  "required": [
    ///    "BTCUSDT"
    ///  ],
    ///  "properties": {
    ///    "BTCUSDT": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "c",
    ///          "i",
    ///          "t",
    ///          "v"
    ///        ],
    ///        "properties": {
    ///          "c": {
    ///            "description": "Count of all orders",
    ///            "examples": [
    ///              20
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "i": {
    ///            "description": "Unfilled Ratio (UFR)",
    ///            "examples": [
    ///              "UFR"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "t": {
    ///            "description": "Trigger UFR value",
    ///            "examples": [
    ///              0.99
    ///            ],
    ///            "type": "number",
    ///            "format": "float"
    ///          },
    ///          "v": {
    ///            "description": "Current UFR value",
    ///            "examples": [
    ///              0.05
    ///            ],
    ///            "type": "number",
    ///            "format": "float"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct AccountApiTradingStatusResponseDataIndicators {
        #[serde(rename = "BTCUSDT")]
        pub btcusdt: Vec<AccountApiTradingStatusResponseDataIndicatorsBtcusdtItem>,
    }
    impl From<&AccountApiTradingStatusResponseDataIndicators>
    for AccountApiTradingStatusResponseDataIndicators {
        fn from(value: &AccountApiTradingStatusResponseDataIndicators) -> Self {
            value.clone()
        }
    }
    ///AccountApiTradingStatusResponseDataIndicatorsBtcusdtItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "c",
    ///    "i",
    ///    "t",
    ///    "v"
    ///  ],
    ///  "properties": {
    ///    "c": {
    ///      "description": "Count of all orders",
    ///      "examples": [
    ///        20
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "i": {
    ///      "description": "Unfilled Ratio (UFR)",
    ///      "examples": [
    ///        "UFR"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "t": {
    ///      "description": "Trigger UFR value",
    ///      "examples": [
    ///        0.99
    ///      ],
    ///      "type": "number",
    ///      "format": "float"
    ///    },
    ///    "v": {
    ///      "description": "Current UFR value",
    ///      "examples": [
    ///        0.05
    ///      ],
    ///      "type": "number",
    ///      "format": "float"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct AccountApiTradingStatusResponseDataIndicatorsBtcusdtItem {
        ///Count of all orders
        pub c: i64,
        ///Unfilled Ratio (UFR)
        pub i: String,
        pub t: f32,
        pub v: f32,
    }
    impl From<&AccountApiTradingStatusResponseDataIndicatorsBtcusdtItem>
    for AccountApiTradingStatusResponseDataIndicatorsBtcusdtItem {
        fn from(
            value: &AccountApiTradingStatusResponseDataIndicatorsBtcusdtItem,
        ) -> Self {
            value.clone()
        }
    }
    ///AccountApiTradingStatusResponseDataTriggerCondition
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "GCR",
    ///    "IFER",
    ///    "UFR"
    ///  ],
    ///  "properties": {
    ///    "GCR": {
    ///      "description": "Number of GTC orders",
    ///      "examples": [
    ///        150
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "IFER": {
    ///      "description": "Number of FOK/IOC orders",
    ///      "examples": [
    ///        150
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "UFR": {
    ///      "description": "Number of orders",
    ///      "examples": [
    ///        300
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct AccountApiTradingStatusResponseDataTriggerCondition {
        ///Number of GTC orders
        #[serde(rename = "GCR")]
        pub gcr: i64,
        ///Number of FOK/IOC orders
        #[serde(rename = "IFER")]
        pub ifer: i64,
        ///Number of orders
        #[serde(rename = "UFR")]
        pub ufr: i64,
    }
    impl From<&AccountApiTradingStatusResponseDataTriggerCondition>
    for AccountApiTradingStatusResponseDataTriggerCondition {
        fn from(value: &AccountApiTradingStatusResponseDataTriggerCondition) -> Self {
            value.clone()
        }
    }
    ///AccountBalancesItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "asset",
    ///    "free",
    ///    "locked"
    ///  ],
    ///  "properties": {
    ///    "asset": {
    ///      "examples": [
    ///        "BTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "free": {
    ///      "examples": [
    ///        "4723846.89208129"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "locked": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct AccountBalancesItem {
        pub asset: String,
        pub free: String,
        pub locked: String,
    }
    impl From<&AccountBalancesItem> for AccountBalancesItem {
        fn from(value: &AccountBalancesItem) -> Self {
            value.clone()
        }
    }
    ///AccountCommissionRates
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "buyer",
    ///    "maker",
    ///    "seller",
    ///    "taker"
    ///  ],
    ///  "properties": {
    ///    "buyer": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "maker": {
    ///      "examples": [
    ///        "0.00150000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "seller": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "taker": {
    ///      "examples": [
    ///        "0.00150000"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct AccountCommissionRates {
        pub buyer: String,
        pub maker: String,
        pub seller: String,
        pub taker: String,
    }
    impl From<&AccountCommissionRates> for AccountCommissionRates {
        fn from(value: &AccountCommissionRates) -> Self {
            value.clone()
        }
    }
    ///AccountSnapshotResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/snapshotSpot"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/snapshotMargin"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/snapshotFutures"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    #[serde(untagged)]
    pub enum AccountSnapshotResponse {
        Spot(SnapshotSpot),
        Margin(SnapshotMargin),
        Futures(SnapshotFutures),
    }
    impl From<&AccountSnapshotResponse> for AccountSnapshotResponse {
        fn from(value: &AccountSnapshotResponse) -> Self {
            value.clone()
        }
    }
    impl From<SnapshotSpot> for AccountSnapshotResponse {
        fn from(value: SnapshotSpot) -> Self {
            Self::Spot(value)
        }
    }
    impl From<SnapshotMargin> for AccountSnapshotResponse {
        fn from(value: SnapshotMargin) -> Self {
            Self::Margin(value)
        }
    }
    impl From<SnapshotFutures> for AccountSnapshotResponse {
        fn from(value: SnapshotFutures) -> Self {
            Self::Futures(value)
        }
    }
    ///AccountSnapshotType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "SPOT",
    ///    "MARGIN",
    ///    "FUTURES"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum AccountSnapshotType {
        #[serde(rename = "SPOT")]
        Spot,
        #[serde(rename = "MARGIN")]
        Margin,
        #[serde(rename = "FUTURES")]
        Futures,
    }
    impl From<&AccountSnapshotType> for AccountSnapshotType {
        fn from(value: &AccountSnapshotType) -> Self {
            value.clone()
        }
    }
    impl ToString for AccountSnapshotType {
        fn to_string(&self) -> String {
            match *self {
                Self::Spot => "SPOT".to_string(),
                Self::Margin => "MARGIN".to_string(),
                Self::Futures => "FUTURES".to_string(),
            }
        }
    }
    impl std::str::FromStr for AccountSnapshotType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "SPOT" => Ok(Self::Spot),
                "MARGIN" => Ok(Self::Margin),
                "FUTURES" => Ok(Self::Futures),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for AccountSnapshotType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for AccountSnapshotType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for AccountSnapshotType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///AccountStatusResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "data"
    ///  ],
    ///  "properties": {
    ///    "data": {
    ///      "examples": [
    ///        "Normal"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct AccountStatusResponse {
        pub data: String,
    }
    impl From<&AccountStatusResponse> for AccountStatusResponse {
        fn from(value: &AccountStatusResponse) -> Self {
            value.clone()
        }
    }
    ///AggTrade
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "M",
    ///    "T",
    ///    "a",
    ///    "f",
    ///    "l",
    ///    "maker",
    ///    "p",
    ///    "q"
    ///  ],
    ///  "properties": {
    ///    "M": {
    ///      "description": "Was the trade the best price match?",
    ///      "type": "boolean"
    ///    },
    ///    "T": {
    ///      "description": "Timestamp",
    ///      "examples": [
    ///        1498793709153
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "a": {
    ///      "description": "Aggregate tradeId",
    ///      "examples": [
    ///        26129
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "f": {
    ///      "description": "First tradeId",
    ///      "examples": [
    ///        27781
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "l": {
    ///      "description": "Last tradeId",
    ///      "examples": [
    ///        27781
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "maker": {
    ///      "description": "Was the buyer the maker?",
    ///      "type": "boolean"
    ///    },
    ///    "p": {
    ///      "description": "Price",
    ///      "examples": [
    ///        "0.01633102"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "q": {
    ///      "description": "Quantity",
    ///      "examples": [
    ///        "4.70443515"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct AggTrade {
        ///Aggregate tradeId
        pub a: i64,
        ///First tradeId
        pub f: i64,
        ///Last tradeId
        pub l: i64,
        ///Was the trade the best price match?
        #[serde(rename = "M")]
        pub m: bool,
        ///Was the buyer the maker?
        pub maker: bool,
        ///Price
        pub p: String,
        ///Quantity
        pub q: String,
        ///Timestamp
        #[serde(rename = "T")]
        pub t: bool,
    }
    impl From<&AggTrade> for AggTrade {
        fn from(value: &AggTrade) -> Self {
            value.clone()
        }
    }
    ///AlgoFuturesHistoricalOrdersResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "orders",
    ///    "total"
    ///  ],
    ///  "properties": {
    ///    "orders": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "algoId",
    ///          "algoStatus",
    ///          "algoType",
    ///          "avgPrice",
    ///          "bookTime",
    ///          "clientAlgoId",
    ///          "endTime",
    ///          "executedAmt",
    ///          "executedQty",
    ///          "positionSide",
    ///          "side",
    ///          "symbol",
    ///          "totalQty",
    ///          "urgency"
    ///        ],
    ///        "properties": {
    ///          "algoId": {
    ///            "examples": [
    ///              14517
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "algoStatus": {
    ///            "examples": [
    ///              "WORKING"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "algoType": {
    ///            "examples": [
    ///              "VP"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "avgPrice": {
    ///            "examples": [
    ///              "0.00"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "bookTime": {
    ///            "examples": [
    ///              1649756817004
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "clientAlgoId": {
    ///            "examples": [
    ///              "d7096549481642f8a0bb69e9e2e31f2e"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "endTime": {
    ///            "examples": [
    ///              1649757088101
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "executedAmt": {
    ///            "examples": [
    ///              "0.00000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "executedQty": {
    ///            "examples": [
    ///              "0.000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "positionSide": {
    ///            "examples": [
    ///              "SHORT"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "side": {
    ///            "examples": [
    ///              "SELL"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "symbol": {
    ///            "examples": [
    ///              "ETHUSDT"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "totalQty": {
    ///            "examples": [
    ///              "5.00"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "urgency": {
    ///            "examples": [
    ///              "LOW"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "total": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct AlgoFuturesHistoricalOrdersResponse {
        pub orders: Vec<AlgoFuturesHistoricalOrdersResponseOrdersItem>,
        pub total: i32,
    }
    impl From<&AlgoFuturesHistoricalOrdersResponse>
    for AlgoFuturesHistoricalOrdersResponse {
        fn from(value: &AlgoFuturesHistoricalOrdersResponse) -> Self {
            value.clone()
        }
    }
    ///AlgoFuturesHistoricalOrdersResponseOrdersItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "algoId",
    ///    "algoStatus",
    ///    "algoType",
    ///    "avgPrice",
    ///    "bookTime",
    ///    "clientAlgoId",
    ///    "endTime",
    ///    "executedAmt",
    ///    "executedQty",
    ///    "positionSide",
    ///    "side",
    ///    "symbol",
    ///    "totalQty",
    ///    "urgency"
    ///  ],
    ///  "properties": {
    ///    "algoId": {
    ///      "examples": [
    ///        14517
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "algoStatus": {
    ///      "examples": [
    ///        "WORKING"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "algoType": {
    ///      "examples": [
    ///        "VP"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "avgPrice": {
    ///      "examples": [
    ///        "0.00"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "bookTime": {
    ///      "examples": [
    ///        1649756817004
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "clientAlgoId": {
    ///      "examples": [
    ///        "d7096549481642f8a0bb69e9e2e31f2e"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "endTime": {
    ///      "examples": [
    ///        1649757088101
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "executedAmt": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "executedQty": {
    ///      "examples": [
    ///        "0.000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "positionSide": {
    ///      "examples": [
    ///        "SHORT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "side": {
    ///      "examples": [
    ///        "SELL"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "symbol": {
    ///      "examples": [
    ///        "ETHUSDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalQty": {
    ///      "examples": [
    ///        "5.00"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "urgency": {
    ///      "examples": [
    ///        "LOW"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct AlgoFuturesHistoricalOrdersResponseOrdersItem {
        #[serde(rename = "algoId")]
        pub algo_id: i64,
        #[serde(rename = "algoStatus")]
        pub algo_status: String,
        #[serde(rename = "algoType")]
        pub algo_type: String,
        #[serde(rename = "avgPrice")]
        pub avg_price: String,
        #[serde(rename = "bookTime")]
        pub book_time: i64,
        #[serde(rename = "clientAlgoId")]
        pub client_algo_id: String,
        #[serde(rename = "endTime")]
        pub end_time: i64,
        #[serde(rename = "executedAmt")]
        pub executed_amt: String,
        #[serde(rename = "executedQty")]
        pub executed_qty: String,
        #[serde(rename = "positionSide")]
        pub position_side: String,
        pub side: String,
        pub symbol: String,
        #[serde(rename = "totalQty")]
        pub total_qty: String,
        pub urgency: String,
    }
    impl From<&AlgoFuturesHistoricalOrdersResponseOrdersItem>
    for AlgoFuturesHistoricalOrdersResponseOrdersItem {
        fn from(value: &AlgoFuturesHistoricalOrdersResponseOrdersItem) -> Self {
            value.clone()
        }
    }
    ///AlgoFuturesHistoricalOrdersSide
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "SELL"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "SELL",
    ///    "BUY"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum AlgoFuturesHistoricalOrdersSide {
        #[serde(rename = "SELL")]
        Sell,
        #[serde(rename = "BUY")]
        Buy,
    }
    impl From<&AlgoFuturesHistoricalOrdersSide> for AlgoFuturesHistoricalOrdersSide {
        fn from(value: &AlgoFuturesHistoricalOrdersSide) -> Self {
            value.clone()
        }
    }
    impl ToString for AlgoFuturesHistoricalOrdersSide {
        fn to_string(&self) -> String {
            match *self {
                Self::Sell => "SELL".to_string(),
                Self::Buy => "BUY".to_string(),
            }
        }
    }
    impl std::str::FromStr for AlgoFuturesHistoricalOrdersSide {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "SELL" => Ok(Self::Sell),
                "BUY" => Ok(Self::Buy),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for AlgoFuturesHistoricalOrdersSide {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for AlgoFuturesHistoricalOrdersSide {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for AlgoFuturesHistoricalOrdersSide {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///AlgoFuturesNewOrderTwapPositionSide
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "BOTH"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "BOTH",
    ///    "LONG",
    ///    "SHORT"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum AlgoFuturesNewOrderTwapPositionSide {
        #[serde(rename = "BOTH")]
        Both,
        #[serde(rename = "LONG")]
        Long,
        #[serde(rename = "SHORT")]
        Short,
    }
    impl From<&AlgoFuturesNewOrderTwapPositionSide>
    for AlgoFuturesNewOrderTwapPositionSide {
        fn from(value: &AlgoFuturesNewOrderTwapPositionSide) -> Self {
            value.clone()
        }
    }
    impl ToString for AlgoFuturesNewOrderTwapPositionSide {
        fn to_string(&self) -> String {
            match *self {
                Self::Both => "BOTH".to_string(),
                Self::Long => "LONG".to_string(),
                Self::Short => "SHORT".to_string(),
            }
        }
    }
    impl std::str::FromStr for AlgoFuturesNewOrderTwapPositionSide {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "BOTH" => Ok(Self::Both),
                "LONG" => Ok(Self::Long),
                "SHORT" => Ok(Self::Short),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for AlgoFuturesNewOrderTwapPositionSide {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for AlgoFuturesNewOrderTwapPositionSide {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for AlgoFuturesNewOrderTwapPositionSide {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///AlgoFuturesNewOrderTwapResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "clientAlgoId",
    ///    "code",
    ///    "msg",
    ///    "success"
    ///  ],
    ///  "properties": {
    ///    "clientAlgoId": {
    ///      "examples": [
    ///        "00358ce6a268403398bd34eaa36dffe7"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "code": {
    ///      "examples": [
    ///        0
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "msg": {
    ///      "examples": [
    ///        "OK"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "success": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct AlgoFuturesNewOrderTwapResponse {
        #[serde(rename = "clientAlgoId")]
        pub client_algo_id: String,
        pub code: i64,
        pub msg: String,
        pub success: bool,
    }
    impl From<&AlgoFuturesNewOrderTwapResponse> for AlgoFuturesNewOrderTwapResponse {
        fn from(value: &AlgoFuturesNewOrderTwapResponse) -> Self {
            value.clone()
        }
    }
    ///AlgoFuturesNewOrderTwapSide
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "SELL"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "SELL",
    ///    "BUY"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum AlgoFuturesNewOrderTwapSide {
        #[serde(rename = "SELL")]
        Sell,
        #[serde(rename = "BUY")]
        Buy,
    }
    impl From<&AlgoFuturesNewOrderTwapSide> for AlgoFuturesNewOrderTwapSide {
        fn from(value: &AlgoFuturesNewOrderTwapSide) -> Self {
            value.clone()
        }
    }
    impl ToString for AlgoFuturesNewOrderTwapSide {
        fn to_string(&self) -> String {
            match *self {
                Self::Sell => "SELL".to_string(),
                Self::Buy => "BUY".to_string(),
            }
        }
    }
    impl std::str::FromStr for AlgoFuturesNewOrderTwapSide {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "SELL" => Ok(Self::Sell),
                "BUY" => Ok(Self::Buy),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for AlgoFuturesNewOrderTwapSide {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for AlgoFuturesNewOrderTwapSide {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for AlgoFuturesNewOrderTwapSide {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///AlgoFuturesNewOrderVpPositionSide
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "BOTH"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "BOTH",
    ///    "LONG",
    ///    "SHORT"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum AlgoFuturesNewOrderVpPositionSide {
        #[serde(rename = "BOTH")]
        Both,
        #[serde(rename = "LONG")]
        Long,
        #[serde(rename = "SHORT")]
        Short,
    }
    impl From<&AlgoFuturesNewOrderVpPositionSide> for AlgoFuturesNewOrderVpPositionSide {
        fn from(value: &AlgoFuturesNewOrderVpPositionSide) -> Self {
            value.clone()
        }
    }
    impl ToString for AlgoFuturesNewOrderVpPositionSide {
        fn to_string(&self) -> String {
            match *self {
                Self::Both => "BOTH".to_string(),
                Self::Long => "LONG".to_string(),
                Self::Short => "SHORT".to_string(),
            }
        }
    }
    impl std::str::FromStr for AlgoFuturesNewOrderVpPositionSide {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "BOTH" => Ok(Self::Both),
                "LONG" => Ok(Self::Long),
                "SHORT" => Ok(Self::Short),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for AlgoFuturesNewOrderVpPositionSide {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for AlgoFuturesNewOrderVpPositionSide {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for AlgoFuturesNewOrderVpPositionSide {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///AlgoFuturesNewOrderVpResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "clientAlgoId",
    ///    "code",
    ///    "msg",
    ///    "success"
    ///  ],
    ///  "properties": {
    ///    "clientAlgoId": {
    ///      "examples": [
    ///        "00358ce6a268403398bd34eaa36dffe7"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "code": {
    ///      "examples": [
    ///        0
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "msg": {
    ///      "examples": [
    ///        "OK"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "success": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct AlgoFuturesNewOrderVpResponse {
        #[serde(rename = "clientAlgoId")]
        pub client_algo_id: String,
        pub code: i64,
        pub msg: String,
        pub success: bool,
    }
    impl From<&AlgoFuturesNewOrderVpResponse> for AlgoFuturesNewOrderVpResponse {
        fn from(value: &AlgoFuturesNewOrderVpResponse) -> Self {
            value.clone()
        }
    }
    ///AlgoFuturesNewOrderVpSide
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "SELL"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "SELL",
    ///    "BUY"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum AlgoFuturesNewOrderVpSide {
        #[serde(rename = "SELL")]
        Sell,
        #[serde(rename = "BUY")]
        Buy,
    }
    impl From<&AlgoFuturesNewOrderVpSide> for AlgoFuturesNewOrderVpSide {
        fn from(value: &AlgoFuturesNewOrderVpSide) -> Self {
            value.clone()
        }
    }
    impl ToString for AlgoFuturesNewOrderVpSide {
        fn to_string(&self) -> String {
            match *self {
                Self::Sell => "SELL".to_string(),
                Self::Buy => "BUY".to_string(),
            }
        }
    }
    impl std::str::FromStr for AlgoFuturesNewOrderVpSide {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "SELL" => Ok(Self::Sell),
                "BUY" => Ok(Self::Buy),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for AlgoFuturesNewOrderVpSide {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for AlgoFuturesNewOrderVpSide {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for AlgoFuturesNewOrderVpSide {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///AlgoFuturesNewOrderVpUrgency
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "LOW"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "LOW",
    ///    "MEDIUM",
    ///    "HIGH"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum AlgoFuturesNewOrderVpUrgency {
        #[serde(rename = "LOW")]
        Low,
        #[serde(rename = "MEDIUM")]
        Medium,
        #[serde(rename = "HIGH")]
        High,
    }
    impl From<&AlgoFuturesNewOrderVpUrgency> for AlgoFuturesNewOrderVpUrgency {
        fn from(value: &AlgoFuturesNewOrderVpUrgency) -> Self {
            value.clone()
        }
    }
    impl ToString for AlgoFuturesNewOrderVpUrgency {
        fn to_string(&self) -> String {
            match *self {
                Self::Low => "LOW".to_string(),
                Self::Medium => "MEDIUM".to_string(),
                Self::High => "HIGH".to_string(),
            }
        }
    }
    impl std::str::FromStr for AlgoFuturesNewOrderVpUrgency {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "LOW" => Ok(Self::Low),
                "MEDIUM" => Ok(Self::Medium),
                "HIGH" => Ok(Self::High),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for AlgoFuturesNewOrderVpUrgency {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for AlgoFuturesNewOrderVpUrgency {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for AlgoFuturesNewOrderVpUrgency {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///AlgoFuturesOpenOrdersResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "total"
    ///  ],
    ///  "properties": {
    ///    "orders": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "algoId",
    ///          "algoStatus",
    ///          "algoType",
    ///          "avgPrice",
    ///          "bookTime",
    ///          "clientAlgoId",
    ///          "endTime",
    ///          "executedAmt",
    ///          "executedQty",
    ///          "positionSide",
    ///          "side",
    ///          "symbol",
    ///          "totalQty",
    ///          "urgency"
    ///        ],
    ///        "properties": {
    ///          "algoId": {
    ///            "examples": [
    ///              14517
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "algoStatus": {
    ///            "examples": [
    ///              "WORKING"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "algoType": {
    ///            "examples": [
    ///              "VP"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "avgPrice": {
    ///            "examples": [
    ///              "0.00"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "bookTime": {
    ///            "examples": [
    ///              1649756817004
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "clientAlgoId": {
    ///            "examples": [
    ///              "d7096549481642f8a0bb69e9e2e31f2e"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "endTime": {
    ///            "examples": [
    ///              0
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "executedAmt": {
    ///            "examples": [
    ///              "0.00000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "executedQty": {
    ///            "examples": [
    ///              "0.000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "positionSide": {
    ///            "examples": [
    ///              "SHORT"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "side": {
    ///            "examples": [
    ///              "SELL"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "symbol": {
    ///            "examples": [
    ///              "ETHUSDT"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "totalQty": {
    ///            "examples": [
    ///              "5.00"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "urgency": {
    ///            "examples": [
    ///              "LOW"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "total": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct AlgoFuturesOpenOrdersResponse {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub orders: Vec<AlgoFuturesOpenOrdersResponseOrdersItem>,
        pub total: i32,
    }
    impl From<&AlgoFuturesOpenOrdersResponse> for AlgoFuturesOpenOrdersResponse {
        fn from(value: &AlgoFuturesOpenOrdersResponse) -> Self {
            value.clone()
        }
    }
    ///AlgoFuturesOpenOrdersResponseOrdersItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "algoId",
    ///    "algoStatus",
    ///    "algoType",
    ///    "avgPrice",
    ///    "bookTime",
    ///    "clientAlgoId",
    ///    "endTime",
    ///    "executedAmt",
    ///    "executedQty",
    ///    "positionSide",
    ///    "side",
    ///    "symbol",
    ///    "totalQty",
    ///    "urgency"
    ///  ],
    ///  "properties": {
    ///    "algoId": {
    ///      "examples": [
    ///        14517
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "algoStatus": {
    ///      "examples": [
    ///        "WORKING"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "algoType": {
    ///      "examples": [
    ///        "VP"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "avgPrice": {
    ///      "examples": [
    ///        "0.00"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "bookTime": {
    ///      "examples": [
    ///        1649756817004
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "clientAlgoId": {
    ///      "examples": [
    ///        "d7096549481642f8a0bb69e9e2e31f2e"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "endTime": {
    ///      "examples": [
    ///        0
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "executedAmt": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "executedQty": {
    ///      "examples": [
    ///        "0.000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "positionSide": {
    ///      "examples": [
    ///        "SHORT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "side": {
    ///      "examples": [
    ///        "SELL"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "symbol": {
    ///      "examples": [
    ///        "ETHUSDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalQty": {
    ///      "examples": [
    ///        "5.00"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "urgency": {
    ///      "examples": [
    ///        "LOW"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct AlgoFuturesOpenOrdersResponseOrdersItem {
        #[serde(rename = "algoId")]
        pub algo_id: i64,
        #[serde(rename = "algoStatus")]
        pub algo_status: String,
        #[serde(rename = "algoType")]
        pub algo_type: String,
        #[serde(rename = "avgPrice")]
        pub avg_price: String,
        #[serde(rename = "bookTime")]
        pub book_time: i64,
        #[serde(rename = "clientAlgoId")]
        pub client_algo_id: String,
        #[serde(rename = "endTime")]
        pub end_time: i64,
        #[serde(rename = "executedAmt")]
        pub executed_amt: String,
        #[serde(rename = "executedQty")]
        pub executed_qty: String,
        #[serde(rename = "positionSide")]
        pub position_side: String,
        pub side: String,
        pub symbol: String,
        #[serde(rename = "totalQty")]
        pub total_qty: String,
        pub urgency: String,
    }
    impl From<&AlgoFuturesOpenOrdersResponseOrdersItem>
    for AlgoFuturesOpenOrdersResponseOrdersItem {
        fn from(value: &AlgoFuturesOpenOrdersResponseOrdersItem) -> Self {
            value.clone()
        }
    }
    ///AlgoFuturesSubOrdersResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "executedAmt",
    ///    "executedQty",
    ///    "subOrders",
    ///    "total"
    ///  ],
    ///  "properties": {
    ///    "executedAmt": {
    ///      "examples": [
    ///        "3229.44000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "executedQty": {
    ///      "examples": [
    ///        "1.000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "subOrders": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "algoId",
    ///          "avgPrice",
    ///          "bookTime",
    ///          "executedAmt",
    ///          "feeAmt",
    ///          "feeAsset",
    ///          "orderId",
    ///          "orderStatus",
    ///          "origQty",
    ///          "side",
    ///          "subId",
    ///          "symbol",
    ///          "timeInForce"
    ///        ],
    ///        "properties": {
    ///          "algoId": {
    ///            "examples": [
    ///              13723
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "avgPrice": {
    ///            "examples": [
    ///              "3229.44"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "bookTime": {
    ///            "examples": [
    ///              1649756817004
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "executedAmt": {
    ///            "examples": [
    ///              "3229.44000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "executedQty": {
    ///            "examples": [
    ///              "1.000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "feeAmt": {
    ///            "examples": [
    ///              "-1.61471999"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "feeAsset": {
    ///            "examples": [
    ///              "USDT"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "orderId": {
    ///            "examples": [
    ///              8389765519993908929
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "orderStatus": {
    ///            "examples": [
    ///              "FILLED"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "origQty": {
    ///            "examples": [
    ///              "1.000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "side": {
    ///            "examples": [
    ///              "SELL"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "subId": {
    ///            "examples": [
    ///              1
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "symbol": {
    ///            "examples": [
    ///              "ETHUSDT"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "timeInForce": {
    ///            "examples": [
    ///              "IMMEDIATE_OR_CANCEL"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "total": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct AlgoFuturesSubOrdersResponse {
        #[serde(rename = "executedAmt")]
        pub executed_amt: String,
        #[serde(rename = "executedQty")]
        pub executed_qty: String,
        #[serde(rename = "subOrders")]
        pub sub_orders: Vec<AlgoFuturesSubOrdersResponseSubOrdersItem>,
        pub total: i32,
    }
    impl From<&AlgoFuturesSubOrdersResponse> for AlgoFuturesSubOrdersResponse {
        fn from(value: &AlgoFuturesSubOrdersResponse) -> Self {
            value.clone()
        }
    }
    ///AlgoFuturesSubOrdersResponseSubOrdersItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "algoId",
    ///    "avgPrice",
    ///    "bookTime",
    ///    "executedAmt",
    ///    "feeAmt",
    ///    "feeAsset",
    ///    "orderId",
    ///    "orderStatus",
    ///    "origQty",
    ///    "side",
    ///    "subId",
    ///    "symbol",
    ///    "timeInForce"
    ///  ],
    ///  "properties": {
    ///    "algoId": {
    ///      "examples": [
    ///        13723
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "avgPrice": {
    ///      "examples": [
    ///        "3229.44"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "bookTime": {
    ///      "examples": [
    ///        1649756817004
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "executedAmt": {
    ///      "examples": [
    ///        "3229.44000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "executedQty": {
    ///      "examples": [
    ///        "1.000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "feeAmt": {
    ///      "examples": [
    ///        "-1.61471999"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "feeAsset": {
    ///      "examples": [
    ///        "USDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "orderId": {
    ///      "examples": [
    ///        8389765519993908929
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "orderStatus": {
    ///      "examples": [
    ///        "FILLED"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "origQty": {
    ///      "examples": [
    ///        "1.000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "side": {
    ///      "examples": [
    ///        "SELL"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "subId": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "symbol": {
    ///      "examples": [
    ///        "ETHUSDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "timeInForce": {
    ///      "examples": [
    ///        "IMMEDIATE_OR_CANCEL"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct AlgoFuturesSubOrdersResponseSubOrdersItem {
        #[serde(rename = "algoId")]
        pub algo_id: i64,
        #[serde(rename = "avgPrice")]
        pub avg_price: String,
        #[serde(rename = "bookTime")]
        pub book_time: i64,
        #[serde(rename = "executedAmt")]
        pub executed_amt: String,
        #[serde(
            rename = "executedQty",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub executed_qty: Option<String>,
        #[serde(rename = "feeAmt")]
        pub fee_amt: String,
        #[serde(rename = "feeAsset")]
        pub fee_asset: String,
        #[serde(rename = "orderId")]
        pub order_id: i64,
        #[serde(rename = "orderStatus")]
        pub order_status: String,
        #[serde(rename = "origQty")]
        pub orig_qty: String,
        pub side: String,
        #[serde(rename = "subId")]
        pub sub_id: i64,
        pub symbol: String,
        #[serde(rename = "timeInForce")]
        pub time_in_force: String,
    }
    impl From<&AlgoFuturesSubOrdersResponseSubOrdersItem>
    for AlgoFuturesSubOrdersResponseSubOrdersItem {
        fn from(value: &AlgoFuturesSubOrdersResponseSubOrdersItem) -> Self {
            value.clone()
        }
    }
    ///AlgoSpotHistoricalOrdersResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "orders",
    ///    "total"
    ///  ],
    ///  "properties": {
    ///    "orders": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "algoId",
    ///          "algoStatus",
    ///          "algoType",
    ///          "avgPrice",
    ///          "bookTime",
    ///          "clientAlgoId",
    ///          "endTime",
    ///          "executedAmt",
    ///          "executedQty",
    ///          "side",
    ///          "symbol",
    ///          "totalQty",
    ///          "urgency"
    ///        ],
    ///        "properties": {
    ///          "algoId": {
    ///            "examples": [
    ///              14517
    ///            ],
    ///            "type": "integer"
    ///          },
    ///          "algoStatus": {
    ///            "examples": [
    ///              "WORKING"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "algoType": {
    ///            "examples": [
    ///              "VP"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "avgPrice": {
    ///            "examples": [
    ///              "0.00"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "bookTime": {
    ///            "examples": [
    ///              1649756817004
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "clientAlgoId": {
    ///            "examples": [
    ///              "d7096549481642f8a0bb69e9e2e31f2e"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "endTime": {
    ///            "examples": [
    ///              1649756817004
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "executedAmt": {
    ///            "examples": [
    ///              "0.000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "executedQty": {
    ///            "examples": [
    ///              "0.000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "side": {
    ///            "examples": [
    ///              "SELL"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "symbol": {
    ///            "examples": [
    ///              "ETHUSDT"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "totalQty": {
    ///            "examples": [
    ///              "5.000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "urgency": {
    ///            "examples": [
    ///              "LOW"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "total": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct AlgoSpotHistoricalOrdersResponse {
        pub orders: Vec<AlgoSpotHistoricalOrdersResponseOrdersItem>,
        pub total: i64,
    }
    impl From<&AlgoSpotHistoricalOrdersResponse> for AlgoSpotHistoricalOrdersResponse {
        fn from(value: &AlgoSpotHistoricalOrdersResponse) -> Self {
            value.clone()
        }
    }
    ///AlgoSpotHistoricalOrdersResponseOrdersItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "algoId",
    ///    "algoStatus",
    ///    "algoType",
    ///    "avgPrice",
    ///    "bookTime",
    ///    "clientAlgoId",
    ///    "endTime",
    ///    "executedAmt",
    ///    "executedQty",
    ///    "side",
    ///    "symbol",
    ///    "totalQty",
    ///    "urgency"
    ///  ],
    ///  "properties": {
    ///    "algoId": {
    ///      "examples": [
    ///        14517
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "algoStatus": {
    ///      "examples": [
    ///        "WORKING"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "algoType": {
    ///      "examples": [
    ///        "VP"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "avgPrice": {
    ///      "examples": [
    ///        "0.00"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "bookTime": {
    ///      "examples": [
    ///        1649756817004
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "clientAlgoId": {
    ///      "examples": [
    ///        "d7096549481642f8a0bb69e9e2e31f2e"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "endTime": {
    ///      "examples": [
    ///        1649756817004
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "executedAmt": {
    ///      "examples": [
    ///        "0.000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "executedQty": {
    ///      "examples": [
    ///        "0.000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "side": {
    ///      "examples": [
    ///        "SELL"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "symbol": {
    ///      "examples": [
    ///        "ETHUSDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalQty": {
    ///      "examples": [
    ///        "5.000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "urgency": {
    ///      "examples": [
    ///        "LOW"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct AlgoSpotHistoricalOrdersResponseOrdersItem {
        #[serde(rename = "algoId")]
        pub algo_id: i64,
        #[serde(rename = "algoStatus")]
        pub algo_status: String,
        #[serde(rename = "algoType")]
        pub algo_type: String,
        #[serde(rename = "avgPrice")]
        pub avg_price: String,
        #[serde(rename = "bookTime")]
        pub book_time: i64,
        #[serde(rename = "clientAlgoId")]
        pub client_algo_id: String,
        #[serde(rename = "endTime")]
        pub end_time: i64,
        #[serde(rename = "executedAmt")]
        pub executed_amt: String,
        #[serde(rename = "executedQty")]
        pub executed_qty: String,
        pub side: String,
        pub symbol: String,
        #[serde(rename = "totalQty")]
        pub total_qty: String,
        pub urgency: String,
    }
    impl From<&AlgoSpotHistoricalOrdersResponseOrdersItem>
    for AlgoSpotHistoricalOrdersResponseOrdersItem {
        fn from(value: &AlgoSpotHistoricalOrdersResponseOrdersItem) -> Self {
            value.clone()
        }
    }
    ///AlgoSpotHistoricalOrdersSide
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "SELL"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "SELL",
    ///    "BUY"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum AlgoSpotHistoricalOrdersSide {
        #[serde(rename = "SELL")]
        Sell,
        #[serde(rename = "BUY")]
        Buy,
    }
    impl From<&AlgoSpotHistoricalOrdersSide> for AlgoSpotHistoricalOrdersSide {
        fn from(value: &AlgoSpotHistoricalOrdersSide) -> Self {
            value.clone()
        }
    }
    impl ToString for AlgoSpotHistoricalOrdersSide {
        fn to_string(&self) -> String {
            match *self {
                Self::Sell => "SELL".to_string(),
                Self::Buy => "BUY".to_string(),
            }
        }
    }
    impl std::str::FromStr for AlgoSpotHistoricalOrdersSide {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "SELL" => Ok(Self::Sell),
                "BUY" => Ok(Self::Buy),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for AlgoSpotHistoricalOrdersSide {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for AlgoSpotHistoricalOrdersSide {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for AlgoSpotHistoricalOrdersSide {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///AlgoSpotNewOrderTwapResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "clientAlgoId",
    ///    "code",
    ///    "msg",
    ///    "success"
    ///  ],
    ///  "properties": {
    ///    "clientAlgoId": {
    ///      "examples": [
    ///        "65ce1630101a480b85915d7e11fd5078"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "code": {
    ///      "examples": [
    ///        0
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "msg": {
    ///      "examples": [
    ///        "OK"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "success": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct AlgoSpotNewOrderTwapResponse {
        #[serde(rename = "clientAlgoId")]
        pub client_algo_id: String,
        pub code: i64,
        pub msg: String,
        pub success: bool,
    }
    impl From<&AlgoSpotNewOrderTwapResponse> for AlgoSpotNewOrderTwapResponse {
        fn from(value: &AlgoSpotNewOrderTwapResponse) -> Self {
            value.clone()
        }
    }
    ///AlgoSpotNewOrderTwapSide
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "SELL"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "SELL",
    ///    "BUY"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum AlgoSpotNewOrderTwapSide {
        #[serde(rename = "SELL")]
        Sell,
        #[serde(rename = "BUY")]
        Buy,
    }
    impl From<&AlgoSpotNewOrderTwapSide> for AlgoSpotNewOrderTwapSide {
        fn from(value: &AlgoSpotNewOrderTwapSide) -> Self {
            value.clone()
        }
    }
    impl ToString for AlgoSpotNewOrderTwapSide {
        fn to_string(&self) -> String {
            match *self {
                Self::Sell => "SELL".to_string(),
                Self::Buy => "BUY".to_string(),
            }
        }
    }
    impl std::str::FromStr for AlgoSpotNewOrderTwapSide {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "SELL" => Ok(Self::Sell),
                "BUY" => Ok(Self::Buy),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for AlgoSpotNewOrderTwapSide {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for AlgoSpotNewOrderTwapSide {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for AlgoSpotNewOrderTwapSide {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///AlgoSpotOpenOrdersResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "orders",
    ///    "total"
    ///  ],
    ///  "properties": {
    ///    "orders": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "algoId",
    ///          "algoStatus",
    ///          "algoType",
    ///          "avgPrice",
    ///          "bookTime",
    ///          "clientAlgoId",
    ///          "endTime",
    ///          "executedAmt",
    ///          "executedQty",
    ///          "side",
    ///          "symbol",
    ///          "totalQty",
    ///          "urgency"
    ///        ],
    ///        "properties": {
    ///          "algoId": {
    ///            "examples": [
    ///              14517
    ///            ],
    ///            "type": "integer"
    ///          },
    ///          "algoStatus": {
    ///            "examples": [
    ///              "WORKING"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "algoType": {
    ///            "examples": [
    ///              "TWAP"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "avgPrice": {
    ///            "examples": [
    ///              "0.00"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "bookTime": {
    ///            "examples": [
    ///              1649756817004
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "clientAlgoId": {
    ///            "examples": [
    ///              "d7096549481642f8a0bb69e9e2e31f2e"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "endTime": {
    ///            "examples": [
    ///              1649756817004
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "executedAmt": {
    ///            "examples": [
    ///              "0.000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "executedQty": {
    ///            "examples": [
    ///              "0.000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "side": {
    ///            "examples": [
    ///              "SELL"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "symbol": {
    ///            "examples": [
    ///              "ETHUSDT"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "totalQty": {
    ///            "examples": [
    ///              "5.000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "urgency": {
    ///            "examples": [
    ///              "LOW"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "total": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct AlgoSpotOpenOrdersResponse {
        pub orders: Vec<AlgoSpotOpenOrdersResponseOrdersItem>,
        pub total: i64,
    }
    impl From<&AlgoSpotOpenOrdersResponse> for AlgoSpotOpenOrdersResponse {
        fn from(value: &AlgoSpotOpenOrdersResponse) -> Self {
            value.clone()
        }
    }
    ///AlgoSpotOpenOrdersResponseOrdersItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "algoId",
    ///    "algoStatus",
    ///    "algoType",
    ///    "avgPrice",
    ///    "bookTime",
    ///    "clientAlgoId",
    ///    "endTime",
    ///    "executedAmt",
    ///    "executedQty",
    ///    "side",
    ///    "symbol",
    ///    "totalQty",
    ///    "urgency"
    ///  ],
    ///  "properties": {
    ///    "algoId": {
    ///      "examples": [
    ///        14517
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "algoStatus": {
    ///      "examples": [
    ///        "WORKING"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "algoType": {
    ///      "examples": [
    ///        "TWAP"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "avgPrice": {
    ///      "examples": [
    ///        "0.00"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "bookTime": {
    ///      "examples": [
    ///        1649756817004
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "clientAlgoId": {
    ///      "examples": [
    ///        "d7096549481642f8a0bb69e9e2e31f2e"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "endTime": {
    ///      "examples": [
    ///        1649756817004
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "executedAmt": {
    ///      "examples": [
    ///        "0.000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "executedQty": {
    ///      "examples": [
    ///        "0.000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "side": {
    ///      "examples": [
    ///        "SELL"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "symbol": {
    ///      "examples": [
    ///        "ETHUSDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalQty": {
    ///      "examples": [
    ///        "5.000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "urgency": {
    ///      "examples": [
    ///        "LOW"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct AlgoSpotOpenOrdersResponseOrdersItem {
        #[serde(rename = "algoId")]
        pub algo_id: i64,
        #[serde(rename = "algoStatus")]
        pub algo_status: String,
        #[serde(rename = "algoType")]
        pub algo_type: String,
        #[serde(rename = "avgPrice")]
        pub avg_price: String,
        #[serde(rename = "bookTime")]
        pub book_time: i64,
        #[serde(rename = "clientAlgoId")]
        pub client_algo_id: String,
        #[serde(rename = "endTime")]
        pub end_time: i64,
        #[serde(rename = "executedAmt")]
        pub executed_amt: String,
        #[serde(rename = "executedQty")]
        pub executed_qty: String,
        pub side: String,
        pub symbol: String,
        #[serde(rename = "totalQty")]
        pub total_qty: String,
        pub urgency: String,
    }
    impl From<&AlgoSpotOpenOrdersResponseOrdersItem>
    for AlgoSpotOpenOrdersResponseOrdersItem {
        fn from(value: &AlgoSpotOpenOrdersResponseOrdersItem) -> Self {
            value.clone()
        }
    }
    ///AlgoSpotSubOrdersResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "executedAmt",
    ///    "executedQty",
    ///    "subOrders",
    ///    "total"
    ///  ],
    ///  "properties": {
    ///    "executedAmt": {
    ///      "examples": [
    ///        "3229.44000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "executedQty": {
    ///      "examples": [
    ///        "1.000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "subOrders": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "algoId",
    ///          "avgPrice",
    ///          "bookTime",
    ///          "executedAmt",
    ///          "executedQty",
    ///          "feeAmt",
    ///          "feeAsset",
    ///          "orderId",
    ///          "orderStatus",
    ///          "origQty",
    ///          "side",
    ///          "subId",
    ///          "symbol",
    ///          "timeInForce"
    ///        ],
    ///        "properties": {
    ///          "algoId": {
    ///            "examples": [
    ///              14517
    ///            ],
    ///            "type": "integer"
    ///          },
    ///          "avgPrice": {
    ///            "examples": [
    ///              "3229.44"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "bookTime": {
    ///            "examples": [
    ///              1649319001964
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "executedAmt": {
    ///            "examples": [
    ///              "0.000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "executedQty": {
    ///            "examples": [
    ///              "0.000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "feeAmt": {
    ///            "examples": [
    ///              "-1.61471999"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "feeAsset": {
    ///            "examples": [
    ///              "USDT"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "orderId": {
    ///            "examples": [
    ///              8389765519993908929
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "orderStatus": {
    ///            "examples": [
    ///              "FILLED"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "origQty": {
    ///            "examples": [
    ///              "1.000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "side": {
    ///            "examples": [
    ///              "SELL"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "subId": {
    ///            "examples": [
    ///              1
    ///            ],
    ///            "type": "integer"
    ///          },
    ///          "symbol": {
    ///            "examples": [
    ///              "ETHUSDT"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "timeInForce": {
    ///            "examples": [
    ///              "IMMEDIATE_OR_CANCEL"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "total": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct AlgoSpotSubOrdersResponse {
        #[serde(rename = "executedAmt")]
        pub executed_amt: String,
        #[serde(rename = "executedQty")]
        pub executed_qty: String,
        #[serde(rename = "subOrders")]
        pub sub_orders: Vec<AlgoSpotSubOrdersResponseSubOrdersItem>,
        pub total: i64,
    }
    impl From<&AlgoSpotSubOrdersResponse> for AlgoSpotSubOrdersResponse {
        fn from(value: &AlgoSpotSubOrdersResponse) -> Self {
            value.clone()
        }
    }
    ///AlgoSpotSubOrdersResponseSubOrdersItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "algoId",
    ///    "avgPrice",
    ///    "bookTime",
    ///    "executedAmt",
    ///    "executedQty",
    ///    "feeAmt",
    ///    "feeAsset",
    ///    "orderId",
    ///    "orderStatus",
    ///    "origQty",
    ///    "side",
    ///    "subId",
    ///    "symbol",
    ///    "timeInForce"
    ///  ],
    ///  "properties": {
    ///    "algoId": {
    ///      "examples": [
    ///        14517
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "avgPrice": {
    ///      "examples": [
    ///        "3229.44"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "bookTime": {
    ///      "examples": [
    ///        1649319001964
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "executedAmt": {
    ///      "examples": [
    ///        "0.000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "executedQty": {
    ///      "examples": [
    ///        "0.000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "feeAmt": {
    ///      "examples": [
    ///        "-1.61471999"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "feeAsset": {
    ///      "examples": [
    ///        "USDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "orderId": {
    ///      "examples": [
    ///        8389765519993908929
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "orderStatus": {
    ///      "examples": [
    ///        "FILLED"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "origQty": {
    ///      "examples": [
    ///        "1.000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "side": {
    ///      "examples": [
    ///        "SELL"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "subId": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "symbol": {
    ///      "examples": [
    ///        "ETHUSDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "timeInForce": {
    ///      "examples": [
    ///        "IMMEDIATE_OR_CANCEL"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct AlgoSpotSubOrdersResponseSubOrdersItem {
        #[serde(rename = "algoId")]
        pub algo_id: i64,
        #[serde(rename = "avgPrice")]
        pub avg_price: String,
        #[serde(rename = "bookTime")]
        pub book_time: i64,
        #[serde(rename = "executedAmt")]
        pub executed_amt: String,
        #[serde(rename = "executedQty")]
        pub executed_qty: String,
        #[serde(rename = "feeAmt")]
        pub fee_amt: String,
        #[serde(rename = "feeAsset")]
        pub fee_asset: String,
        #[serde(rename = "orderId")]
        pub order_id: i64,
        #[serde(rename = "orderStatus")]
        pub order_status: String,
        #[serde(rename = "origQty")]
        pub orig_qty: String,
        pub side: String,
        #[serde(rename = "subId")]
        pub sub_id: i64,
        pub symbol: String,
        #[serde(rename = "timeInForce")]
        pub time_in_force: String,
    }
    impl From<&AlgoSpotSubOrdersResponseSubOrdersItem>
    for AlgoSpotSubOrdersResponseSubOrdersItem {
        fn from(value: &AlgoSpotSubOrdersResponseSubOrdersItem) -> Self {
            value.clone()
        }
    }
    ///AllOrderListResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "contingencyType",
    ///    "isIsolated",
    ///    "listClientOrderId",
    ///    "listOrderStatus",
    ///    "listStatusType",
    ///    "orderListId",
    ///    "orders",
    ///    "symbol",
    ///    "transactionTime"
    ///  ],
    ///  "properties": {
    ///    "contingencyType": {
    ///      "examples": [
    ///        "OCO"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "isIsolated": {
    ///      "type": "boolean"
    ///    },
    ///    "listClientOrderId": {
    ///      "examples": [
    ///        "amEEAXryFzFwYF1FeRpUoZ"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "listOrderStatus": {
    ///      "examples": [
    ///        "EXECUTING"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "listStatusType": {
    ///      "examples": [
    ///        "EXEC_STARTED"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "orderListId": {
    ///      "examples": [
    ///        29
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "orders": {
    ///      "type": "array",
    ///      "items": {
    ///        "examples": [
    ///          [
    ///            {
    ///              "clientOrderId": "oD7aesZqjEGlZrbtRpy5zB",
    ///              "orderId": 4,
    ///              "symbol": "LTCBTC"
    ///            },
    ///            {
    ///              "clientOrderId": "Jr1h6xirOxgeJOUuYQS7V3",
    ///              "orderId": 5,
    ///              "symbol": "LTCBTC"
    ///            }
    ///          ]
    ///        ],
    ///        "type": "object",
    ///        "required": [
    ///          "clientOrderId",
    ///          "orderId",
    ///          "symbol"
    ///        ],
    ///        "properties": {
    ///          "clientOrderId": {
    ///            "type": "string"
    ///          },
    ///          "orderId": {
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "symbol": {
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "symbol": {
    ///      "examples": [
    ///        "LTCBTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "transactionTime": {
    ///      "examples": [
    ///        1565245913483
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct AllOrderListResponseItem {
        #[serde(rename = "contingencyType")]
        pub contingency_type: String,
        #[serde(rename = "isIsolated")]
        pub is_isolated: bool,
        #[serde(rename = "listClientOrderId")]
        pub list_client_order_id: String,
        #[serde(rename = "listOrderStatus")]
        pub list_order_status: String,
        #[serde(rename = "listStatusType")]
        pub list_status_type: String,
        #[serde(rename = "orderListId")]
        pub order_list_id: i64,
        pub orders: Vec<AllOrderListResponseItemOrdersItem>,
        pub symbol: String,
        #[serde(rename = "transactionTime")]
        pub transaction_time: i64,
    }
    impl From<&AllOrderListResponseItem> for AllOrderListResponseItem {
        fn from(value: &AllOrderListResponseItem) -> Self {
            value.clone()
        }
    }
    ///AllOrderListResponseItemOrdersItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    [
    ///      {
    ///        "clientOrderId": "oD7aesZqjEGlZrbtRpy5zB",
    ///        "orderId": 4,
    ///        "symbol": "LTCBTC"
    ///      },
    ///      {
    ///        "clientOrderId": "Jr1h6xirOxgeJOUuYQS7V3",
    ///        "orderId": 5,
    ///        "symbol": "LTCBTC"
    ///      }
    ///    ]
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "clientOrderId",
    ///    "orderId",
    ///    "symbol"
    ///  ],
    ///  "properties": {
    ///    "clientOrderId": {
    ///      "type": "string"
    ///    },
    ///    "orderId": {
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "symbol": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct AllOrderListResponseItemOrdersItem {
        #[serde(rename = "clientOrderId")]
        pub client_order_id: String,
        #[serde(rename = "orderId")]
        pub order_id: i64,
        pub symbol: String,
    }
    impl From<&AllOrderListResponseItemOrdersItem>
    for AllOrderListResponseItemOrdersItem {
        fn from(value: &AllOrderListResponseItemOrdersItem) -> Self {
            value.clone()
        }
    }
    ///ApplyForMarginLoanIsIsolated
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "TRUE",
    ///    "FALSE"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum ApplyForMarginLoanIsIsolated {
        #[serde(rename = "TRUE")]
        True,
        #[serde(rename = "FALSE")]
        False,
    }
    impl From<&ApplyForMarginLoanIsIsolated> for ApplyForMarginLoanIsIsolated {
        fn from(value: &ApplyForMarginLoanIsIsolated) -> Self {
            value.clone()
        }
    }
    impl ToString for ApplyForMarginLoanIsIsolated {
        fn to_string(&self) -> String {
            match *self {
                Self::True => "TRUE".to_string(),
                Self::False => "FALSE".to_string(),
            }
        }
    }
    impl std::str::FromStr for ApplyForMarginLoanIsIsolated {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "TRUE" => Ok(Self::True),
                "FALSE" => Ok(Self::False),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for ApplyForMarginLoanIsIsolated {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for ApplyForMarginLoanIsIsolated {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for ApplyForMarginLoanIsIsolated {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///AssetAssetDetailResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "CTR"
    ///  ],
    ///  "properties": {
    ///    "CTR": {
    ///      "type": "object",
    ///      "required": [
    ///        "depositStatus",
    ///        "depositTip",
    ///        "minWithdrawAmount",
    ///        "withdrawFee",
    ///        "withdrawStatus"
    ///      ],
    ///      "properties": {
    ///        "depositStatus": {
    ///          "description": "deposit status (false if ALL of networks' are false)",
    ///          "examples": [
    ///            false
    ///          ],
    ///          "type": "boolean"
    ///        },
    ///        "depositTip": {
    ///          "examples": [
    ///            "Delisted, Deposit Suspended"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "minWithdrawAmount": {
    ///          "examples": [
    ///            "70.00000000"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "withdrawFee": {
    ///          "examples": [
    ///            35
    ///          ],
    ///          "type": "integer",
    ///          "format": "int64"
    ///        },
    ///        "withdrawStatus": {
    ///          "description": "withdrawStatus status (false if ALL of networks' are false)",
    ///          "type": "boolean"
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct AssetAssetDetailResponse {
        #[serde(rename = "CTR")]
        pub ctr: AssetAssetDetailResponseCtr,
    }
    impl From<&AssetAssetDetailResponse> for AssetAssetDetailResponse {
        fn from(value: &AssetAssetDetailResponse) -> Self {
            value.clone()
        }
    }
    ///AssetAssetDetailResponseCtr
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "depositStatus",
    ///    "depositTip",
    ///    "minWithdrawAmount",
    ///    "withdrawFee",
    ///    "withdrawStatus"
    ///  ],
    ///  "properties": {
    ///    "depositStatus": {
    ///      "description": "deposit status (false if ALL of networks' are false)",
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "depositTip": {
    ///      "examples": [
    ///        "Delisted, Deposit Suspended"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "minWithdrawAmount": {
    ///      "examples": [
    ///        "70.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "withdrawFee": {
    ///      "examples": [
    ///        35
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "withdrawStatus": {
    ///      "description": "withdrawStatus status (false if ALL of networks' are false)",
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct AssetAssetDetailResponseCtr {
        ///deposit status (false if ALL of networks' are false)
        #[serde(rename = "depositStatus")]
        pub deposit_status: bool,
        #[serde(rename = "depositTip")]
        pub deposit_tip: String,
        #[serde(rename = "minWithdrawAmount")]
        pub min_withdraw_amount: String,
        #[serde(rename = "withdrawFee")]
        pub withdraw_fee: i64,
        ///withdrawStatus status (false if ALL of networks' are false)
        #[serde(rename = "withdrawStatus")]
        pub withdraw_status: bool,
    }
    impl From<&AssetAssetDetailResponseCtr> for AssetAssetDetailResponseCtr {
        fn from(value: &AssetAssetDetailResponseCtr) -> Self {
            value.clone()
        }
    }
    ///AssetAssetDividendResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "rows",
    ///    "total"
    ///  ],
    ///  "properties": {
    ///    "rows": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "amount",
    ///          "asset",
    ///          "divTime",
    ///          "enInfo",
    ///          "id",
    ///          "tranId"
    ///        ],
    ///        "properties": {
    ///          "amount": {
    ///            "examples": [
    ///              "10.00000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "asset": {
    ///            "examples": [
    ///              "BHFT"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "divTime": {
    ///            "examples": [
    ///              1563189166000
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "enInfo": {
    ///            "examples": [
    ///              "BHFT distribution"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "id": {
    ///            "examples": [
    ///              242006910
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "tranId": {
    ///            "examples": [
    ///              2968885920
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "total": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct AssetAssetDividendResponse {
        pub rows: Vec<AssetAssetDividendResponseRowsItem>,
        pub total: i32,
    }
    impl From<&AssetAssetDividendResponse> for AssetAssetDividendResponse {
        fn from(value: &AssetAssetDividendResponse) -> Self {
            value.clone()
        }
    }
    ///AssetAssetDividendResponseRowsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "asset",
    ///    "divTime",
    ///    "enInfo",
    ///    "id",
    ///    "tranId"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "examples": [
    ///        "10.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "asset": {
    ///      "examples": [
    ///        "BHFT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "divTime": {
    ///      "examples": [
    ///        1563189166000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "enInfo": {
    ///      "examples": [
    ///        "BHFT distribution"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "examples": [
    ///        242006910
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "tranId": {
    ///      "examples": [
    ///        2968885920
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct AssetAssetDividendResponseRowsItem {
        pub amount: String,
        pub asset: String,
        #[serde(rename = "divTime")]
        pub div_time: i64,
        #[serde(rename = "enInfo")]
        pub en_info: String,
        pub id: i64,
        #[serde(rename = "tranId")]
        pub tran_id: i64,
    }
    impl From<&AssetAssetDividendResponseRowsItem>
    for AssetAssetDividendResponseRowsItem {
        fn from(value: &AssetAssetDividendResponseRowsItem) -> Self {
            value.clone()
        }
    }
    ///AssetConvertTransferQueryByPageAccountType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "MAIN",
    ///    "CARD"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum AssetConvertTransferQueryByPageAccountType {
        #[serde(rename = "MAIN")]
        Main,
        #[serde(rename = "CARD")]
        Card,
    }
    impl From<&AssetConvertTransferQueryByPageAccountType>
    for AssetConvertTransferQueryByPageAccountType {
        fn from(value: &AssetConvertTransferQueryByPageAccountType) -> Self {
            value.clone()
        }
    }
    impl ToString for AssetConvertTransferQueryByPageAccountType {
        fn to_string(&self) -> String {
            match *self {
                Self::Main => "MAIN".to_string(),
                Self::Card => "CARD".to_string(),
            }
        }
    }
    impl std::str::FromStr for AssetConvertTransferQueryByPageAccountType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "MAIN" => Ok(Self::Main),
                "CARD" => Ok(Self::Card),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for AssetConvertTransferQueryByPageAccountType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for AssetConvertTransferQueryByPageAccountType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for AssetConvertTransferQueryByPageAccountType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///AssetConvertTransferQueryByPageResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "rows",
    ///    "total"
    ///  ],
    ///  "properties": {
    ///    "rows": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "accountType",
    ///          "deductedAmount",
    ///          "deductedAsset",
    ///          "status",
    ///          "targetAmount",
    ///          "targetAsset",
    ///          "time",
    ///          "tranId",
    ///          "type"
    ///        ],
    ///        "properties": {
    ///          "accountType": {
    ///            "examples": [
    ///              "MAIN"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "deductedAmount": {
    ///            "examples": [
    ///              "1"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "deductedAsset": {
    ///            "examples": [
    ///              "BUSD"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "status": {
    ///            "examples": [
    ///              "S"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "targetAmount": {
    ///            "examples": [
    ///              "1"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "targetAsset": {
    ///            "examples": [
    ///              "USDC"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "time": {
    ///            "examples": [
    ///              1664442078000
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "tranId": {
    ///            "examples": [
    ///              118263407119
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "type": {
    ///            "examples": [
    ///              244
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "total": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct AssetConvertTransferQueryByPageResponse {
        pub rows: Vec<AssetConvertTransferQueryByPageResponseRowsItem>,
        pub total: i32,
    }
    impl From<&AssetConvertTransferQueryByPageResponse>
    for AssetConvertTransferQueryByPageResponse {
        fn from(value: &AssetConvertTransferQueryByPageResponse) -> Self {
            value.clone()
        }
    }
    ///AssetConvertTransferQueryByPageResponseRowsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "accountType",
    ///    "deductedAmount",
    ///    "deductedAsset",
    ///    "status",
    ///    "targetAmount",
    ///    "targetAsset",
    ///    "time",
    ///    "tranId",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "accountType": {
    ///      "examples": [
    ///        "MAIN"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "deductedAmount": {
    ///      "examples": [
    ///        "1"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "deductedAsset": {
    ///      "examples": [
    ///        "BUSD"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "examples": [
    ///        "S"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "targetAmount": {
    ///      "examples": [
    ///        "1"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "targetAsset": {
    ///      "examples": [
    ///        "USDC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "time": {
    ///      "examples": [
    ///        1664442078000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "tranId": {
    ///      "examples": [
    ///        118263407119
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "type": {
    ///      "examples": [
    ///        244
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct AssetConvertTransferQueryByPageResponseRowsItem {
        #[serde(rename = "accountType")]
        pub account_type: String,
        #[serde(rename = "deductedAmount")]
        pub deducted_amount: String,
        #[serde(rename = "deductedAsset")]
        pub deducted_asset: String,
        pub status: String,
        #[serde(rename = "targetAmount")]
        pub target_amount: String,
        #[serde(rename = "targetAsset")]
        pub target_asset: String,
        pub time: i64,
        #[serde(rename = "tranId")]
        pub tran_id: i64,
        #[serde(rename = "type")]
        pub type_: i64,
    }
    impl From<&AssetConvertTransferQueryByPageResponseRowsItem>
    for AssetConvertTransferQueryByPageResponseRowsItem {
        fn from(value: &AssetConvertTransferQueryByPageResponseRowsItem) -> Self {
            value.clone()
        }
    }
    ///AssetConvertTransferResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "status",
    ///    "tranId"
    ///  ],
    ///  "properties": {
    ///    "status": {
    ///      "examples": [
    ///        "S"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "tranId": {
    ///      "examples": [
    ///        118263407119
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct AssetConvertTransferResponse {
        pub status: String,
        #[serde(rename = "tranId")]
        pub tran_id: i64,
    }
    impl From<&AssetConvertTransferResponse> for AssetConvertTransferResponse {
        fn from(value: &AssetConvertTransferResponse) -> Self {
            value.clone()
        }
    }
    ///AssetCustodyTransferHistoryResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "rows",
    ///    "total"
    ///  ],
    ///  "properties": {
    ///    "rows": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "amount",
    ///          "asset",
    ///          "clientTranId",
    ///          "time",
    ///          "transferType"
    ///        ],
    ///        "properties": {
    ///          "amount": {
    ///            "examples": [
    ///              "1"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "asset": {
    ///            "examples": [
    ///              "ETH"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "clientTranId": {
    ///            "examples": [
    ///              "293915932290879488"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "time": {
    ///            "examples": [
    ///              1695205406000
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "transferType": {
    ///            "examples": [
    ///              "Undelegate"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "total": {
    ///      "examples": [
    ///        3316
    ///      ],
    ///      "type": "integer"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct AssetCustodyTransferHistoryResponse {
        pub rows: Vec<AssetCustodyTransferHistoryResponseRowsItem>,
        pub total: i64,
    }
    impl From<&AssetCustodyTransferHistoryResponse>
    for AssetCustodyTransferHistoryResponse {
        fn from(value: &AssetCustodyTransferHistoryResponse) -> Self {
            value.clone()
        }
    }
    ///AssetCustodyTransferHistoryResponseRowsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "asset",
    ///    "clientTranId",
    ///    "time",
    ///    "transferType"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "examples": [
    ///        "1"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "asset": {
    ///      "examples": [
    ///        "ETH"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "clientTranId": {
    ///      "examples": [
    ///        "293915932290879488"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "time": {
    ///      "examples": [
    ///        1695205406000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "transferType": {
    ///      "examples": [
    ///        "Undelegate"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct AssetCustodyTransferHistoryResponseRowsItem {
        pub amount: String,
        pub asset: String,
        #[serde(rename = "clientTranId")]
        pub client_tran_id: String,
        pub time: i64,
        #[serde(rename = "transferType")]
        pub transfer_type: String,
    }
    impl From<&AssetCustodyTransferHistoryResponseRowsItem>
    for AssetCustodyTransferHistoryResponseRowsItem {
        fn from(value: &AssetCustodyTransferHistoryResponseRowsItem) -> Self {
            value.clone()
        }
    }
    ///AssetDribbletResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "total",
    ///    "userAssetDribblets"
    ///  ],
    ///  "properties": {
    ///    "total": {
    ///      "description": "Total counts of exchange",
    ///      "examples": [
    ///        8
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "userAssetDribblets": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "operateTime",
    ///          "totalServiceChargeAmount",
    ///          "totalTransferedAmount",
    ///          "transId",
    ///          "userAssetDribbletDetails"
    ///        ],
    ///        "properties": {
    ///          "operateTime": {
    ///            "examples": [
    ///              1615985535000
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "totalServiceChargeAmount": {
    ///            "description": "Total service charge amount for this exchange.",
    ///            "examples": [
    ///              "0.00002699"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "totalTransferedAmount": {
    ///            "description": "Total transfered BNB amount for this exchange.",
    ///            "examples": [
    ///              "0.00132256"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "transId": {
    ///            "examples": [
    ///              45178372831
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "userAssetDribbletDetails": {
    ///            "type": "array",
    ///            "items": {
    ///              "type": "object",
    ///              "required": [
    ///                "amount",
    ///                "fromAsset",
    ///                "operateTime",
    ///                "serviceChargeAmount",
    ///                "transId",
    ///                "transferedAmount"
    ///              ],
    ///              "properties": {
    ///                "amount": {
    ///                  "examples": [
    ///                    "0.0009"
    ///                  ],
    ///                  "type": "string"
    ///                },
    ///                "fromAsset": {
    ///                  "examples": [
    ///                    "USDT"
    ///                  ],
    ///                  "type": "string"
    ///                },
    ///                "operateTime": {
    ///                  "examples": [
    ///                    1615985535000
    ///                  ],
    ///                  "type": "integer",
    ///                  "format": "int64"
    ///                },
    ///                "serviceChargeAmount": {
    ///                  "examples": [
    ///                    "0.000009"
    ///                  ],
    ///                  "type": "string"
    ///                },
    ///                "transId": {
    ///                  "examples": [
    ///                    4359321
    ///                  ],
    ///                  "type": "integer",
    ///                  "format": "int64"
    ///                },
    ///                "transferedAmount": {
    ///                  "examples": [
    ///                    "0.000441"
    ///                  ],
    ///                  "type": "string"
    ///                }
    ///              }
    ///            }
    ///          }
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct AssetDribbletResponse {
        ///Total counts of exchange
        pub total: i64,
        #[serde(rename = "userAssetDribblets")]
        pub user_asset_dribblets: Vec<AssetDribbletResponseUserAssetDribbletsItem>,
    }
    impl From<&AssetDribbletResponse> for AssetDribbletResponse {
        fn from(value: &AssetDribbletResponse) -> Self {
            value.clone()
        }
    }
    ///AssetDribbletResponseUserAssetDribbletsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "operateTime",
    ///    "totalServiceChargeAmount",
    ///    "totalTransferedAmount",
    ///    "transId",
    ///    "userAssetDribbletDetails"
    ///  ],
    ///  "properties": {
    ///    "operateTime": {
    ///      "examples": [
    ///        1615985535000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "totalServiceChargeAmount": {
    ///      "description": "Total service charge amount for this exchange.",
    ///      "examples": [
    ///        "0.00002699"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalTransferedAmount": {
    ///      "description": "Total transfered BNB amount for this exchange.",
    ///      "examples": [
    ///        "0.00132256"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "transId": {
    ///      "examples": [
    ///        45178372831
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "userAssetDribbletDetails": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "amount",
    ///          "fromAsset",
    ///          "operateTime",
    ///          "serviceChargeAmount",
    ///          "transId",
    ///          "transferedAmount"
    ///        ],
    ///        "properties": {
    ///          "amount": {
    ///            "examples": [
    ///              "0.0009"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "fromAsset": {
    ///            "examples": [
    ///              "USDT"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "operateTime": {
    ///            "examples": [
    ///              1615985535000
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "serviceChargeAmount": {
    ///            "examples": [
    ///              "0.000009"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "transId": {
    ///            "examples": [
    ///              4359321
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "transferedAmount": {
    ///            "examples": [
    ///              "0.000441"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct AssetDribbletResponseUserAssetDribbletsItem {
        #[serde(rename = "operateTime")]
        pub operate_time: i64,
        ///Total service charge amount for this exchange.
        #[serde(rename = "totalServiceChargeAmount")]
        pub total_service_charge_amount: String,
        ///Total transfered BNB amount for this exchange.
        #[serde(rename = "totalTransferedAmount")]
        pub total_transfered_amount: String,
        #[serde(rename = "transId")]
        pub trans_id: i64,
        #[serde(rename = "userAssetDribbletDetails")]
        pub user_asset_dribblet_details: Vec<
            AssetDribbletResponseUserAssetDribbletsItemUserAssetDribbletDetailsItem,
        >,
    }
    impl From<&AssetDribbletResponseUserAssetDribbletsItem>
    for AssetDribbletResponseUserAssetDribbletsItem {
        fn from(value: &AssetDribbletResponseUserAssetDribbletsItem) -> Self {
            value.clone()
        }
    }
    ///AssetDribbletResponseUserAssetDribbletsItemUserAssetDribbletDetailsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "fromAsset",
    ///    "operateTime",
    ///    "serviceChargeAmount",
    ///    "transId",
    ///    "transferedAmount"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "examples": [
    ///        "0.0009"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "fromAsset": {
    ///      "examples": [
    ///        "USDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "operateTime": {
    ///      "examples": [
    ///        1615985535000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "serviceChargeAmount": {
    ///      "examples": [
    ///        "0.000009"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "transId": {
    ///      "examples": [
    ///        4359321
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "transferedAmount": {
    ///      "examples": [
    ///        "0.000441"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct AssetDribbletResponseUserAssetDribbletsItemUserAssetDribbletDetailsItem {
        pub amount: String,
        #[serde(rename = "fromAsset")]
        pub from_asset: String,
        #[serde(rename = "operateTime")]
        pub operate_time: i64,
        #[serde(rename = "serviceChargeAmount")]
        pub service_charge_amount: String,
        #[serde(rename = "transId")]
        pub trans_id: i64,
        #[serde(rename = "transferedAmount")]
        pub transfered_amount: String,
    }
    impl From<&AssetDribbletResponseUserAssetDribbletsItemUserAssetDribbletDetailsItem>
    for AssetDribbletResponseUserAssetDribbletsItemUserAssetDribbletDetailsItem {
        fn from(
            value: &AssetDribbletResponseUserAssetDribbletsItemUserAssetDribbletDetailsItem,
        ) -> Self {
            value.clone()
        }
    }
    ///AssetDustBtcResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "details",
    ///    "dribbletPercentage",
    ///    "totalTransferBNB",
    ///    "totalTransferBtc"
    ///  ],
    ///  "properties": {
    ///    "details": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "amountFree",
    ///          "asset",
    ///          "assetFullName",
    ///          "exchange",
    ///          "toBNB",
    ///          "toBNBOffExchange",
    ///          "toBTC"
    ///        ],
    ///        "properties": {
    ///          "amountFree": {
    ///            "description": "Convertible amount",
    ///            "examples": [
    ///              "6.21"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "asset": {
    ///            "examples": [
    ///              "ADA"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "assetFullName": {
    ///            "examples": [
    ///              "ADA"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "exchange": {
    ///            "description": "Commission fee",
    ///            "examples": [
    ///              "0.00035546"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "toBNB": {
    ///            "description": "BNB amount(Not deducted commission fee",
    ///            "examples": [
    ///              "0.01777302"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "toBNBOffExchange": {
    ///            "description": "BNB amount(Deducted commission fee",
    ///            "examples": [
    ///              "0.01741756"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "toBTC": {
    ///            "description": "BTC amount",
    ///            "examples": [
    ///              "0.00016848"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "dribbletPercentage": {
    ///      "description": "Commission fee",
    ///      "examples": [
    ///        "0.02"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalTransferBNB": {
    ///      "examples": [
    ///        "0.01777302"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalTransferBtc": {
    ///      "examples": [
    ///        "0.00016848"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct AssetDustBtcResponse {
        pub details: Vec<AssetDustBtcResponseDetailsItem>,
        ///Commission fee
        #[serde(rename = "dribbletPercentage")]
        pub dribblet_percentage: String,
        #[serde(rename = "totalTransferBNB")]
        pub total_transfer_bnb: String,
        #[serde(rename = "totalTransferBtc")]
        pub total_transfer_btc: String,
    }
    impl From<&AssetDustBtcResponse> for AssetDustBtcResponse {
        fn from(value: &AssetDustBtcResponse) -> Self {
            value.clone()
        }
    }
    ///AssetDustBtcResponseDetailsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "amountFree",
    ///    "asset",
    ///    "assetFullName",
    ///    "exchange",
    ///    "toBNB",
    ///    "toBNBOffExchange",
    ///    "toBTC"
    ///  ],
    ///  "properties": {
    ///    "amountFree": {
    ///      "description": "Convertible amount",
    ///      "examples": [
    ///        "6.21"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "asset": {
    ///      "examples": [
    ///        "ADA"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "assetFullName": {
    ///      "examples": [
    ///        "ADA"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "exchange": {
    ///      "description": "Commission fee",
    ///      "examples": [
    ///        "0.00035546"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "toBNB": {
    ///      "description": "BNB amount(Not deducted commission fee",
    ///      "examples": [
    ///        "0.01777302"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "toBNBOffExchange": {
    ///      "description": "BNB amount(Deducted commission fee",
    ///      "examples": [
    ///        "0.01741756"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "toBTC": {
    ///      "description": "BTC amount",
    ///      "examples": [
    ///        "0.00016848"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct AssetDustBtcResponseDetailsItem {
        ///Convertible amount
        #[serde(rename = "amountFree")]
        pub amount_free: String,
        pub asset: String,
        #[serde(rename = "assetFullName")]
        pub asset_full_name: String,
        ///Commission fee
        pub exchange: String,
        ///BNB amount(Not deducted commission fee
        #[serde(rename = "toBNB")]
        pub to_bnb: String,
        ///BNB amount(Deducted commission fee
        #[serde(rename = "toBNBOffExchange")]
        pub to_bnb_off_exchange: String,
        ///BTC amount
        #[serde(rename = "toBTC")]
        pub to_btc: String,
    }
    impl From<&AssetDustBtcResponseDetailsItem> for AssetDustBtcResponseDetailsItem {
        fn from(value: &AssetDustBtcResponseDetailsItem) -> Self {
            value.clone()
        }
    }
    ///AssetGetFundingAssetNeedBtcValuation
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "true",
    ///    "false"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum AssetGetFundingAssetNeedBtcValuation {
        #[serde(rename = "true")]
        True,
        #[serde(rename = "false")]
        False,
    }
    impl From<&AssetGetFundingAssetNeedBtcValuation>
    for AssetGetFundingAssetNeedBtcValuation {
        fn from(value: &AssetGetFundingAssetNeedBtcValuation) -> Self {
            value.clone()
        }
    }
    impl ToString for AssetGetFundingAssetNeedBtcValuation {
        fn to_string(&self) -> String {
            match *self {
                Self::True => "true".to_string(),
                Self::False => "false".to_string(),
            }
        }
    }
    impl std::str::FromStr for AssetGetFundingAssetNeedBtcValuation {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "true" => Ok(Self::True),
                "false" => Ok(Self::False),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for AssetGetFundingAssetNeedBtcValuation {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for AssetGetFundingAssetNeedBtcValuation {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for AssetGetFundingAssetNeedBtcValuation {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///AssetGetFundingAssetResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "asset",
    ///    "btcValuation",
    ///    "free",
    ///    "freeze",
    ///    "locked",
    ///    "withdrawing"
    ///  ],
    ///  "properties": {
    ///    "asset": {
    ///      "examples": [
    ///        "USDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "btcValuation": {
    ///      "examples": [
    ///        "0.00000091"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "free": {
    ///      "examples": [
    ///        "1"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "freeze": {
    ///      "examples": [
    ///        "0"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "locked": {
    ///      "examples": [
    ///        "0"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "withdrawing": {
    ///      "examples": [
    ///        "0"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct AssetGetFundingAssetResponseItem {
        pub asset: String,
        #[serde(rename = "btcValuation")]
        pub btc_valuation: String,
        pub free: String,
        pub freeze: String,
        pub locked: String,
        pub withdrawing: String,
    }
    impl From<&AssetGetFundingAssetResponseItem> for AssetGetFundingAssetResponseItem {
        fn from(value: &AssetGetFundingAssetResponseItem) -> Self {
            value.clone()
        }
    }
    ///AssetGetUserAssetNeedBtcValuation
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "true",
    ///    "false"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum AssetGetUserAssetNeedBtcValuation {
        #[serde(rename = "true")]
        True,
        #[serde(rename = "false")]
        False,
    }
    impl From<&AssetGetUserAssetNeedBtcValuation> for AssetGetUserAssetNeedBtcValuation {
        fn from(value: &AssetGetUserAssetNeedBtcValuation) -> Self {
            value.clone()
        }
    }
    impl ToString for AssetGetUserAssetNeedBtcValuation {
        fn to_string(&self) -> String {
            match *self {
                Self::True => "true".to_string(),
                Self::False => "false".to_string(),
            }
        }
    }
    impl std::str::FromStr for AssetGetUserAssetNeedBtcValuation {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "true" => Ok(Self::True),
                "false" => Ok(Self::False),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for AssetGetUserAssetNeedBtcValuation {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for AssetGetUserAssetNeedBtcValuation {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for AssetGetUserAssetNeedBtcValuation {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///AssetGetUserAssetResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "asset",
    ///    "btcValuation",
    ///    "free",
    ///    "freeze",
    ///    "ipoable",
    ///    "locked",
    ///    "withdrawing"
    ///  ],
    ///  "properties": {
    ///    "asset": {
    ///      "examples": [
    ///        "AVAX"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "btcValuation": {
    ///      "examples": [
    ///        "0"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "free": {
    ///      "examples": [
    ///        "1"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "freeze": {
    ///      "examples": [
    ///        "0"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "ipoable": {
    ///      "examples": [
    ///        "0"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "locked": {
    ///      "examples": [
    ///        "0"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "withdrawing": {
    ///      "examples": [
    ///        "0"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct AssetGetUserAssetResponseItem {
        pub asset: String,
        #[serde(rename = "btcValuation")]
        pub btc_valuation: String,
        pub free: String,
        pub freeze: String,
        pub ipoable: String,
        pub locked: String,
        pub withdrawing: String,
    }
    impl From<&AssetGetUserAssetResponseItem> for AssetGetUserAssetResponseItem {
        fn from(value: &AssetGetUserAssetResponseItem) -> Self {
            value.clone()
        }
    }
    ///AssetLedgerTransferCloudMiningQueryByPageResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "rows",
    ///    "total"
    ///  ],
    ///  "properties": {
    ///    "rows": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "amount",
    ///          "asset",
    ///          "createTime",
    ///          "status",
    ///          "tranId",
    ///          "type"
    ///        ],
    ///        "properties": {
    ///          "amount": {
    ///            "examples": [
    ///              "1"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "asset": {
    ///            "examples": [
    ///              "USDT"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "createTime": {
    ///            "examples": [
    ///              1667880112000
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "status": {
    ///            "examples": [
    ///              "S"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "tranId": {
    ///            "examples": [
    ///              121230610120
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "type": {
    ///            "examples": [
    ///              248
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "total": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct AssetLedgerTransferCloudMiningQueryByPageResponse {
        pub rows: Vec<AssetLedgerTransferCloudMiningQueryByPageResponseRowsItem>,
        pub total: i32,
    }
    impl From<&AssetLedgerTransferCloudMiningQueryByPageResponse>
    for AssetLedgerTransferCloudMiningQueryByPageResponse {
        fn from(value: &AssetLedgerTransferCloudMiningQueryByPageResponse) -> Self {
            value.clone()
        }
    }
    ///AssetLedgerTransferCloudMiningQueryByPageResponseRowsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "asset",
    ///    "createTime",
    ///    "status",
    ///    "tranId",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "examples": [
    ///        "1"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "asset": {
    ///      "examples": [
    ///        "USDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "createTime": {
    ///      "examples": [
    ///        1667880112000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "status": {
    ///      "examples": [
    ///        "S"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "tranId": {
    ///      "examples": [
    ///        121230610120
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "type": {
    ///      "examples": [
    ///        248
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct AssetLedgerTransferCloudMiningQueryByPageResponseRowsItem {
        pub amount: String,
        pub asset: String,
        #[serde(rename = "createTime")]
        pub create_time: i64,
        pub status: String,
        #[serde(rename = "tranId")]
        pub tran_id: i64,
        #[serde(rename = "type")]
        pub type_: i64,
    }
    impl From<&AssetLedgerTransferCloudMiningQueryByPageResponseRowsItem>
    for AssetLedgerTransferCloudMiningQueryByPageResponseRowsItem {
        fn from(
            value: &AssetLedgerTransferCloudMiningQueryByPageResponseRowsItem,
        ) -> Self {
            value.clone()
        }
    }
    ///AssetTradeFeeResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "makerCommission",
    ///    "symbol",
    ///    "takerCommission"
    ///  ],
    ///  "properties": {
    ///    "makerCommission": {
    ///      "examples": [
    ///        "0.001"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "symbol": {
    ///      "examples": [
    ///        "ADABNB"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "takerCommission": {
    ///      "examples": [
    ///        "0.001"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct AssetTradeFeeResponseItem {
        #[serde(rename = "makerCommission")]
        pub maker_commission: String,
        pub symbol: String,
        #[serde(rename = "takerCommission")]
        pub taker_commission: String,
    }
    impl From<&AssetTradeFeeResponseItem> for AssetTradeFeeResponseItem {
        fn from(value: &AssetTradeFeeResponseItem) -> Self {
            value.clone()
        }
    }
    ///AssetTransferResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "rows",
    ///    "total"
    ///  ],
    ///  "properties": {
    ///    "rows": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "amount",
    ///          "asset",
    ///          "status",
    ///          "timestamp",
    ///          "tranId",
    ///          "type"
    ///        ],
    ///        "properties": {
    ///          "amount": {
    ///            "examples": [
    ///              "1"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "asset": {
    ///            "examples": [
    ///              "USDT"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "status": {
    ///            "examples": [
    ///              "CONFIRMED"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "timestamp": {
    ///            "examples": [
    ///              1544433328000
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "tranId": {
    ///            "examples": [
    ///              11415955596
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "type": {
    ///            "examples": [
    ///              "MAIN_UMFUTUR"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "total": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct AssetTransferResponse {
        pub rows: Vec<AssetTransferResponseRowsItem>,
        pub total: i32,
    }
    impl From<&AssetTransferResponse> for AssetTransferResponse {
        fn from(value: &AssetTransferResponse) -> Self {
            value.clone()
        }
    }
    ///AssetTransferResponseRowsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "asset",
    ///    "status",
    ///    "timestamp",
    ///    "tranId",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "examples": [
    ///        "1"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "asset": {
    ///      "examples": [
    ///        "USDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "examples": [
    ///        "CONFIRMED"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "timestamp": {
    ///      "examples": [
    ///        1544433328000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "tranId": {
    ///      "examples": [
    ///        11415955596
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "type": {
    ///      "examples": [
    ///        "MAIN_UMFUTUR"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct AssetTransferResponseRowsItem {
        pub amount: String,
        pub asset: String,
        pub status: String,
        pub timestamp: i64,
        #[serde(rename = "tranId")]
        pub tran_id: i64,
        #[serde(rename = "type")]
        pub type_: String,
    }
    impl From<&AssetTransferResponseRowsItem> for AssetTransferResponseRowsItem {
        fn from(value: &AssetTransferResponseRowsItem) -> Self {
            value.clone()
        }
    }
    ///AssetTransferType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "MAIN_C2C"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "MAIN_C2C",
    ///    "MAIN_UMFUTURE",
    ///    "MAIN_CMFUTURE",
    ///    "MAIN_MARGIN",
    ///    "MAIN_MINING",
    ///    "C2C_MAIN",
    ///    "C2C_UMFUTURE",
    ///    "C2C_MINING",
    ///    "C2C_MARGIN",
    ///    "UMFUTURE_MAIN",
    ///    "UMFUTURE_C2C",
    ///    "UMFUTURE_MARGIN",
    ///    "CMFUTURE_MAIN",
    ///    "CMFUTURE_MARGIN",
    ///    "MARGIN_MAIN",
    ///    "MARGIN_UMFUTURE",
    ///    "MARGIN_CMFUTURE",
    ///    "MARGIN_MINING",
    ///    "MARGIN_C2C",
    ///    "MINING_MAIN",
    ///    "MINING_UMFUTURE",
    ///    "MINING_C2C",
    ///    "MINING_MARGIN",
    ///    "MAIN_PAY",
    ///    "PAY_MAIN",
    ///    "ISOLATEDMARGIN_MARGIN",
    ///    "MARGIN_ISOLATEDMARGIN",
    ///    "ISOLATEDMARGIN_ISOLATEDMARGIN"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum AssetTransferType {
        #[serde(rename = "MAIN_C2C")]
        MainC2c,
        #[serde(rename = "MAIN_UMFUTURE")]
        MainUmfuture,
        #[serde(rename = "MAIN_CMFUTURE")]
        MainCmfuture,
        #[serde(rename = "MAIN_MARGIN")]
        MainMargin,
        #[serde(rename = "MAIN_MINING")]
        MainMining,
        #[serde(rename = "C2C_MAIN")]
        C2cMain,
        #[serde(rename = "C2C_UMFUTURE")]
        C2cUmfuture,
        #[serde(rename = "C2C_MINING")]
        C2cMining,
        #[serde(rename = "C2C_MARGIN")]
        C2cMargin,
        #[serde(rename = "UMFUTURE_MAIN")]
        UmfutureMain,
        #[serde(rename = "UMFUTURE_C2C")]
        UmfutureC2c,
        #[serde(rename = "UMFUTURE_MARGIN")]
        UmfutureMargin,
        #[serde(rename = "CMFUTURE_MAIN")]
        CmfutureMain,
        #[serde(rename = "CMFUTURE_MARGIN")]
        CmfutureMargin,
        #[serde(rename = "MARGIN_MAIN")]
        MarginMain,
        #[serde(rename = "MARGIN_UMFUTURE")]
        MarginUmfuture,
        #[serde(rename = "MARGIN_CMFUTURE")]
        MarginCmfuture,
        #[serde(rename = "MARGIN_MINING")]
        MarginMining,
        #[serde(rename = "MARGIN_C2C")]
        MarginC2c,
        #[serde(rename = "MINING_MAIN")]
        MiningMain,
        #[serde(rename = "MINING_UMFUTURE")]
        MiningUmfuture,
        #[serde(rename = "MINING_C2C")]
        MiningC2c,
        #[serde(rename = "MINING_MARGIN")]
        MiningMargin,
        #[serde(rename = "MAIN_PAY")]
        MainPay,
        #[serde(rename = "PAY_MAIN")]
        PayMain,
        #[serde(rename = "ISOLATEDMARGIN_MARGIN")]
        IsolatedmarginMargin,
        #[serde(rename = "MARGIN_ISOLATEDMARGIN")]
        MarginIsolatedmargin,
        #[serde(rename = "ISOLATEDMARGIN_ISOLATEDMARGIN")]
        IsolatedmarginIsolatedmargin,
    }
    impl From<&AssetTransferType> for AssetTransferType {
        fn from(value: &AssetTransferType) -> Self {
            value.clone()
        }
    }
    impl ToString for AssetTransferType {
        fn to_string(&self) -> String {
            match *self {
                Self::MainC2c => "MAIN_C2C".to_string(),
                Self::MainUmfuture => "MAIN_UMFUTURE".to_string(),
                Self::MainCmfuture => "MAIN_CMFUTURE".to_string(),
                Self::MainMargin => "MAIN_MARGIN".to_string(),
                Self::MainMining => "MAIN_MINING".to_string(),
                Self::C2cMain => "C2C_MAIN".to_string(),
                Self::C2cUmfuture => "C2C_UMFUTURE".to_string(),
                Self::C2cMining => "C2C_MINING".to_string(),
                Self::C2cMargin => "C2C_MARGIN".to_string(),
                Self::UmfutureMain => "UMFUTURE_MAIN".to_string(),
                Self::UmfutureC2c => "UMFUTURE_C2C".to_string(),
                Self::UmfutureMargin => "UMFUTURE_MARGIN".to_string(),
                Self::CmfutureMain => "CMFUTURE_MAIN".to_string(),
                Self::CmfutureMargin => "CMFUTURE_MARGIN".to_string(),
                Self::MarginMain => "MARGIN_MAIN".to_string(),
                Self::MarginUmfuture => "MARGIN_UMFUTURE".to_string(),
                Self::MarginCmfuture => "MARGIN_CMFUTURE".to_string(),
                Self::MarginMining => "MARGIN_MINING".to_string(),
                Self::MarginC2c => "MARGIN_C2C".to_string(),
                Self::MiningMain => "MINING_MAIN".to_string(),
                Self::MiningUmfuture => "MINING_UMFUTURE".to_string(),
                Self::MiningC2c => "MINING_C2C".to_string(),
                Self::MiningMargin => "MINING_MARGIN".to_string(),
                Self::MainPay => "MAIN_PAY".to_string(),
                Self::PayMain => "PAY_MAIN".to_string(),
                Self::IsolatedmarginMargin => "ISOLATEDMARGIN_MARGIN".to_string(),
                Self::MarginIsolatedmargin => "MARGIN_ISOLATEDMARGIN".to_string(),
                Self::IsolatedmarginIsolatedmargin => {
                    "ISOLATEDMARGIN_ISOLATEDMARGIN".to_string()
                }
            }
        }
    }
    impl std::str::FromStr for AssetTransferType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "MAIN_C2C" => Ok(Self::MainC2c),
                "MAIN_UMFUTURE" => Ok(Self::MainUmfuture),
                "MAIN_CMFUTURE" => Ok(Self::MainCmfuture),
                "MAIN_MARGIN" => Ok(Self::MainMargin),
                "MAIN_MINING" => Ok(Self::MainMining),
                "C2C_MAIN" => Ok(Self::C2cMain),
                "C2C_UMFUTURE" => Ok(Self::C2cUmfuture),
                "C2C_MINING" => Ok(Self::C2cMining),
                "C2C_MARGIN" => Ok(Self::C2cMargin),
                "UMFUTURE_MAIN" => Ok(Self::UmfutureMain),
                "UMFUTURE_C2C" => Ok(Self::UmfutureC2c),
                "UMFUTURE_MARGIN" => Ok(Self::UmfutureMargin),
                "CMFUTURE_MAIN" => Ok(Self::CmfutureMain),
                "CMFUTURE_MARGIN" => Ok(Self::CmfutureMargin),
                "MARGIN_MAIN" => Ok(Self::MarginMain),
                "MARGIN_UMFUTURE" => Ok(Self::MarginUmfuture),
                "MARGIN_CMFUTURE" => Ok(Self::MarginCmfuture),
                "MARGIN_MINING" => Ok(Self::MarginMining),
                "MARGIN_C2C" => Ok(Self::MarginC2c),
                "MINING_MAIN" => Ok(Self::MiningMain),
                "MINING_UMFUTURE" => Ok(Self::MiningUmfuture),
                "MINING_C2C" => Ok(Self::MiningC2c),
                "MINING_MARGIN" => Ok(Self::MiningMargin),
                "MAIN_PAY" => Ok(Self::MainPay),
                "PAY_MAIN" => Ok(Self::PayMain),
                "ISOLATEDMARGIN_MARGIN" => Ok(Self::IsolatedmarginMargin),
                "MARGIN_ISOLATEDMARGIN" => Ok(Self::MarginIsolatedmargin),
                "ISOLATEDMARGIN_ISOLATEDMARGIN" => Ok(Self::IsolatedmarginIsolatedmargin),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for AssetTransferType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for AssetTransferType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for AssetTransferType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///AssetWalletBalanceResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "activate",
    ///    "balance",
    ///    "walletName"
    ///  ],
    ///  "properties": {
    ///    "activate": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "balance": {
    ///      "examples": [
    ///        "0"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "walletName": {
    ///      "examples": [
    ///        "Spot"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct AssetWalletBalanceResponseItem {
        pub activate: bool,
        pub balance: String,
        #[serde(rename = "walletName")]
        pub wallet_name: String,
    }
    impl From<&AssetWalletBalanceResponseItem> for AssetWalletBalanceResponseItem {
        fn from(value: &AssetWalletBalanceResponseItem) -> Self {
            value.clone()
        }
    }
    ///AvgPriceResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "mins",
    ///    "price"
    ///  ],
    ///  "properties": {
    ///    "mins": {
    ///      "examples": [
    ///        5
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "price": {
    ///      "examples": [
    ///        "9.35751834"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct AvgPriceResponse {
        pub mins: i64,
        pub price: String,
    }
    impl From<&AvgPriceResponse> for AvgPriceResponse {
        fn from(value: &AvgPriceResponse) -> Self {
            value.clone()
        }
    }
    ///BlvtRedeemRecordResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "fee",
    ///    "id",
    ///    "nav",
    ///    "netProceed",
    ///    "timestamp",
    ///    "tokenName"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "description": "Redemption amount",
    ///      "examples": [
    ///        "0.54216292"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "fee": {
    ///      "description": "Reemption fee",
    ///      "examples": [
    ///        "0.00995598"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "nav": {
    ///      "description": "NAV of redemption",
    ///      "examples": [
    ///        "18.36345064"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "netProceed": {
    ///      "description": "Net redemption value in usdt",
    ///      "examples": [
    ///        "9.94602604"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "timestamp": {
    ///      "examples": [
    ///        1599128003050
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "tokenName": {
    ///      "examples": [
    ///        "LINKUP"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct BlvtRedeemRecordResponseItem {
        ///Redemption amount
        pub amount: String,
        ///Reemption fee
        pub fee: String,
        pub id: i64,
        ///NAV of redemption
        pub nav: String,
        ///Net redemption value in usdt
        #[serde(rename = "netProceed")]
        pub net_proceed: String,
        pub timestamp: i64,
        #[serde(rename = "tokenName")]
        pub token_name: String,
    }
    impl From<&BlvtRedeemRecordResponseItem> for BlvtRedeemRecordResponseItem {
        fn from(value: &BlvtRedeemRecordResponseItem) -> Self {
            value.clone()
        }
    }
    ///BlvtRedeemResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "id",
    ///    "redeemAmount",
    ///    "status",
    ///    "timestamp",
    ///    "tokenName"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "description": "Redemption value in usdt",
    ///      "examples": [
    ///        "10.05022099"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "examples": [
    ///        123
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "redeemAmount": {
    ///      "description": "Redemption token amount",
    ///      "examples": [
    ///        "0.95590905"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "description": "S, P, and F for \"success\", \"pending\", and \"failure\"",
    ///      "examples": [
    ///        "S"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "timestamp": {
    ///      "examples": [
    ///        1600250279614
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "tokenName": {
    ///      "examples": [
    ///        "LINKUP"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct BlvtRedeemResponse {
        ///Redemption value in usdt
        pub amount: String,
        pub id: i64,
        ///Redemption token amount
        #[serde(rename = "redeemAmount")]
        pub redeem_amount: String,
        ///S, P, and F for "success", "pending", and "failure"
        pub status: String,
        pub timestamp: i64,
        #[serde(rename = "tokenName")]
        pub token_name: String,
    }
    impl From<&BlvtRedeemResponse> for BlvtRedeemResponse {
        fn from(value: &BlvtRedeemResponse) -> Self {
            value.clone()
        }
    }
    ///BlvtSubscribeRecordResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "fee",
    ///    "id",
    ///    "nav",
    ///    "timestamp",
    ///    "tokenName",
    ///    "totalCharge"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "description": "Subscription amount",
    ///      "examples": [
    ///        "0.54216292"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "fee": {
    ///      "description": "Subscription fee in usdt",
    ///      "examples": [
    ///        "0.00999000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "nav": {
    ///      "description": "NAV price of subscription",
    ///      "examples": [
    ///        "18.42621386"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "timestamp": {
    ///      "examples": [
    ///        1599127217916
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "tokenName": {
    ///      "examples": [
    ///        "LINKUP"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalCharge": {
    ///      "description": "Subscription cost in usdt",
    ///      "examples": [
    ///        "9.99999991"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct BlvtSubscribeRecordResponse {
        ///Subscription amount
        pub amount: String,
        ///Subscription fee in usdt
        pub fee: String,
        pub id: i64,
        ///NAV price of subscription
        pub nav: String,
        pub timestamp: i64,
        #[serde(rename = "tokenName")]
        pub token_name: String,
        ///Subscription cost in usdt
        #[serde(rename = "totalCharge")]
        pub total_charge: String,
    }
    impl From<&BlvtSubscribeRecordResponse> for BlvtSubscribeRecordResponse {
        fn from(value: &BlvtSubscribeRecordResponse) -> Self {
            value.clone()
        }
    }
    ///BlvtSubscribeResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "cost",
    ///    "id",
    ///    "status",
    ///    "timestamp",
    ///    "tokenName"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "description": "subscribed token amount",
    ///      "examples": [
    ///        "0.9559090500"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "cost": {
    ///      "description": "subscription cost in usdt",
    ///      "examples": [
    ///        "9.99999995"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "examples": [
    ///        123
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "status": {
    ///      "description": "S, P, and F for \"success\", \"pending\", and \"failure\"",
    ///      "examples": [
    ///        "S"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "timestamp": {
    ///      "examples": [
    ///        1600249972899
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "tokenName": {
    ///      "examples": [
    ///        "LINKUP"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct BlvtSubscribeResponse {
        ///subscribed token amount
        pub amount: String,
        ///subscription cost in usdt
        pub cost: String,
        pub id: i64,
        ///S, P, and F for "success", "pending", and "failure"
        pub status: String,
        pub timestamp: i64,
        #[serde(rename = "tokenName")]
        pub token_name: String,
    }
    impl From<&BlvtSubscribeResponse> for BlvtSubscribeResponse {
        fn from(value: &BlvtSubscribeResponse) -> Self {
            value.clone()
        }
    }
    ///BlvtTokenInfoResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "basket",
    ///    "currentBaskets",
    ///    "dailyManagementFee",
    ///    "dailyPurchaseLimit",
    ///    "dailyRedeemLimit",
    ///    "description",
    ///    "fundingRate",
    ///    "nav",
    ///    "purchaseFeePct",
    ///    "realLeverage",
    ///    "redeemFeePct",
    ///    "timestamp",
    ///    "tokenIssued",
    ///    "tokenName",
    ///    "underlying"
    ///  ],
    ///  "properties": {
    ///    "basket": {
    ///      "examples": [
    ///        "-821.474 BTCUSDT Futures"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "currentBaskets": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "amount",
    ///          "notionalValue",
    ///          "symbol"
    ///        ],
    ///        "properties": {
    ///          "amount": {
    ///            "examples": [
    ///              "-1183.984"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "notionalValue": {
    ///            "examples": [
    ///              "-22871089.96704"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "symbol": {
    ///            "examples": [
    ///              "BTCUSDT"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "dailyManagementFee": {
    ///      "examples": [
    ///        "0.0001"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "dailyPurchaseLimit": {
    ///      "examples": [
    ///        "100000.00"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "dailyRedeemLimit": {
    ///      "examples": [
    ///        "1000000.00"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "description": {
    ///      "examples": [
    ///        "3X Short Bitcoin Token"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "fundingRate": {
    ///      "examples": [
    ///        "0.001020"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "nav": {
    ///      "examples": [
    ///        "4.79"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "purchaseFeePct": {
    ///      "examples": [
    ///        "0.0010"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "realLeverage": {
    ///      "examples": [
    ///        "-2.316"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "redeemFeePct": {
    ///      "examples": [
    ///        "0.0010"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "timestamp": {
    ///      "examples": [
    ///        1583127900000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "tokenIssued": {
    ///      "examples": [
    ///        "717953.95"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "tokenName": {
    ///      "examples": [
    ///        "BTCDOWN"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "underlying": {
    ///      "examples": [
    ///        "BTC"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct BlvtTokenInfoResponseItem {
        pub basket: String,
        #[serde(rename = "currentBaskets")]
        pub current_baskets: Vec<BlvtTokenInfoResponseItemCurrentBasketsItem>,
        #[serde(rename = "dailyManagementFee")]
        pub daily_management_fee: String,
        #[serde(rename = "dailyPurchaseLimit")]
        pub daily_purchase_limit: String,
        #[serde(rename = "dailyRedeemLimit")]
        pub daily_redeem_limit: String,
        pub description: String,
        #[serde(rename = "fundingRate")]
        pub funding_rate: String,
        pub nav: String,
        #[serde(rename = "purchaseFeePct")]
        pub purchase_fee_pct: String,
        #[serde(rename = "realLeverage")]
        pub real_leverage: String,
        #[serde(rename = "redeemFeePct")]
        pub redeem_fee_pct: String,
        pub timestamp: i64,
        #[serde(rename = "tokenIssued")]
        pub token_issued: String,
        #[serde(rename = "tokenName")]
        pub token_name: String,
        pub underlying: String,
    }
    impl From<&BlvtTokenInfoResponseItem> for BlvtTokenInfoResponseItem {
        fn from(value: &BlvtTokenInfoResponseItem) -> Self {
            value.clone()
        }
    }
    ///BlvtTokenInfoResponseItemCurrentBasketsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "notionalValue",
    ///    "symbol"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "examples": [
    ///        "-1183.984"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "notionalValue": {
    ///      "examples": [
    ///        "-22871089.96704"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "symbol": {
    ///      "examples": [
    ///        "BTCUSDT"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct BlvtTokenInfoResponseItemCurrentBasketsItem {
        pub amount: String,
        #[serde(rename = "notionalValue")]
        pub notional_value: String,
        pub symbol: String,
    }
    impl From<&BlvtTokenInfoResponseItemCurrentBasketsItem>
    for BlvtTokenInfoResponseItemCurrentBasketsItem {
        fn from(value: &BlvtTokenInfoResponseItemCurrentBasketsItem) -> Self {
            value.clone()
        }
    }
    ///BlvtUserLimitResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "tokenName",
    ///    "userDailyTotalPurchaseLimit",
    ///    "userDailyTotalRedeemLimit"
    ///  ],
    ///  "properties": {
    ///    "tokenName": {
    ///      "examples": [
    ///        "LINKUP"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "userDailyTotalPurchaseLimit": {
    ///      "description": "USDT",
    ///      "examples": [
    ///        "1000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "userDailyTotalRedeemLimit": {
    ///      "description": "USDT",
    ///      "examples": [
    ///        "1000"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct BlvtUserLimitResponseItem {
        #[serde(rename = "tokenName")]
        pub token_name: String,
        ///USDT
        #[serde(rename = "userDailyTotalPurchaseLimit")]
        pub user_daily_total_purchase_limit: String,
        ///USDT
        #[serde(rename = "userDailyTotalRedeemLimit")]
        pub user_daily_total_redeem_limit: String,
    }
    impl From<&BlvtUserLimitResponseItem> for BlvtUserLimitResponseItem {
        fn from(value: &BlvtUserLimitResponseItem) -> Self {
            value.clone()
        }
    }
    ///BnbBurnStatus
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "interestBNBBurn",
    ///    "spotBNBBurn"
    ///  ],
    ///  "properties": {
    ///    "interestBNBBurn": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "spotBNBBurn": {
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct BnbBurnStatus {
        #[serde(rename = "interestBNBBurn")]
        pub interest_bnb_burn: bool,
        #[serde(rename = "spotBNBBurn")]
        pub spot_bnb_burn: bool,
    }
    impl From<&BnbBurnStatus> for BnbBurnStatus {
        fn from(value: &BnbBurnStatus) -> Self {
            value.clone()
        }
    }
    ///BookTicker
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "askPrice",
    ///    "askQty",
    ///    "bidPrice",
    ///    "bidQty",
    ///    "symbol"
    ///  ],
    ///  "properties": {
    ///    "askPrice": {
    ///      "examples": [
    ///        "16.36450000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "askQty": {
    ///      "examples": [
    ///        "12.56000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "bidPrice": {
    ///      "examples": [
    ///        "16.36240000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "bidQty": {
    ///      "examples": [
    ///        "256.78000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "symbol": {
    ///      "examples": [
    ///        "BNBBTC"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct BookTicker {
        #[serde(rename = "askPrice")]
        pub ask_price: String,
        #[serde(rename = "askQty")]
        pub ask_qty: String,
        #[serde(rename = "bidPrice")]
        pub bid_price: String,
        #[serde(rename = "bidQty")]
        pub bid_qty: String,
        pub symbol: String,
    }
    impl From<&BookTicker> for BookTicker {
        fn from(value: &BookTicker) -> Self {
            value.clone()
        }
    }
    ///BookTickerList
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "array",
    ///  "items": {
    ///    "$ref": "#/components/schemas/bookTicker"
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct BookTickerList(pub Vec<BookTicker>);
    impl std::ops::Deref for BookTickerList {
        type Target = Vec<BookTicker>;
        fn deref(&self) -> &Vec<BookTicker> {
            &self.0
        }
    }
    impl From<BookTickerList> for Vec<BookTicker> {
        fn from(value: BookTickerList) -> Self {
            value.0
        }
    }
    impl From<&BookTickerList> for BookTickerList {
        fn from(value: &BookTickerList) -> Self {
            value.clone()
        }
    }
    impl From<Vec<BookTicker>> for BookTickerList {
        fn from(value: Vec<BookTicker>) -> Self {
            Self(value)
        }
    }
    ///BswapAddLiquidityPreviewCombination
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "baseAmt",
    ///    "baseAsset",
    ///    "price",
    ///    "quoteAmt",
    ///    "quoteAsset",
    ///    "share"
    ///  ],
    ///  "properties": {
    ///    "baseAmt": {
    ///      "examples": [
    ///        299975
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "baseAsset": {
    ///      "examples": [
    ///        "BUSD"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "price": {
    ///      "examples": [
    ///        1.00008334
    ///      ],
    ///      "type": "number",
    ///      "format": "double"
    ///    },
    ///    "quoteAmt": {
    ///      "examples": [
    ///        300000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "quoteAsset": {
    ///      "examples": [
    ///        "USDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "share": {
    ///      "examples": [
    ///        1.23
    ///      ],
    ///      "type": "number",
    ///      "format": "double"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct BswapAddLiquidityPreviewCombination {
        #[serde(rename = "baseAmt")]
        pub base_amt: i64,
        #[serde(rename = "baseAsset")]
        pub base_asset: String,
        pub price: f64,
        #[serde(rename = "quoteAmt")]
        pub quote_amt: i64,
        #[serde(rename = "quoteAsset")]
        pub quote_asset: String,
        pub share: f64,
    }
    impl From<&BswapAddLiquidityPreviewCombination>
    for BswapAddLiquidityPreviewCombination {
        fn from(value: &BswapAddLiquidityPreviewCombination) -> Self {
            value.clone()
        }
    }
    ///BswapAddLiquidityPreviewResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/bswapAddLiquidityPreviewCombination"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/bswapAddLiquidityPreviewSingle"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    #[serde(untagged)]
    pub enum BswapAddLiquidityPreviewResponse {
        Combination(BswapAddLiquidityPreviewCombination),
        Single(BswapAddLiquidityPreviewSingle),
    }
    impl From<&BswapAddLiquidityPreviewResponse> for BswapAddLiquidityPreviewResponse {
        fn from(value: &BswapAddLiquidityPreviewResponse) -> Self {
            value.clone()
        }
    }
    impl From<BswapAddLiquidityPreviewCombination> for BswapAddLiquidityPreviewResponse {
        fn from(value: BswapAddLiquidityPreviewCombination) -> Self {
            Self::Combination(value)
        }
    }
    impl From<BswapAddLiquidityPreviewSingle> for BswapAddLiquidityPreviewResponse {
        fn from(value: BswapAddLiquidityPreviewSingle) -> Self {
            Self::Single(value)
        }
    }
    ///BswapAddLiquidityPreviewSingle
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "fee",
    ///    "price",
    ///    "quoteAmt",
    ///    "quoteAsset",
    ///    "share",
    ///    "slippage"
    ///  ],
    ///  "properties": {
    ///    "fee": {
    ///      "examples": [
    ///        120
    ///      ],
    ///      "type": "number",
    ///      "format": "double"
    ///    },
    ///    "price": {
    ///      "examples": [
    ///        1.00008334
    ///      ],
    ///      "type": "number",
    ///      "format": "double"
    ///    },
    ///    "quoteAmt": {
    ///      "examples": [
    ///        300000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "quoteAsset": {
    ///      "examples": [
    ///        "USDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "share": {
    ///      "examples": [
    ///        1.23
    ///      ],
    ///      "type": "number",
    ///      "format": "double"
    ///    },
    ///    "slippage": {
    ///      "examples": [
    ///        0.00007245
    ///      ],
    ///      "type": "number",
    ///      "format": "double"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct BswapAddLiquidityPreviewSingle {
        pub fee: f64,
        pub price: f64,
        #[serde(rename = "quoteAmt")]
        pub quote_amt: i64,
        #[serde(rename = "quoteAsset")]
        pub quote_asset: String,
        pub share: f64,
        pub slippage: f64,
    }
    impl From<&BswapAddLiquidityPreviewSingle> for BswapAddLiquidityPreviewSingle {
        fn from(value: &BswapAddLiquidityPreviewSingle) -> Self {
            value.clone()
        }
    }
    ///BswapAddLiquidityPreviewType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "SINGLE"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "SINGLE",
    ///    "COMBINATION"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum BswapAddLiquidityPreviewType {
        #[serde(rename = "SINGLE")]
        Single,
        #[serde(rename = "COMBINATION")]
        Combination,
    }
    impl From<&BswapAddLiquidityPreviewType> for BswapAddLiquidityPreviewType {
        fn from(value: &BswapAddLiquidityPreviewType) -> Self {
            value.clone()
        }
    }
    impl ToString for BswapAddLiquidityPreviewType {
        fn to_string(&self) -> String {
            match *self {
                Self::Single => "SINGLE".to_string(),
                Self::Combination => "COMBINATION".to_string(),
            }
        }
    }
    impl std::str::FromStr for BswapAddLiquidityPreviewType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "SINGLE" => Ok(Self::Single),
                "COMBINATION" => Ok(Self::Combination),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for BswapAddLiquidityPreviewType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for BswapAddLiquidityPreviewType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for BswapAddLiquidityPreviewType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///BswapClaimRewardsResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "success"
    ///  ],
    ///  "properties": {
    ///    "success": {
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct BswapClaimRewardsResponse {
        pub success: bool,
    }
    impl From<&BswapClaimRewardsResponse> for BswapClaimRewardsResponse {
        fn from(value: &BswapClaimRewardsResponse) -> Self {
            value.clone()
        }
    }
    ///BswapClaimedHistoryResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "assetRewards",
    ///    "claimAmount",
    ///    "claimTime",
    ///    "poolId",
    ///    "poolName",
    ///    "status"
    ///  ],
    ///  "properties": {
    ///    "assetRewards": {
    ///      "examples": [
    ///        "BNB"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "claimAmount": {
    ///      "examples": [
    ///        2.3e-7
    ///      ],
    ///      "type": "number",
    ///      "format": "float"
    ///    },
    ///    "claimTime": {
    ///      "examples": [
    ///        1565769342148
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "poolId": {
    ///      "examples": [
    ///        52
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    },
    ///    "poolName": {
    ///      "examples": [
    ///        "BNB/USDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "description": "0: pending, 1: success",
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct BswapClaimedHistoryResponseItem {
        #[serde(rename = "assetRewards")]
        pub asset_rewards: String,
        #[serde(rename = "claimAmount")]
        pub claim_amount: f32,
        #[serde(rename = "claimTime")]
        pub claim_time: i64,
        #[serde(rename = "poolId")]
        pub pool_id: i32,
        #[serde(rename = "poolName")]
        pub pool_name: String,
        ///0: pending, 1: success
        pub status: i32,
    }
    impl From<&BswapClaimedHistoryResponseItem> for BswapClaimedHistoryResponseItem {
        fn from(value: &BswapClaimedHistoryResponseItem) -> Self {
            value.clone()
        }
    }
    ///BswapLiquidityAddResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "operationId"
    ///  ],
    ///  "properties": {
    ///    "operationId": {
    ///      "examples": [
    ///        12341
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct BswapLiquidityAddResponse {
        #[serde(rename = "operationId")]
        pub operation_id: i64,
    }
    impl From<&BswapLiquidityAddResponse> for BswapLiquidityAddResponse {
        fn from(value: &BswapLiquidityAddResponse) -> Self {
            value.clone()
        }
    }
    ///BswapLiquidityAddType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "Single"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "Single",
    ///    "Combination"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum BswapLiquidityAddType {
        Single,
        Combination,
    }
    impl From<&BswapLiquidityAddType> for BswapLiquidityAddType {
        fn from(value: &BswapLiquidityAddType) -> Self {
            value.clone()
        }
    }
    impl ToString for BswapLiquidityAddType {
        fn to_string(&self) -> String {
            match *self {
                Self::Single => "Single".to_string(),
                Self::Combination => "Combination".to_string(),
            }
        }
    }
    impl std::str::FromStr for BswapLiquidityAddType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "Single" => Ok(Self::Single),
                "Combination" => Ok(Self::Combination),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for BswapLiquidityAddType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for BswapLiquidityAddType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for BswapLiquidityAddType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///BswapLiquidityOpsOperation
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "ADD",
    ///    "REMOVE"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum BswapLiquidityOpsOperation {
        #[serde(rename = "ADD")]
        Add,
        #[serde(rename = "REMOVE")]
        Remove,
    }
    impl From<&BswapLiquidityOpsOperation> for BswapLiquidityOpsOperation {
        fn from(value: &BswapLiquidityOpsOperation) -> Self {
            value.clone()
        }
    }
    impl ToString for BswapLiquidityOpsOperation {
        fn to_string(&self) -> String {
            match *self {
                Self::Add => "ADD".to_string(),
                Self::Remove => "REMOVE".to_string(),
            }
        }
    }
    impl std::str::FromStr for BswapLiquidityOpsOperation {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "ADD" => Ok(Self::Add),
                "REMOVE" => Ok(Self::Remove),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for BswapLiquidityOpsOperation {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for BswapLiquidityOpsOperation {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for BswapLiquidityOpsOperation {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///BswapLiquidityOpsResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "operation",
    ///    "operationId",
    ///    "poolId",
    ///    "poolName",
    ///    "shareAmount",
    ///    "status",
    ///    "updateTime"
    ///  ],
    ///  "properties": {
    ///    "operation": {
    ///      "description": "\"ADD\" or \"REMOVE\"",
    ///      "examples": [
    ///        "ADD"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "operationId": {
    ///      "examples": [
    ///        12341
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "poolId": {
    ///      "examples": [
    ///        2
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "poolName": {
    ///      "examples": [
    ///        "BUSD/USDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "shareAmount": {
    ///      "examples": [
    ///        "10.1"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "description": "0: pending, 1: success, 2: failed",
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    },
    ///    "updateTime": {
    ///      "examples": [
    ///        1565769342148
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct BswapLiquidityOpsResponseItem {
        ///"ADD" or "REMOVE"
        pub operation: String,
        #[serde(rename = "operationId")]
        pub operation_id: i64,
        #[serde(rename = "poolId")]
        pub pool_id: i64,
        #[serde(rename = "poolName")]
        pub pool_name: String,
        #[serde(rename = "shareAmount")]
        pub share_amount: String,
        ///0: pending, 1: success, 2: failed
        pub status: i32,
        #[serde(rename = "updateTime")]
        pub update_time: i64,
    }
    impl From<&BswapLiquidityOpsResponseItem> for BswapLiquidityOpsResponseItem {
        fn from(value: &BswapLiquidityOpsResponseItem) -> Self {
            value.clone()
        }
    }
    ///BswapLiquidityRemoveResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "operationId"
    ///  ],
    ///  "properties": {
    ///    "operationId": {
    ///      "examples": [
    ///        12341
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct BswapLiquidityRemoveResponse {
        #[serde(rename = "operationId")]
        pub operation_id: i64,
    }
    impl From<&BswapLiquidityRemoveResponse> for BswapLiquidityRemoveResponse {
        fn from(value: &BswapLiquidityRemoveResponse) -> Self {
            value.clone()
        }
    }
    ///BswapLiquidityRemoveType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "SINGLE"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "SINGLE",
    ///    "COMBINATION"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum BswapLiquidityRemoveType {
        #[serde(rename = "SINGLE")]
        Single,
        #[serde(rename = "COMBINATION")]
        Combination,
    }
    impl From<&BswapLiquidityRemoveType> for BswapLiquidityRemoveType {
        fn from(value: &BswapLiquidityRemoveType) -> Self {
            value.clone()
        }
    }
    impl ToString for BswapLiquidityRemoveType {
        fn to_string(&self) -> String {
            match *self {
                Self::Single => "SINGLE".to_string(),
                Self::Combination => "COMBINATION".to_string(),
            }
        }
    }
    impl std::str::FromStr for BswapLiquidityRemoveType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "SINGLE" => Ok(Self::Single),
                "COMBINATION" => Ok(Self::Combination),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for BswapLiquidityRemoveType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for BswapLiquidityRemoveType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for BswapLiquidityRemoveType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///BswapLiquidityResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "liquidity",
    ///    "poolId",
    ///    "poolNmae",
    ///    "share",
    ///    "updateTime"
    ///  ],
    ///  "properties": {
    ///    "liquidity": {
    ///      "type": "object",
    ///      "required": [
    ///        "BUSD",
    ///        "USDT"
    ///      ],
    ///      "properties": {
    ///        "BUSD": {
    ///          "examples": [
    ///            100000315.79
    ///          ],
    ///          "type": "number",
    ///          "format": "double"
    ///        },
    ///        "USDT": {
    ///          "examples": [
    ///            99999245.54
    ///          ],
    ///          "type": "number",
    ///          "format": "double"
    ///        }
    ///      }
    ///    },
    ///    "poolId": {
    ///      "examples": [
    ///        2
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "poolNmae": {
    ///      "examples": [
    ///        "BUSD/USDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "share": {
    ///      "type": "object",
    ///      "required": [
    ///        "asset",
    ///        "shareAmount",
    ///        "sharePercentage"
    ///      ],
    ///      "properties": {
    ///        "asset": {
    ///          "type": "object",
    ///          "required": [
    ///            "BUSD",
    ///            "USDT"
    ///          ],
    ///          "properties": {
    ///            "BUSD": {
    ///              "examples": [
    ///                6207.02
    ///              ],
    ///              "type": "number",
    ///              "format": "double"
    ///            },
    ///            "USDT": {
    ///              "examples": [
    ///                6206.95
    ///              ],
    ///              "type": "number",
    ///              "format": "double"
    ///            }
    ///          }
    ///        },
    ///        "shareAmount": {
    ///          "examples": [
    ///            12415
    ///          ],
    ///          "type": "number",
    ///          "format": "double"
    ///        },
    ///        "sharePercentage": {
    ///          "examples": [
    ///            0.00006207
    ///          ],
    ///          "type": "number",
    ///          "format": "double"
    ///        }
    ///      }
    ///    },
    ///    "updateTime": {
    ///      "examples": [
    ///        1565769342148
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct BswapLiquidityResponseItem {
        pub liquidity: BswapLiquidityResponseItemLiquidity,
        #[serde(rename = "poolId")]
        pub pool_id: i64,
        #[serde(rename = "poolNmae")]
        pub pool_nmae: String,
        pub share: BswapLiquidityResponseItemShare,
        #[serde(rename = "updateTime")]
        pub update_time: i64,
    }
    impl From<&BswapLiquidityResponseItem> for BswapLiquidityResponseItem {
        fn from(value: &BswapLiquidityResponseItem) -> Self {
            value.clone()
        }
    }
    ///BswapLiquidityResponseItemLiquidity
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "BUSD",
    ///    "USDT"
    ///  ],
    ///  "properties": {
    ///    "BUSD": {
    ///      "examples": [
    ///        100000315.79
    ///      ],
    ///      "type": "number",
    ///      "format": "double"
    ///    },
    ///    "USDT": {
    ///      "examples": [
    ///        99999245.54
    ///      ],
    ///      "type": "number",
    ///      "format": "double"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct BswapLiquidityResponseItemLiquidity {
        #[serde(rename = "BUSD")]
        pub busd: f64,
        #[serde(rename = "USDT")]
        pub usdt: f64,
    }
    impl From<&BswapLiquidityResponseItemLiquidity>
    for BswapLiquidityResponseItemLiquidity {
        fn from(value: &BswapLiquidityResponseItemLiquidity) -> Self {
            value.clone()
        }
    }
    ///BswapLiquidityResponseItemShare
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "asset",
    ///    "shareAmount",
    ///    "sharePercentage"
    ///  ],
    ///  "properties": {
    ///    "asset": {
    ///      "type": "object",
    ///      "required": [
    ///        "BUSD",
    ///        "USDT"
    ///      ],
    ///      "properties": {
    ///        "BUSD": {
    ///          "examples": [
    ///            6207.02
    ///          ],
    ///          "type": "number",
    ///          "format": "double"
    ///        },
    ///        "USDT": {
    ///          "examples": [
    ///            6206.95
    ///          ],
    ///          "type": "number",
    ///          "format": "double"
    ///        }
    ///      }
    ///    },
    ///    "shareAmount": {
    ///      "examples": [
    ///        12415
    ///      ],
    ///      "type": "number",
    ///      "format": "double"
    ///    },
    ///    "sharePercentage": {
    ///      "examples": [
    ///        0.00006207
    ///      ],
    ///      "type": "number",
    ///      "format": "double"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct BswapLiquidityResponseItemShare {
        pub asset: BswapLiquidityResponseItemShareAsset,
        #[serde(rename = "shareAmount")]
        pub share_amount: f64,
        #[serde(rename = "sharePercentage")]
        pub share_percentage: f64,
    }
    impl From<&BswapLiquidityResponseItemShare> for BswapLiquidityResponseItemShare {
        fn from(value: &BswapLiquidityResponseItemShare) -> Self {
            value.clone()
        }
    }
    ///BswapLiquidityResponseItemShareAsset
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "BUSD",
    ///    "USDT"
    ///  ],
    ///  "properties": {
    ///    "BUSD": {
    ///      "examples": [
    ///        6207.02
    ///      ],
    ///      "type": "number",
    ///      "format": "double"
    ///    },
    ///    "USDT": {
    ///      "examples": [
    ///        6206.95
    ///      ],
    ///      "type": "number",
    ///      "format": "double"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct BswapLiquidityResponseItemShareAsset {
        #[serde(rename = "BUSD")]
        pub busd: f64,
        #[serde(rename = "USDT")]
        pub usdt: f64,
    }
    impl From<&BswapLiquidityResponseItemShareAsset>
    for BswapLiquidityResponseItemShareAsset {
        fn from(value: &BswapLiquidityResponseItemShareAsset) -> Self {
            value.clone()
        }
    }
    ///BswapPoolConfigureResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "assetConfigure",
    ///    "liquidity",
    ///    "poolId",
    ///    "poolNmae",
    ///    "updateTime"
    ///  ],
    ///  "properties": {
    ///    "assetConfigure": {
    ///      "type": "object",
    ///      "required": [
    ///        "BUSD",
    ///        "USDT"
    ///      ],
    ///      "properties": {
    ///        "BUSD": {
    ///          "type": "object",
    ///          "required": [
    ///            "maxAdd",
    ///            "maxSwap",
    ///            "minAdd",
    ///            "minSwap"
    ///          ],
    ///          "properties": {
    ///            "maxAdd": {
    ///              "examples": [
    ///                20
    ///              ],
    ///              "type": "integer",
    ///              "format": "int64"
    ///            },
    ///            "maxSwap": {
    ///              "examples": [
    ///                30
    ///              ],
    ///              "type": "integer",
    ///              "format": "int64"
    ///            },
    ///            "minAdd": {
    ///              "examples": [
    ///                10
    ///              ],
    ///              "type": "integer",
    ///              "format": "int64"
    ///            },
    ///            "minSwap": {
    ///              "examples": [
    ///                10
    ///              ],
    ///              "type": "integer",
    ///              "format": "int64"
    ///            }
    ///          }
    ///        },
    ///        "USDT": {
    ///          "type": "object",
    ///          "required": [
    ///            "maxAdd",
    ///            "maxSwap",
    ///            "minAdd",
    ///            "minSwap"
    ///          ],
    ///          "properties": {
    ///            "maxAdd": {
    ///              "examples": [
    ///                20
    ///              ],
    ///              "type": "integer",
    ///              "format": "int64"
    ///            },
    ///            "maxSwap": {
    ///              "examples": [
    ///                30
    ///              ],
    ///              "type": "integer",
    ///              "format": "int64"
    ///            },
    ///            "minAdd": {
    ///              "examples": [
    ///                10
    ///              ],
    ///              "type": "integer",
    ///              "format": "int64"
    ///            },
    ///            "minSwap": {
    ///              "examples": [
    ///                10
    ///              ],
    ///              "type": "integer",
    ///              "format": "int64"
    ///            }
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "liquidity": {
    ///      "type": "object",
    ///      "required": [
    ///        "constantA",
    ///        "minRedeemShare",
    ///        "slippageTolerance"
    ///      ],
    ///      "properties": {
    ///        "constantA": {
    ///          "description": "\"NA\" if pool is an innovation pool",
    ///          "examples": [
    ///            2000
    ///          ],
    ///          "type": "integer",
    ///          "format": "int64"
    ///        },
    ///        "minRedeemShare": {
    ///          "examples": [
    ///            0.1
    ///          ],
    ///          "type": "number",
    ///          "format": "double"
    ///        },
    ///        "slippageTolerance": {
    ///          "description": "The swap proceeds only when the slippage is within the set range",
    ///          "examples": [
    ///            0.2
    ///          ],
    ///          "type": "number",
    ///          "format": "double"
    ///        }
    ///      }
    ///    },
    ///    "poolId": {
    ///      "examples": [
    ///        2
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "poolNmae": {
    ///      "examples": [
    ///        "BUSD/USDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "updateTime": {
    ///      "examples": [
    ///        1565769342148
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct BswapPoolConfigureResponseItem {
        #[serde(rename = "assetConfigure")]
        pub asset_configure: BswapPoolConfigureResponseItemAssetConfigure,
        pub liquidity: BswapPoolConfigureResponseItemLiquidity,
        #[serde(rename = "poolId")]
        pub pool_id: i64,
        #[serde(rename = "poolNmae")]
        pub pool_nmae: String,
        #[serde(rename = "updateTime")]
        pub update_time: i64,
    }
    impl From<&BswapPoolConfigureResponseItem> for BswapPoolConfigureResponseItem {
        fn from(value: &BswapPoolConfigureResponseItem) -> Self {
            value.clone()
        }
    }
    ///BswapPoolConfigureResponseItemAssetConfigure
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "BUSD",
    ///    "USDT"
    ///  ],
    ///  "properties": {
    ///    "BUSD": {
    ///      "type": "object",
    ///      "required": [
    ///        "maxAdd",
    ///        "maxSwap",
    ///        "minAdd",
    ///        "minSwap"
    ///      ],
    ///      "properties": {
    ///        "maxAdd": {
    ///          "examples": [
    ///            20
    ///          ],
    ///          "type": "integer",
    ///          "format": "int64"
    ///        },
    ///        "maxSwap": {
    ///          "examples": [
    ///            30
    ///          ],
    ///          "type": "integer",
    ///          "format": "int64"
    ///        },
    ///        "minAdd": {
    ///          "examples": [
    ///            10
    ///          ],
    ///          "type": "integer",
    ///          "format": "int64"
    ///        },
    ///        "minSwap": {
    ///          "examples": [
    ///            10
    ///          ],
    ///          "type": "integer",
    ///          "format": "int64"
    ///        }
    ///      }
    ///    },
    ///    "USDT": {
    ///      "type": "object",
    ///      "required": [
    ///        "maxAdd",
    ///        "maxSwap",
    ///        "minAdd",
    ///        "minSwap"
    ///      ],
    ///      "properties": {
    ///        "maxAdd": {
    ///          "examples": [
    ///            20
    ///          ],
    ///          "type": "integer",
    ///          "format": "int64"
    ///        },
    ///        "maxSwap": {
    ///          "examples": [
    ///            30
    ///          ],
    ///          "type": "integer",
    ///          "format": "int64"
    ///        },
    ///        "minAdd": {
    ///          "examples": [
    ///            10
    ///          ],
    ///          "type": "integer",
    ///          "format": "int64"
    ///        },
    ///        "minSwap": {
    ///          "examples": [
    ///            10
    ///          ],
    ///          "type": "integer",
    ///          "format": "int64"
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct BswapPoolConfigureResponseItemAssetConfigure {
        #[serde(rename = "BUSD")]
        pub busd: BswapPoolConfigureResponseItemAssetConfigureBusd,
        #[serde(rename = "USDT")]
        pub usdt: BswapPoolConfigureResponseItemAssetConfigureUsdt,
    }
    impl From<&BswapPoolConfigureResponseItemAssetConfigure>
    for BswapPoolConfigureResponseItemAssetConfigure {
        fn from(value: &BswapPoolConfigureResponseItemAssetConfigure) -> Self {
            value.clone()
        }
    }
    ///BswapPoolConfigureResponseItemAssetConfigureBusd
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "maxAdd",
    ///    "maxSwap",
    ///    "minAdd",
    ///    "minSwap"
    ///  ],
    ///  "properties": {
    ///    "maxAdd": {
    ///      "examples": [
    ///        20
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "maxSwap": {
    ///      "examples": [
    ///        30
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "minAdd": {
    ///      "examples": [
    ///        10
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "minSwap": {
    ///      "examples": [
    ///        10
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct BswapPoolConfigureResponseItemAssetConfigureBusd {
        #[serde(rename = "maxAdd")]
        pub max_add: i64,
        #[serde(rename = "maxSwap")]
        pub max_swap: i64,
        #[serde(rename = "minAdd")]
        pub min_add: i64,
        #[serde(rename = "minSwap")]
        pub min_swap: i64,
    }
    impl From<&BswapPoolConfigureResponseItemAssetConfigureBusd>
    for BswapPoolConfigureResponseItemAssetConfigureBusd {
        fn from(value: &BswapPoolConfigureResponseItemAssetConfigureBusd) -> Self {
            value.clone()
        }
    }
    ///BswapPoolConfigureResponseItemAssetConfigureUsdt
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "maxAdd",
    ///    "maxSwap",
    ///    "minAdd",
    ///    "minSwap"
    ///  ],
    ///  "properties": {
    ///    "maxAdd": {
    ///      "examples": [
    ///        20
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "maxSwap": {
    ///      "examples": [
    ///        30
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "minAdd": {
    ///      "examples": [
    ///        10
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "minSwap": {
    ///      "examples": [
    ///        10
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct BswapPoolConfigureResponseItemAssetConfigureUsdt {
        #[serde(rename = "maxAdd")]
        pub max_add: i64,
        #[serde(rename = "maxSwap")]
        pub max_swap: i64,
        #[serde(rename = "minAdd")]
        pub min_add: i64,
        #[serde(rename = "minSwap")]
        pub min_swap: i64,
    }
    impl From<&BswapPoolConfigureResponseItemAssetConfigureUsdt>
    for BswapPoolConfigureResponseItemAssetConfigureUsdt {
        fn from(value: &BswapPoolConfigureResponseItemAssetConfigureUsdt) -> Self {
            value.clone()
        }
    }
    ///BswapPoolConfigureResponseItemLiquidity
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "constantA",
    ///    "minRedeemShare",
    ///    "slippageTolerance"
    ///  ],
    ///  "properties": {
    ///    "constantA": {
    ///      "description": "\"NA\" if pool is an innovation pool",
    ///      "examples": [
    ///        2000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "minRedeemShare": {
    ///      "examples": [
    ///        0.1
    ///      ],
    ///      "type": "number",
    ///      "format": "double"
    ///    },
    ///    "slippageTolerance": {
    ///      "description": "The swap proceeds only when the slippage is within the set range",
    ///      "examples": [
    ///        0.2
    ///      ],
    ///      "type": "number",
    ///      "format": "double"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct BswapPoolConfigureResponseItemLiquidity {
        ///"NA" if pool is an innovation pool
        #[serde(rename = "constantA")]
        pub constant_a: i64,
        #[serde(rename = "minRedeemShare")]
        pub min_redeem_share: f64,
        #[serde(rename = "slippageTolerance")]
        pub slippage_tolerance: f64,
    }
    impl From<&BswapPoolConfigureResponseItemLiquidity>
    for BswapPoolConfigureResponseItemLiquidity {
        fn from(value: &BswapPoolConfigureResponseItemLiquidity) -> Self {
            value.clone()
        }
    }
    ///BswapPoolsResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "assets",
    ///    "poolId",
    ///    "poolName"
    ///  ],
    ///  "properties": {
    ///    "assets": {
    ///      "examples": [
    ///        [
    ///          "BUSD",
    ///          "USDT"
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string",
    ///        "maxItems": 2,
    ///        "minItems": 2
    ///      }
    ///    },
    ///    "poolId": {
    ///      "examples": [
    ///        2
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "poolName": {
    ///      "examples": [
    ///        "BUSD/USDT"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct BswapPoolsResponseItem {
        pub assets: Vec<String>,
        #[serde(rename = "poolId")]
        pub pool_id: i64,
        #[serde(rename = "poolName")]
        pub pool_name: String,
    }
    impl From<&BswapPoolsResponseItem> for BswapPoolsResponseItem {
        fn from(value: &BswapPoolsResponseItem) -> Self {
            value.clone()
        }
    }
    ///BswapQuoteResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "baseAsset",
    ///    "baseQty",
    ///    "fee",
    ///    "price",
    ///    "quoteAsset",
    ///    "quoteQty",
    ///    "slippage"
    ///  ],
    ///  "properties": {
    ///    "baseAsset": {
    ///      "examples": [
    ///        "BUSD"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "baseQty": {
    ///      "examples": [
    ///        299975
    ///      ],
    ///      "type": "number",
    ///      "format": "double"
    ///    },
    ///    "fee": {
    ///      "examples": [
    ///        120
    ///      ],
    ///      "type": "number",
    ///      "format": "double"
    ///    },
    ///    "price": {
    ///      "examples": [
    ///        1.00008334
    ///      ],
    ///      "type": "number",
    ///      "format": "double"
    ///    },
    ///    "quoteAsset": {
    ///      "examples": [
    ///        "USDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "quoteQty": {
    ///      "examples": [
    ///        300000
    ///      ],
    ///      "type": "number",
    ///      "format": "double"
    ///    },
    ///    "slippage": {
    ///      "examples": [
    ///        0.00007245
    ///      ],
    ///      "type": "number",
    ///      "format": "double"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct BswapQuoteResponse {
        #[serde(rename = "baseAsset")]
        pub base_asset: String,
        #[serde(rename = "baseQty")]
        pub base_qty: f64,
        pub fee: f64,
        pub price: f64,
        #[serde(rename = "quoteAsset")]
        pub quote_asset: String,
        #[serde(rename = "quoteQty")]
        pub quote_qty: f64,
        pub slippage: f64,
    }
    impl From<&BswapQuoteResponse> for BswapQuoteResponse {
        fn from(value: &BswapQuoteResponse) -> Self {
            value.clone()
        }
    }
    ///BswapRemoveLiquidityPreviewResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/bswapRmvLiquidityPreviewCombination"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/bswapRmvLiquidityPreviewSingle"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    #[serde(untagged)]
    pub enum BswapRemoveLiquidityPreviewResponse {
        Combination(BswapRmvLiquidityPreviewCombination),
        Single(BswapRmvLiquidityPreviewSingle),
    }
    impl From<&BswapRemoveLiquidityPreviewResponse>
    for BswapRemoveLiquidityPreviewResponse {
        fn from(value: &BswapRemoveLiquidityPreviewResponse) -> Self {
            value.clone()
        }
    }
    impl From<BswapRmvLiquidityPreviewCombination>
    for BswapRemoveLiquidityPreviewResponse {
        fn from(value: BswapRmvLiquidityPreviewCombination) -> Self {
            Self::Combination(value)
        }
    }
    impl From<BswapRmvLiquidityPreviewSingle> for BswapRemoveLiquidityPreviewResponse {
        fn from(value: BswapRmvLiquidityPreviewSingle) -> Self {
            Self::Single(value)
        }
    }
    ///BswapRemoveLiquidityPreviewType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "SINGLE"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "SINGLE",
    ///    "COMBINATION"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum BswapRemoveLiquidityPreviewType {
        #[serde(rename = "SINGLE")]
        Single,
        #[serde(rename = "COMBINATION")]
        Combination,
    }
    impl From<&BswapRemoveLiquidityPreviewType> for BswapRemoveLiquidityPreviewType {
        fn from(value: &BswapRemoveLiquidityPreviewType) -> Self {
            value.clone()
        }
    }
    impl ToString for BswapRemoveLiquidityPreviewType {
        fn to_string(&self) -> String {
            match *self {
                Self::Single => "SINGLE".to_string(),
                Self::Combination => "COMBINATION".to_string(),
            }
        }
    }
    impl std::str::FromStr for BswapRemoveLiquidityPreviewType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "SINGLE" => Ok(Self::Single),
                "COMBINATION" => Ok(Self::Combination),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for BswapRemoveLiquidityPreviewType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for BswapRemoveLiquidityPreviewType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for BswapRemoveLiquidityPreviewType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///BswapRmvLiquidityPreviewCombination
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "baseAmt",
    ///    "baseAsset",
    ///    "price",
    ///    "quoteAmt",
    ///    "quoteAsset"
    ///  ],
    ///  "properties": {
    ///    "baseAmt": {
    ///      "examples": [
    ///        299975
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "baseAsset": {
    ///      "examples": [
    ///        "BUSD"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "price": {
    ///      "examples": [
    ///        1.00008334
    ///      ],
    ///      "type": "number",
    ///      "format": "double"
    ///    },
    ///    "quoteAmt": {
    ///      "examples": [
    ///        300000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "quoteAsset": {
    ///      "examples": [
    ///        "USDT"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct BswapRmvLiquidityPreviewCombination {
        #[serde(rename = "baseAmt")]
        pub base_amt: i64,
        #[serde(rename = "baseAsset")]
        pub base_asset: String,
        pub price: f64,
        #[serde(rename = "quoteAmt")]
        pub quote_amt: i64,
        #[serde(rename = "quoteAsset")]
        pub quote_asset: String,
    }
    impl From<&BswapRmvLiquidityPreviewCombination>
    for BswapRmvLiquidityPreviewCombination {
        fn from(value: &BswapRmvLiquidityPreviewCombination) -> Self {
            value.clone()
        }
    }
    ///BswapRmvLiquidityPreviewSingle
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "fee",
    ///    "price",
    ///    "quoteAmt",
    ///    "quoteAsset",
    ///    "slippage"
    ///  ],
    ///  "properties": {
    ///    "fee": {
    ///      "examples": [
    ///        120
    ///      ],
    ///      "type": "number",
    ///      "format": "double"
    ///    },
    ///    "price": {
    ///      "examples": [
    ///        1.00008334
    ///      ],
    ///      "type": "number",
    ///      "format": "double"
    ///    },
    ///    "quoteAmt": {
    ///      "examples": [
    ///        300000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "quoteAsset": {
    ///      "examples": [
    ///        "USDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "slippage": {
    ///      "examples": [
    ///        0.00007245
    ///      ],
    ///      "type": "number",
    ///      "format": "double"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct BswapRmvLiquidityPreviewSingle {
        pub fee: f64,
        pub price: f64,
        #[serde(rename = "quoteAmt")]
        pub quote_amt: i64,
        #[serde(rename = "quoteAsset")]
        pub quote_asset: String,
        pub slippage: f64,
    }
    impl From<&BswapRmvLiquidityPreviewSingle> for BswapRmvLiquidityPreviewSingle {
        fn from(value: &BswapRmvLiquidityPreviewSingle) -> Self {
            value.clone()
        }
    }
    ///BswapSwapResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "swapId"
    ///  ],
    ///  "properties": {
    ///    "swapId": {
    ///      "examples": [
    ///        2314
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct BswapSwapResponse {
        #[serde(rename = "swapId")]
        pub swap_id: i64,
    }
    impl From<&BswapSwapResponse> for BswapSwapResponse {
        fn from(value: &BswapSwapResponse) -> Self {
            value.clone()
        }
    }
    ///BswapUnclaimedRewardsResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "details",
    ///    "totalUnclaimedRewards"
    ///  ],
    ///  "properties": {
    ///    "details": {
    ///      "type": "object",
    ///      "required": [
    ///        "BNB/BTC",
    ///        "BNB/USDT"
    ///      ],
    ///      "properties": {
    ///        "BNB/BTC": {
    ///          "type": "object",
    ///          "required": [
    ///            "BNB"
    ///          ],
    ///          "properties": {
    ///            "BNB": {
    ///              "examples": [
    ///                1e-8
    ///              ],
    ///              "type": "number",
    ///              "format": "double"
    ///            }
    ///          }
    ///        },
    ///        "BNB/USDT": {
    ///          "type": "object",
    ///          "required": [
    ///            "BUSD",
    ///            "USDT"
    ///          ],
    ///          "properties": {
    ///            "BUSD": {
    ///              "examples": [
    ///                100000315.79
    ///              ],
    ///              "type": "number",
    ///              "format": "float"
    ///            },
    ///            "USDT": {
    ///              "examples": [
    ///                2e-8
    ///              ],
    ///              "type": "number",
    ///              "format": "double"
    ///            }
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "totalUnclaimedRewards": {
    ///      "type": "object",
    ///      "required": [
    ///        "BNB",
    ///        "BUSD",
    ///        "USDT"
    ///      ],
    ///      "properties": {
    ///        "BNB": {
    ///          "examples": [
    ///            1e-8
    ///          ],
    ///          "type": "number",
    ///          "format": "double"
    ///        },
    ///        "BUSD": {
    ///          "examples": [
    ///            100000315.79
    ///          ],
    ///          "type": "number",
    ///          "format": "float"
    ///        },
    ///        "USDT": {
    ///          "examples": [
    ///            2e-8
    ///          ],
    ///          "type": "number",
    ///          "format": "double"
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct BswapUnclaimedRewardsResponse {
        pub details: BswapUnclaimedRewardsResponseDetails,
        #[serde(rename = "totalUnclaimedRewards")]
        pub total_unclaimed_rewards: BswapUnclaimedRewardsResponseTotalUnclaimedRewards,
    }
    impl From<&BswapUnclaimedRewardsResponse> for BswapUnclaimedRewardsResponse {
        fn from(value: &BswapUnclaimedRewardsResponse) -> Self {
            value.clone()
        }
    }
    ///BswapUnclaimedRewardsResponseDetails
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "BNB/BTC",
    ///    "BNB/USDT"
    ///  ],
    ///  "properties": {
    ///    "BNB/BTC": {
    ///      "type": "object",
    ///      "required": [
    ///        "BNB"
    ///      ],
    ///      "properties": {
    ///        "BNB": {
    ///          "examples": [
    ///            1e-8
    ///          ],
    ///          "type": "number",
    ///          "format": "double"
    ///        }
    ///      }
    ///    },
    ///    "BNB/USDT": {
    ///      "type": "object",
    ///      "required": [
    ///        "BUSD",
    ///        "USDT"
    ///      ],
    ///      "properties": {
    ///        "BUSD": {
    ///          "examples": [
    ///            100000315.79
    ///          ],
    ///          "type": "number",
    ///          "format": "float"
    ///        },
    ///        "USDT": {
    ///          "examples": [
    ///            2e-8
    ///          ],
    ///          "type": "number",
    ///          "format": "double"
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct BswapUnclaimedRewardsResponseDetails {
        #[serde(rename = "BNB/BTC")]
        pub bnb_btc: BswapUnclaimedRewardsResponseDetailsBnbBtc,
        #[serde(rename = "BNB/USDT")]
        pub bnb_usdt: BswapUnclaimedRewardsResponseDetailsBnbUsdt,
    }
    impl From<&BswapUnclaimedRewardsResponseDetails>
    for BswapUnclaimedRewardsResponseDetails {
        fn from(value: &BswapUnclaimedRewardsResponseDetails) -> Self {
            value.clone()
        }
    }
    ///BswapUnclaimedRewardsResponseDetailsBnbBtc
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "BNB"
    ///  ],
    ///  "properties": {
    ///    "BNB": {
    ///      "examples": [
    ///        1e-8
    ///      ],
    ///      "type": "number",
    ///      "format": "double"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct BswapUnclaimedRewardsResponseDetailsBnbBtc {
        #[serde(rename = "BNB")]
        pub bnb: f64,
    }
    impl From<&BswapUnclaimedRewardsResponseDetailsBnbBtc>
    for BswapUnclaimedRewardsResponseDetailsBnbBtc {
        fn from(value: &BswapUnclaimedRewardsResponseDetailsBnbBtc) -> Self {
            value.clone()
        }
    }
    ///BswapUnclaimedRewardsResponseDetailsBnbUsdt
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "BUSD",
    ///    "USDT"
    ///  ],
    ///  "properties": {
    ///    "BUSD": {
    ///      "examples": [
    ///        100000315.79
    ///      ],
    ///      "type": "number",
    ///      "format": "float"
    ///    },
    ///    "USDT": {
    ///      "examples": [
    ///        2e-8
    ///      ],
    ///      "type": "number",
    ///      "format": "double"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct BswapUnclaimedRewardsResponseDetailsBnbUsdt {
        #[serde(rename = "BUSD")]
        pub busd: f32,
        #[serde(rename = "USDT")]
        pub usdt: f64,
    }
    impl From<&BswapUnclaimedRewardsResponseDetailsBnbUsdt>
    for BswapUnclaimedRewardsResponseDetailsBnbUsdt {
        fn from(value: &BswapUnclaimedRewardsResponseDetailsBnbUsdt) -> Self {
            value.clone()
        }
    }
    ///BswapUnclaimedRewardsResponseTotalUnclaimedRewards
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "BNB",
    ///    "BUSD",
    ///    "USDT"
    ///  ],
    ///  "properties": {
    ///    "BNB": {
    ///      "examples": [
    ///        1e-8
    ///      ],
    ///      "type": "number",
    ///      "format": "double"
    ///    },
    ///    "BUSD": {
    ///      "examples": [
    ///        100000315.79
    ///      ],
    ///      "type": "number",
    ///      "format": "float"
    ///    },
    ///    "USDT": {
    ///      "examples": [
    ///        2e-8
    ///      ],
    ///      "type": "number",
    ///      "format": "double"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct BswapUnclaimedRewardsResponseTotalUnclaimedRewards {
        #[serde(rename = "BNB")]
        pub bnb: f64,
        #[serde(rename = "BUSD")]
        pub busd: f32,
        #[serde(rename = "USDT")]
        pub usdt: f64,
    }
    impl From<&BswapUnclaimedRewardsResponseTotalUnclaimedRewards>
    for BswapUnclaimedRewardsResponseTotalUnclaimedRewards {
        fn from(value: &BswapUnclaimedRewardsResponseTotalUnclaimedRewards) -> Self {
            value.clone()
        }
    }
    ///C2cOrderMatchListUserOrderHistoryResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "code",
    ///    "data",
    ///    "message",
    ///    "success",
    ///    "total"
    ///  ],
    ///  "properties": {
    ///    "code": {
    ///      "examples": [
    ///        "000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "data": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "advNo",
    ///          "advertisementRole",
    ///          "amount",
    ///          "asset",
    ///          "commission",
    ///          "counterPartNickName",
    ///          "createTime",
    ///          "fiat",
    ///          "fiatSymbol",
    ///          "orderNumber",
    ///          "orderStatus",
    ///          "totalPrice",
    ///          "tradeType",
    ///          "unitPrice"
    ///        ],
    ///        "properties": {
    ///          "advNo": {
    ///            "examples": [
    ///              "11218246497340923904"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "advertisementRole": {
    ///            "examples": [
    ///              "TAKER"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "amount": {
    ///            "description": "Quantity (in Crypto)",
    ///            "examples": [
    ///              "5000.00000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "asset": {
    ///            "examples": [
    ///              "BUSD"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "commission": {
    ///            "description": "Transaction Fee (in Crypto)",
    ///            "examples": [
    ///              "0"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "counterPartNickName": {
    ///            "examples": [
    ///              "ab***"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "createTime": {
    ///            "examples": [
    ///              1619361369000
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "fiat": {
    ///            "examples": [
    ///              "CNY"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "fiatSymbol": {
    ///            "examples": [
    ///              ""
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "orderNumber": {
    ///            "examples": [
    ///              "20219644646554779648"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "orderStatus": {
    ///            "description": "PENDING, TRADING, BUYER_PAYED, DISTRIBUTING, COMPLETED, IN_APPEAL, CANCELLED, CANCELLED_BY_SYSTEM",
    ///            "examples": [
    ///              "COMPLETED"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "totalPrice": {
    ///            "examples": [
    ///              "33400.00000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "tradeType": {
    ///            "examples": [
    ///              "SELL"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "unitPrice": {
    ///            "description": "Unit Price (in Fiat)",
    ///            "examples": [
    ///              "6.68"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "message": {
    ///      "examples": [
    ///        "success"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "success": {
    ///      "type": "boolean"
    ///    },
    ///    "total": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct C2cOrderMatchListUserOrderHistoryResponse {
        pub code: String,
        pub data: Vec<C2cOrderMatchListUserOrderHistoryResponseDataItem>,
        pub message: String,
        pub success: bool,
        pub total: i32,
    }
    impl From<&C2cOrderMatchListUserOrderHistoryResponse>
    for C2cOrderMatchListUserOrderHistoryResponse {
        fn from(value: &C2cOrderMatchListUserOrderHistoryResponse) -> Self {
            value.clone()
        }
    }
    ///C2cOrderMatchListUserOrderHistoryResponseDataItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "advNo",
    ///    "advertisementRole",
    ///    "amount",
    ///    "asset",
    ///    "commission",
    ///    "counterPartNickName",
    ///    "createTime",
    ///    "fiat",
    ///    "fiatSymbol",
    ///    "orderNumber",
    ///    "orderStatus",
    ///    "totalPrice",
    ///    "tradeType",
    ///    "unitPrice"
    ///  ],
    ///  "properties": {
    ///    "advNo": {
    ///      "examples": [
    ///        "11218246497340923904"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "advertisementRole": {
    ///      "examples": [
    ///        "TAKER"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "amount": {
    ///      "description": "Quantity (in Crypto)",
    ///      "examples": [
    ///        "5000.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "asset": {
    ///      "examples": [
    ///        "BUSD"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "commission": {
    ///      "description": "Transaction Fee (in Crypto)",
    ///      "examples": [
    ///        "0"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "counterPartNickName": {
    ///      "examples": [
    ///        "ab***"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "createTime": {
    ///      "examples": [
    ///        1619361369000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "fiat": {
    ///      "examples": [
    ///        "CNY"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "fiatSymbol": {
    ///      "examples": [
    ///        ""
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "orderNumber": {
    ///      "examples": [
    ///        "20219644646554779648"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "orderStatus": {
    ///      "description": "PENDING, TRADING, BUYER_PAYED, DISTRIBUTING, COMPLETED, IN_APPEAL, CANCELLED, CANCELLED_BY_SYSTEM",
    ///      "examples": [
    ///        "COMPLETED"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalPrice": {
    ///      "examples": [
    ///        "33400.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "tradeType": {
    ///      "examples": [
    ///        "SELL"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "unitPrice": {
    ///      "description": "Unit Price (in Fiat)",
    ///      "examples": [
    ///        "6.68"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct C2cOrderMatchListUserOrderHistoryResponseDataItem {
        #[serde(rename = "advNo")]
        pub adv_no: String,
        #[serde(rename = "advertisementRole")]
        pub advertisement_role: String,
        ///Quantity (in Crypto)
        pub amount: String,
        pub asset: String,
        ///Transaction Fee (in Crypto)
        pub commission: String,
        #[serde(rename = "counterPartNickName")]
        pub counter_part_nick_name: String,
        #[serde(rename = "createTime")]
        pub create_time: i64,
        pub fiat: String,
        #[serde(rename = "fiatSymbol")]
        pub fiat_symbol: String,
        #[serde(rename = "orderNumber")]
        pub order_number: String,
        ///PENDING, TRADING, BUYER_PAYED, DISTRIBUTING, COMPLETED, IN_APPEAL, CANCELLED, CANCELLED_BY_SYSTEM
        #[serde(rename = "orderStatus")]
        pub order_status: String,
        #[serde(rename = "totalPrice")]
        pub total_price: String,
        #[serde(rename = "tradeType")]
        pub trade_type: String,
        ///Unit Price (in Fiat)
        #[serde(rename = "unitPrice")]
        pub unit_price: String,
    }
    impl From<&C2cOrderMatchListUserOrderHistoryResponseDataItem>
    for C2cOrderMatchListUserOrderHistoryResponseDataItem {
        fn from(value: &C2cOrderMatchListUserOrderHistoryResponseDataItem) -> Self {
            value.clone()
        }
    }
    ///C2cOrderMatchListUserOrderHistoryTradeType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "BUY",
    ///    "SELL"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum C2cOrderMatchListUserOrderHistoryTradeType {
        #[serde(rename = "BUY")]
        Buy,
        #[serde(rename = "SELL")]
        Sell,
    }
    impl From<&C2cOrderMatchListUserOrderHistoryTradeType>
    for C2cOrderMatchListUserOrderHistoryTradeType {
        fn from(value: &C2cOrderMatchListUserOrderHistoryTradeType) -> Self {
            value.clone()
        }
    }
    impl ToString for C2cOrderMatchListUserOrderHistoryTradeType {
        fn to_string(&self) -> String {
            match *self {
                Self::Buy => "BUY".to_string(),
                Self::Sell => "SELL".to_string(),
            }
        }
    }
    impl std::str::FromStr for C2cOrderMatchListUserOrderHistoryTradeType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "BUY" => Ok(Self::Buy),
                "SELL" => Ok(Self::Sell),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for C2cOrderMatchListUserOrderHistoryTradeType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for C2cOrderMatchListUserOrderHistoryTradeType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for C2cOrderMatchListUserOrderHistoryTradeType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///CancelAlgoFuturesOrderResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "algoId",
    ///    "code",
    ///    "msg",
    ///    "success"
    ///  ],
    ///  "properties": {
    ///    "algoId": {
    ///      "examples": [
    ///        14511
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "code": {
    ///      "examples": [
    ///        0
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "msg": {
    ///      "examples": [
    ///        "OK"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "success": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct CancelAlgoFuturesOrderResponse {
        #[serde(rename = "algoId")]
        pub algo_id: i64,
        pub code: i64,
        pub msg: String,
        pub success: bool,
    }
    impl From<&CancelAlgoFuturesOrderResponse> for CancelAlgoFuturesOrderResponse {
        fn from(value: &CancelAlgoFuturesOrderResponse) -> Self {
            value.clone()
        }
    }
    ///CancelAlgoSpotOrderResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "algoId",
    ///    "code",
    ///    "msg",
    ///    "success"
    ///  ],
    ///  "properties": {
    ///    "algoId": {
    ///      "examples": [
    ///        14511
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "code": {
    ///      "examples": [
    ///        0
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "msg": {
    ///      "examples": [
    ///        "OK"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "success": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct CancelAlgoSpotOrderResponse {
        #[serde(rename = "algoId")]
        pub algo_id: i64,
        pub code: i64,
        pub msg: String,
        pub success: bool,
    }
    impl From<&CancelAlgoSpotOrderResponse> for CancelAlgoSpotOrderResponse {
        fn from(value: &CancelAlgoSpotOrderResponse) -> Self {
            value.clone()
        }
    }
    ///CancelMarginOrderIsIsolated
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "TRUE",
    ///    "FALSE"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum CancelMarginOrderIsIsolated {
        #[serde(rename = "TRUE")]
        True,
        #[serde(rename = "FALSE")]
        False,
    }
    impl From<&CancelMarginOrderIsIsolated> for CancelMarginOrderIsIsolated {
        fn from(value: &CancelMarginOrderIsIsolated) -> Self {
            value.clone()
        }
    }
    impl ToString for CancelMarginOrderIsIsolated {
        fn to_string(&self) -> String {
            match *self {
                Self::True => "TRUE".to_string(),
                Self::False => "FALSE".to_string(),
            }
        }
    }
    impl std::str::FromStr for CancelMarginOrderIsIsolated {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "TRUE" => Ok(Self::True),
                "FALSE" => Ok(Self::False),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for CancelMarginOrderIsIsolated {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for CancelMarginOrderIsIsolated {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for CancelMarginOrderIsIsolated {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///CancelMarginOrderOcoIsIsolated
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "TRUE",
    ///    "FALSE"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum CancelMarginOrderOcoIsIsolated {
        #[serde(rename = "TRUE")]
        True,
        #[serde(rename = "FALSE")]
        False,
    }
    impl From<&CancelMarginOrderOcoIsIsolated> for CancelMarginOrderOcoIsIsolated {
        fn from(value: &CancelMarginOrderOcoIsIsolated) -> Self {
            value.clone()
        }
    }
    impl ToString for CancelMarginOrderOcoIsIsolated {
        fn to_string(&self) -> String {
            match *self {
                Self::True => "TRUE".to_string(),
                Self::False => "FALSE".to_string(),
            }
        }
    }
    impl std::str::FromStr for CancelMarginOrderOcoIsIsolated {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "TRUE" => Ok(Self::True),
                "FALSE" => Ok(Self::False),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for CancelMarginOrderOcoIsIsolated {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for CancelMarginOrderOcoIsIsolated {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for CancelMarginOrderOcoIsIsolated {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///CancelOpenOrdersResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "anyOf": [
    ///    {
    ///      "$ref": "#/components/schemas/order"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/ocoOrder"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    #[serde(untagged)]
    pub enum CancelOpenOrdersResponseItem {
        Order(Order),
        OcoOrder(OcoOrder),
    }
    impl From<&CancelOpenOrdersResponseItem> for CancelOpenOrdersResponseItem {
        fn from(value: &CancelOpenOrdersResponseItem) -> Self {
            value.clone()
        }
    }
    impl From<Order> for CancelOpenOrdersResponseItem {
        fn from(value: Order) -> Self {
            Self::Order(value)
        }
    }
    impl From<OcoOrder> for CancelOpenOrdersResponseItem {
        fn from(value: OcoOrder) -> Self {
            Self::OcoOrder(value)
        }
    }
    ///CancelOrderCancelRestrictions
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "ONLY_NEW"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "ONLY_NEW",
    ///    "ONLY_PARTIALLY_FILLED"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum CancelOrderCancelRestrictions {
        #[serde(rename = "ONLY_NEW")]
        OnlyNew,
        #[serde(rename = "ONLY_PARTIALLY_FILLED")]
        OnlyPartiallyFilled,
    }
    impl From<&CancelOrderCancelRestrictions> for CancelOrderCancelRestrictions {
        fn from(value: &CancelOrderCancelRestrictions) -> Self {
            value.clone()
        }
    }
    impl ToString for CancelOrderCancelRestrictions {
        fn to_string(&self) -> String {
            match *self {
                Self::OnlyNew => "ONLY_NEW".to_string(),
                Self::OnlyPartiallyFilled => "ONLY_PARTIALLY_FILLED".to_string(),
            }
        }
    }
    impl std::str::FromStr for CancelOrderCancelRestrictions {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "ONLY_NEW" => Ok(Self::OnlyNew),
                "ONLY_PARTIALLY_FILLED" => Ok(Self::OnlyPartiallyFilled),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for CancelOrderCancelRestrictions {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for CancelOrderCancelRestrictions {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for CancelOrderCancelRestrictions {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///CanceledMarginOrderDetail
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "clientOrderId",
    ///    "cummulativeQuoteQty",
    ///    "executedQty",
    ///    "isIsolated",
    ///    "orderId",
    ///    "orderListId",
    ///    "origClientOrderId",
    ///    "origQty",
    ///    "price",
    ///    "side",
    ///    "status",
    ///    "symbol",
    ///    "timeInForce",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "clientOrderId": {
    ///      "examples": [
    ///        "pXLV6Hz6mprAcVYpVMTGgx"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "cummulativeQuoteQty": {
    ///      "examples": [
    ///        "0.000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "executedQty": {
    ///      "examples": [
    ///        "0.000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "isIsolated": {
    ///      "type": "boolean"
    ///    },
    ///    "orderId": {
    ///      "examples": [
    ///        11
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "orderListId": {
    ///      "examples": [
    ///        -1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "origClientOrderId": {
    ///      "examples": [
    ///        "E6APeyTJvkMvLMYMqu1KQ4"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "origQty": {
    ///      "examples": [
    ///        "0.178622"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "price": {
    ///      "examples": [
    ///        "0.089853"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "side": {
    ///      "examples": [
    ///        "BUY"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "examples": [
    ///        "CANCELED"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "symbol": {
    ///      "examples": [
    ///        "BNBUSDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "timeInForce": {
    ///      "examples": [
    ///        "GTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "examples": [
    ///        "LIMIT"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct CanceledMarginOrderDetail {
        #[serde(rename = "clientOrderId")]
        pub client_order_id: String,
        #[serde(rename = "cummulativeQuoteQty")]
        pub cummulative_quote_qty: String,
        #[serde(rename = "executedQty")]
        pub executed_qty: String,
        #[serde(rename = "isIsolated")]
        pub is_isolated: bool,
        #[serde(rename = "orderId")]
        pub order_id: i64,
        #[serde(rename = "orderListId")]
        pub order_list_id: i64,
        #[serde(rename = "origClientOrderId")]
        pub orig_client_order_id: String,
        #[serde(rename = "origQty")]
        pub orig_qty: String,
        pub price: String,
        pub side: String,
        pub status: String,
        pub symbol: String,
        #[serde(rename = "timeInForce")]
        pub time_in_force: String,
        #[serde(rename = "type")]
        pub type_: String,
    }
    impl From<&CanceledMarginOrderDetail> for CanceledMarginOrderDetail {
        fn from(value: &CanceledMarginOrderDetail) -> Self {
            value.clone()
        }
    }
    ///CapitalConfigGetallResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "coin",
    ///    "depositAllEnable",
    ///    "free",
    ///    "freeze",
    ///    "ipoable",
    ///    "ipoing",
    ///    "isLegalMoney",
    ///    "locked",
    ///    "name",
    ///    "networkList",
    ///    "storage",
    ///    "trading",
    ///    "withdrawAllEnable",
    ///    "withdrawing"
    ///  ],
    ///  "properties": {
    ///    "coin": {
    ///      "examples": [
    ///        "BTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "depositAllEnable": {
    ///      "type": "boolean"
    ///    },
    ///    "free": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "freeze": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "ipoable": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "ipoing": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "isLegalMoney": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "locked": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "examples": [
    ///        "Bitcoin"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "networkList": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "addressRegex",
    ///          "coin",
    ///          "depositDesc",
    ///          "depositEnable",
    ///          "isDefault",
    ///          "memoRegex",
    ///          "minConfirm",
    ///          "name",
    ///          "network",
    ///          "resetAddressStatus",
    ///          "sameAddress",
    ///          "specialTips",
    ///          "unLockConfirm",
    ///          "withdrawDesc",
    ///          "withdrawEnable",
    ///          "withdrawFee",
    ///          "withdrawIntegerMultiple",
    ///          "withdrawMax",
    ///          "withdrawMin"
    ///        ],
    ///        "properties": {
    ///          "addressRegex": {
    ///            "examples": [
    ///              "^(bnb1)[0-9a-z]{38}$"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "coin": {
    ///            "examples": [
    ///              "BTC"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "depositDesc": {
    ///            "description": "shown only when \"depositEnable\" is false.",
    ///            "examples": [
    ///              "Wallet Maintenance, Deposit Suspended"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "depositEnable": {
    ///            "examples": [
    ///              false
    ///            ],
    ///            "type": "boolean"
    ///          },
    ///          "isDefault": {
    ///            "examples": [
    ///              false
    ///            ],
    ///            "type": "boolean"
    ///          },
    ///          "memoRegex": {
    ///            "examples": [
    ///              "^[0-9A-Za-z\\-_]{1,120}$"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "minConfirm": {
    ///            "description": "min number for balance confirmation.",
    ///            "examples": [
    ///              1
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "name": {
    ///            "examples": [
    ///              "BEP2"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "network": {
    ///            "examples": [
    ///              "ETH"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "resetAddressStatus": {
    ///            "examples": [
    ///              false
    ///            ],
    ///            "type": "boolean"
    ///          },
    ///          "sameAddress": {
    ///            "type": "boolean"
    ///          },
    ///          "specialTips": {
    ///            "examples": [
    ///              "Both a MEMO and an Address are required to successfully deposit your BEP2-BTCB tokens to Binance."
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "unLockConfirm": {
    ///            "description": "confirmation number for balance unlock.",
    ///            "examples": [
    ///              0
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "withdrawDesc": {
    ///            "description": "shown only when \"withdrawEnable\" is false",
    ///            "examples": [
    ///              "Wallet Maintenance, Withdrawal Suspended"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "withdrawEnable": {
    ///            "examples": [
    ///              false
    ///            ],
    ///            "type": "boolean"
    ///          },
    ///          "withdrawFee": {
    ///            "examples": [
    ///              "0.00000220"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "withdrawIntegerMultiple": {
    ///            "examples": [
    ///              "0.00000001"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "withdrawMax": {
    ///            "examples": [
    ///              "9999999999.99999999"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "withdrawMin": {
    ///            "examples": [
    ///              "0.00000440"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "storage": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "trading": {
    ///      "type": "boolean"
    ///    },
    ///    "withdrawAllEnable": {
    ///      "type": "boolean"
    ///    },
    ///    "withdrawing": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct CapitalConfigGetallResponseItem {
        pub coin: String,
        #[serde(rename = "depositAllEnable")]
        pub deposit_all_enable: bool,
        pub free: String,
        pub freeze: String,
        pub ipoable: String,
        pub ipoing: String,
        #[serde(rename = "isLegalMoney")]
        pub is_legal_money: bool,
        pub locked: String,
        pub name: String,
        #[serde(rename = "networkList")]
        pub network_list: Vec<CapitalConfigGetallResponseItemNetworkListItem>,
        pub storage: String,
        pub trading: bool,
        #[serde(rename = "withdrawAllEnable")]
        pub withdraw_all_enable: bool,
        pub withdrawing: String,
    }
    impl From<&CapitalConfigGetallResponseItem> for CapitalConfigGetallResponseItem {
        fn from(value: &CapitalConfigGetallResponseItem) -> Self {
            value.clone()
        }
    }
    ///CapitalConfigGetallResponseItemNetworkListItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "addressRegex",
    ///    "coin",
    ///    "depositDesc",
    ///    "depositEnable",
    ///    "isDefault",
    ///    "memoRegex",
    ///    "minConfirm",
    ///    "name",
    ///    "network",
    ///    "resetAddressStatus",
    ///    "sameAddress",
    ///    "specialTips",
    ///    "unLockConfirm",
    ///    "withdrawDesc",
    ///    "withdrawEnable",
    ///    "withdrawFee",
    ///    "withdrawIntegerMultiple",
    ///    "withdrawMax",
    ///    "withdrawMin"
    ///  ],
    ///  "properties": {
    ///    "addressRegex": {
    ///      "examples": [
    ///        "^(bnb1)[0-9a-z]{38}$"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "coin": {
    ///      "examples": [
    ///        "BTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "depositDesc": {
    ///      "description": "shown only when \"depositEnable\" is false.",
    ///      "examples": [
    ///        "Wallet Maintenance, Deposit Suspended"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "depositEnable": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "isDefault": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "memoRegex": {
    ///      "examples": [
    ///        "^[0-9A-Za-z\\-_]{1,120}$"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "minConfirm": {
    ///      "description": "min number for balance confirmation.",
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "name": {
    ///      "examples": [
    ///        "BEP2"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "network": {
    ///      "examples": [
    ///        "ETH"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "resetAddressStatus": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "sameAddress": {
    ///      "type": "boolean"
    ///    },
    ///    "specialTips": {
    ///      "examples": [
    ///        "Both a MEMO and an Address are required to successfully deposit your BEP2-BTCB tokens to Binance."
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "unLockConfirm": {
    ///      "description": "confirmation number for balance unlock.",
    ///      "examples": [
    ///        0
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "withdrawDesc": {
    ///      "description": "shown only when \"withdrawEnable\" is false",
    ///      "examples": [
    ///        "Wallet Maintenance, Withdrawal Suspended"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "withdrawEnable": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "withdrawFee": {
    ///      "examples": [
    ///        "0.00000220"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "withdrawIntegerMultiple": {
    ///      "examples": [
    ///        "0.00000001"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "withdrawMax": {
    ///      "examples": [
    ///        "9999999999.99999999"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "withdrawMin": {
    ///      "examples": [
    ///        "0.00000440"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct CapitalConfigGetallResponseItemNetworkListItem {
        #[serde(rename = "addressRegex")]
        pub address_regex: String,
        pub coin: String,
        ///shown only when "depositEnable" is false.
        #[serde(rename = "depositDesc")]
        pub deposit_desc: String,
        #[serde(rename = "depositEnable")]
        pub deposit_enable: bool,
        #[serde(rename = "isDefault")]
        pub is_default: bool,
        #[serde(rename = "memoRegex")]
        pub memo_regex: String,
        ///min number for balance confirmation.
        #[serde(rename = "minConfirm")]
        pub min_confirm: i64,
        pub name: String,
        pub network: String,
        #[serde(rename = "resetAddressStatus")]
        pub reset_address_status: bool,
        #[serde(rename = "sameAddress")]
        pub same_address: bool,
        #[serde(rename = "specialTips")]
        pub special_tips: String,
        ///confirmation number for balance unlock.
        #[serde(rename = "unLockConfirm")]
        pub un_lock_confirm: i64,
        ///shown only when "withdrawEnable" is false
        #[serde(rename = "withdrawDesc")]
        pub withdraw_desc: String,
        #[serde(rename = "withdrawEnable")]
        pub withdraw_enable: bool,
        #[serde(rename = "withdrawFee")]
        pub withdraw_fee: String,
        #[serde(rename = "withdrawIntegerMultiple")]
        pub withdraw_integer_multiple: String,
        #[serde(rename = "withdrawMax")]
        pub withdraw_max: String,
        #[serde(rename = "withdrawMin")]
        pub withdraw_min: String,
    }
    impl From<&CapitalConfigGetallResponseItemNetworkListItem>
    for CapitalConfigGetallResponseItemNetworkListItem {
        fn from(value: &CapitalConfigGetallResponseItemNetworkListItem) -> Self {
            value.clone()
        }
    }
    ///CapitalContractConvertibleCoinsResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "coins",
    ///    "convertEnabled",
    ///    "exchangeRates"
    ///  ],
    ///  "properties": {
    ///    "coins": {
    ///      "type": "array",
    ///      "items": {
    ///        "examples": [
    ///          "USDC"
    ///        ],
    ///        "type": "string"
    ///      }
    ///    },
    ///    "convertEnabled": {
    ///      "type": "boolean"
    ///    },
    ///    "exchangeRates": {
    ///      "type": "object",
    ///      "required": [
    ///        "TUSD",
    ///        "USDC",
    ///        "USDP"
    ///      ],
    ///      "properties": {
    ///        "TUSD": {
    ///          "examples": [
    ///            "1"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "USDC": {
    ///          "examples": [
    ///            "1"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "USDP": {
    ///          "examples": [
    ///            "1"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct CapitalContractConvertibleCoinsResponse {
        pub coins: Vec<String>,
        #[serde(rename = "convertEnabled")]
        pub convert_enabled: bool,
        #[serde(rename = "exchangeRates")]
        pub exchange_rates: CapitalContractConvertibleCoinsResponseExchangeRates,
    }
    impl From<&CapitalContractConvertibleCoinsResponse>
    for CapitalContractConvertibleCoinsResponse {
        fn from(value: &CapitalContractConvertibleCoinsResponse) -> Self {
            value.clone()
        }
    }
    ///CapitalContractConvertibleCoinsResponseExchangeRates
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "TUSD",
    ///    "USDC",
    ///    "USDP"
    ///  ],
    ///  "properties": {
    ///    "TUSD": {
    ///      "examples": [
    ///        "1"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "USDC": {
    ///      "examples": [
    ///        "1"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "USDP": {
    ///      "examples": [
    ///        "1"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct CapitalContractConvertibleCoinsResponseExchangeRates {
        #[serde(rename = "TUSD")]
        pub tusd: String,
        #[serde(rename = "USDC")]
        pub usdc: String,
        #[serde(rename = "USDP")]
        pub usdp: String,
    }
    impl From<&CapitalContractConvertibleCoinsResponseExchangeRates>
    for CapitalContractConvertibleCoinsResponseExchangeRates {
        fn from(value: &CapitalContractConvertibleCoinsResponseExchangeRates) -> Self {
            value.clone()
        }
    }
    ///CapitalDepositAddressListResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "address",
    ///    "coin",
    ///    "isDefault"
    ///  ],
    ///  "properties": {
    ///    "address": {
    ///      "examples": [
    ///        "0xD316E95Fd9E8E237Cb11f8200Babbc5D8D177BA4"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "coin": {
    ///      "examples": [
    ///        "ETH"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "isDefault": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct CapitalDepositAddressListResponseItem {
        pub address: String,
        pub coin: String,
        #[serde(rename = "isDefault")]
        pub is_default: i32,
    }
    impl From<&CapitalDepositAddressListResponseItem>
    for CapitalDepositAddressListResponseItem {
        fn from(value: &CapitalDepositAddressListResponseItem) -> Self {
            value.clone()
        }
    }
    ///CapitalDepositAddressResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "address",
    ///    "coin",
    ///    "tag",
    ///    "url"
    ///  ],
    ///  "properties": {
    ///    "address": {
    ///      "examples": [
    ///        "1HPn8Rx2y6nNSfagQBKy27GB99Vbzg89wv"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "coin": {
    ///      "examples": [
    ///        "BTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "tag": {
    ///      "examples": [
    ///        ""
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "url": {
    ///      "examples": [
    ///        "https://btc.com/1HPn8Rx2y6nNSfagQBKy27GB99Vbzg89wv"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct CapitalDepositAddressResponse {
        pub address: String,
        pub coin: String,
        pub tag: String,
        pub url: String,
    }
    impl From<&CapitalDepositAddressResponse> for CapitalDepositAddressResponse {
        fn from(value: &CapitalDepositAddressResponse) -> Self {
            value.clone()
        }
    }
    ///CapitalDepositCreditApplyResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "code",
    ///    "data",
    ///    "message",
    ///    "success"
    ///  ],
    ///  "properties": {
    ///    "code": {
    ///      "examples": [
    ///        "000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "data": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "message": {
    ///      "examples": [
    ///        "success"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "success": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct CapitalDepositCreditApplyResponse {
        pub code: String,
        pub data: bool,
        pub message: String,
        pub success: bool,
    }
    impl From<&CapitalDepositCreditApplyResponse> for CapitalDepositCreditApplyResponse {
        fn from(value: &CapitalDepositCreditApplyResponse) -> Self {
            value.clone()
        }
    }
    ///CapitalDepositHisrecResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "address",
    ///    "addressTag",
    ///    "amount",
    ///    "coin",
    ///    "confirmTimes",
    ///    "insertTime",
    ///    "network",
    ///    "status",
    ///    "transferType",
    ///    "txId",
    ///    "unlockConfirm"
    ///  ],
    ///  "properties": {
    ///    "address": {
    ///      "examples": [
    ///        "0x788cabe9236ce061e5a892e1a59395a81fc8d62c"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "addressTag": {
    ///      "examples": [
    ///        ""
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "amount": {
    ///      "examples": [
    ///        "0.00999800"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "coin": {
    ///      "examples": [
    ///        "PAXG"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "confirmTimes": {
    ///      "examples": [
    ///        "12/12"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "insertTime": {
    ///      "examples": [
    ///        1599621997000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "network": {
    ///      "examples": [
    ///        "ETH"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    },
    ///    "transferType": {
    ///      "examples": [
    ///        0
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    },
    ///    "txId": {
    ///      "examples": [
    ///        "0xaad4654a3234aa6118af9b4b335f5ae81c360b2394721c019b5d1e75328b09f3"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "unlockConfirm": {
    ///      "description": "confirm times for unlocking",
    ///      "examples": [
    ///        "12/12"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct CapitalDepositHisrecResponseItem {
        pub address: String,
        #[serde(rename = "addressTag")]
        pub address_tag: String,
        pub amount: String,
        pub coin: String,
        #[serde(rename = "confirmTimes")]
        pub confirm_times: String,
        #[serde(rename = "insertTime")]
        pub insert_time: i64,
        pub network: String,
        pub status: i32,
        #[serde(rename = "transferType")]
        pub transfer_type: i32,
        #[serde(rename = "txId")]
        pub tx_id: String,
        ///confirm times for unlocking
        #[serde(rename = "unlockConfirm")]
        pub unlock_confirm: String,
    }
    impl From<&CapitalDepositHisrecResponseItem> for CapitalDepositHisrecResponseItem {
        fn from(value: &CapitalDepositHisrecResponseItem) -> Self {
            value.clone()
        }
    }
    ///CapitalDepositSubAddressResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "address",
    ///    "coin",
    ///    "tag",
    ///    "url"
    ///  ],
    ///  "properties": {
    ///    "address": {
    ///      "examples": [
    ///        "TDunhSa7jkTNuKrusUTU1MUHtqXoBPKETV"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "coin": {
    ///      "examples": [
    ///        "USDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "tag": {
    ///      "examples": [
    ///        ""
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "url": {
    ///      "examples": [
    ///        "https://tronscan.org/#/address/TDunhSa7jkTNuKrusUTU1MUHtqXoBPKETV"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct CapitalDepositSubAddressResponse {
        pub address: String,
        pub coin: String,
        pub tag: String,
        pub url: String,
    }
    impl From<&CapitalDepositSubAddressResponse> for CapitalDepositSubAddressResponse {
        fn from(value: &CapitalDepositSubAddressResponse) -> Self {
            value.clone()
        }
    }
    ///CapitalDepositSubHisrecResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "address",
    ///    "addressTag",
    ///    "amount",
    ///    "coin",
    ///    "confirmTimes",
    ///    "insertTime",
    ///    "network",
    ///    "status",
    ///    "transferType",
    ///    "txId"
    ///  ],
    ///  "properties": {
    ///    "address": {
    ///      "examples": [
    ///        "0x788cabe9236ce061e5a892e1a59395a81fc8d62c"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "addressTag": {
    ///      "examples": [
    ///        ""
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "amount": {
    ///      "examples": [
    ///        "0.00999800"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "coin": {
    ///      "examples": [
    ///        "PAXG"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "confirmTimes": {
    ///      "examples": [
    ///        "12/12"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "insertTime": {
    ///      "examples": [
    ///        1599621997000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "network": {
    ///      "examples": [
    ///        "ETH"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    },
    ///    "transferType": {
    ///      "examples": [
    ///        0
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    },
    ///    "txId": {
    ///      "examples": [
    ///        "0xaad4654a3234aa6118af9b4b335f5ae81c360b2394721c019b5d1e75328b09f3"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct CapitalDepositSubHisrecResponseItem {
        pub address: String,
        #[serde(rename = "addressTag")]
        pub address_tag: String,
        pub amount: String,
        pub coin: String,
        #[serde(rename = "confirmTimes")]
        pub confirm_times: String,
        #[serde(rename = "insertTime")]
        pub insert_time: i64,
        pub network: String,
        pub status: i32,
        #[serde(rename = "transferType")]
        pub transfer_type: i32,
        #[serde(rename = "txId")]
        pub tx_id: String,
    }
    impl From<&CapitalDepositSubHisrecResponseItem>
    for CapitalDepositSubHisrecResponseItem {
        fn from(value: &CapitalDepositSubHisrecResponseItem) -> Self {
            value.clone()
        }
    }
    ///CapitalWithdrawApplyResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id"
    ///  ],
    ///  "properties": {
    ///    "id": {
    ///      "examples": [
    ///        "7213fea8e94b4a5593d507237e5a555b"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct CapitalWithdrawApplyResponse {
        pub id: String,
    }
    impl From<&CapitalWithdrawApplyResponse> for CapitalWithdrawApplyResponse {
        fn from(value: &CapitalWithdrawApplyResponse) -> Self {
            value.clone()
        }
    }
    ///CapitalWithdrawHistoryResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "address",
    ///    "amount",
    ///    "applyTime",
    ///    "coin",
    ///    "id",
    ///    "network",
    ///    "status",
    ///    "transactionFee",
    ///    "transferType",
    ///    "txId",
    ///    "withdrawOrderId"
    ///  ],
    ///  "properties": {
    ///    "address": {
    ///      "examples": [
    ///        "0x94df8b352de7f46f64b01d3666bf6e936e44ce60"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "amount": {
    ///      "examples": [
    ///        "8.91000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "applyTime": {
    ///      "examples": [
    ///        "2019-10-12 11:12:02"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "coin": {
    ///      "examples": [
    ///        "USDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "confirmNo": {
    ///      "examples": [
    ///        3
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    },
    ///    "id": {
    ///      "examples": [
    ///        "b6ae22b3aa844210a7041aee7589627c"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "info": {
    ///      "description": "Reason for withdrawal failure",
    ///      "examples": [
    ///        "The address is not valid. Please confirm with the recipient"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "network": {
    ///      "examples": [
    ///        "ETH"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "examples": [
    ///        6
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    },
    ///    "transactionFee": {
    ///      "examples": [
    ///        "0.004"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "transferType": {
    ///      "description": "1 for internal transfer, 0 for external transfer",
    ///      "examples": [
    ///        0
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    },
    ///    "txId": {
    ///      "examples": [
    ///        "0xb5ef8c13b968a406cc62a93a8bd80f9e9a906ef1b3fcf20a2e48573c17659268"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "withdrawOrderId": {
    ///      "description": "will not be returned if there's no withdrawOrderId for this withdraw.",
    ///      "examples": [
    ///        "WITHDRAWtest123"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct CapitalWithdrawHistoryResponseItem {
        pub address: String,
        pub amount: String,
        #[serde(rename = "applyTime")]
        pub apply_time: String,
        pub coin: String,
        #[serde(rename = "confirmNo", default, skip_serializing_if = "Option::is_none")]
        pub confirm_no: Option<i32>,
        pub id: String,
        ///Reason for withdrawal failure
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub info: Option<String>,
        pub network: String,
        pub status: i32,
        #[serde(rename = "transactionFee")]
        pub transaction_fee: String,
        ///1 for internal transfer, 0 for external transfer
        #[serde(rename = "transferType")]
        pub transfer_type: i32,
        #[serde(rename = "txId")]
        pub tx_id: String,
        ///will not be returned if there's no withdrawOrderId for this withdraw.
        #[serde(rename = "withdrawOrderId")]
        pub withdraw_order_id: String,
    }
    impl From<&CapitalWithdrawHistoryResponseItem>
    for CapitalWithdrawHistoryResponseItem {
        fn from(value: &CapitalWithdrawHistoryResponseItem) -> Self {
            value.clone()
        }
    }
    ///ConvertAcceptQuoteResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "createTime",
    ///    "orderId",
    ///    "orderStatus"
    ///  ],
    ///  "properties": {
    ///    "createTime": {
    ///      "examples": [
    ///        1623381330472
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "orderId": {
    ///      "examples": [
    ///        "933256278426274426"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "orderStatus": {
    ///      "examples": [
    ///        "PROCESS"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct ConvertAcceptQuoteResponse {
        #[serde(rename = "createTime")]
        pub create_time: i64,
        #[serde(rename = "orderId")]
        pub order_id: String,
        #[serde(rename = "orderStatus")]
        pub order_status: String,
    }
    impl From<&ConvertAcceptQuoteResponse> for ConvertAcceptQuoteResponse {
        fn from(value: &ConvertAcceptQuoteResponse) -> Self {
            value.clone()
        }
    }
    ///ConvertAssetInfoResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "asset",
    ///    "fraction"
    ///  ],
    ///  "properties": {
    ///    "asset": {
    ///      "examples": [
    ///        "BTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "fraction": {
    ///      "examples": [
    ///        8
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct ConvertAssetInfoResponseItem {
        pub asset: String,
        pub fraction: i32,
    }
    impl From<&ConvertAssetInfoResponseItem> for ConvertAssetInfoResponseItem {
        fn from(value: &ConvertAssetInfoResponseItem) -> Self {
            value.clone()
        }
    }
    ///ConvertDustAssetsToBnbResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "totalServiceCharge",
    ///    "totalTransfered",
    ///    "transferResult"
    ///  ],
    ///  "properties": {
    ///    "totalServiceCharge": {
    ///      "examples": [
    ///        "0.02102542"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalTransfered": {
    ///      "examples": [
    ///        "1.05127099"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "transferResult": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "amount",
    ///          "fromAsset",
    ///          "operateTime",
    ///          "serviceChargeAmount",
    ///          "tranId",
    ///          "transferedAmount"
    ///        ],
    ///        "properties": {
    ///          "amount": {
    ///            "examples": [
    ///              "0.03000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "fromAsset": {
    ///            "examples": [
    ///              "ETH"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "operateTime": {
    ///            "examples": [
    ///              1563368549307
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "serviceChargeAmount": {
    ///            "examples": [
    ///              "0.00500000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "tranId": {
    ///            "examples": [
    ///              1563368549307
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "transferedAmount": {
    ///            "examples": [
    ///              "0.25000000"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct ConvertDustAssetsToBnbResponse {
        #[serde(rename = "totalServiceCharge")]
        pub total_service_charge: String,
        #[serde(rename = "totalTransfered")]
        pub total_transfered: String,
        #[serde(rename = "transferResult")]
        pub transfer_result: Vec<ConvertDustAssetsToBnbResponseTransferResultItem>,
    }
    impl From<&ConvertDustAssetsToBnbResponse> for ConvertDustAssetsToBnbResponse {
        fn from(value: &ConvertDustAssetsToBnbResponse) -> Self {
            value.clone()
        }
    }
    ///ConvertDustAssetsToBnbResponseTransferResultItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "fromAsset",
    ///    "operateTime",
    ///    "serviceChargeAmount",
    ///    "tranId",
    ///    "transferedAmount"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "examples": [
    ///        "0.03000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "fromAsset": {
    ///      "examples": [
    ///        "ETH"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "operateTime": {
    ///      "examples": [
    ///        1563368549307
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "serviceChargeAmount": {
    ///      "examples": [
    ///        "0.00500000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "tranId": {
    ///      "examples": [
    ///        1563368549307
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "transferedAmount": {
    ///      "examples": [
    ///        "0.25000000"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct ConvertDustAssetsToBnbResponseTransferResultItem {
        pub amount: String,
        #[serde(rename = "fromAsset")]
        pub from_asset: String,
        #[serde(rename = "operateTime")]
        pub operate_time: i64,
        #[serde(rename = "serviceChargeAmount")]
        pub service_charge_amount: String,
        #[serde(rename = "tranId")]
        pub tran_id: i64,
        #[serde(rename = "transferedAmount")]
        pub transfered_amount: String,
    }
    impl From<&ConvertDustAssetsToBnbResponseTransferResultItem>
    for ConvertDustAssetsToBnbResponseTransferResultItem {
        fn from(value: &ConvertDustAssetsToBnbResponseTransferResultItem) -> Self {
            value.clone()
        }
    }
    ///ConvertExchangeInfoResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "fromAsset",
    ///    "fromAssetMaxAmount",
    ///    "fromAssetMinAmount",
    ///    "toAsset",
    ///    "toAssetMaxAmount",
    ///    "toAssetMinAmount"
    ///  ],
    ///  "properties": {
    ///    "fromAsset": {
    ///      "examples": [
    ///        "BTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "fromAssetMaxAmount": {
    ///      "examples": [
    ///        "50"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "fromAssetMinAmount": {
    ///      "examples": [
    ///        "0.0004"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "toAsset": {
    ///      "examples": [
    ///        "USDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "toAssetMaxAmount": {
    ///      "examples": [
    ///        "2500000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "toAssetMinAmount": {
    ///      "examples": [
    ///        "20"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct ConvertExchangeInfoResponseItem {
        #[serde(rename = "fromAsset")]
        pub from_asset: String,
        #[serde(rename = "fromAssetMaxAmount")]
        pub from_asset_max_amount: String,
        #[serde(rename = "fromAssetMinAmount")]
        pub from_asset_min_amount: String,
        #[serde(rename = "toAsset")]
        pub to_asset: String,
        #[serde(rename = "toAssetMaxAmount")]
        pub to_asset_max_amount: String,
        #[serde(rename = "toAssetMinAmount")]
        pub to_asset_min_amount: String,
    }
    impl From<&ConvertExchangeInfoResponseItem> for ConvertExchangeInfoResponseItem {
        fn from(value: &ConvertExchangeInfoResponseItem) -> Self {
            value.clone()
        }
    }
    ///ConvertGetQuoteResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "fromAmount",
    ///    "inverseRatio",
    ///    "quoteId",
    ///    "ratio",
    ///    "toAmount",
    ///    "validTimestamp"
    ///  ],
    ///  "properties": {
    ///    "fromAmount": {
    ///      "examples": [
    ///        "0.1"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "inverseRatio": {
    ///      "examples": [
    ///        "0.0000262"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "quoteId": {
    ///      "examples": [
    ///        "12415572564"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "ratio": {
    ///      "examples": [
    ///        "38163.7"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "toAmount": {
    ///      "examples": [
    ///        "3816.37"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "validTimestamp": {
    ///      "examples": [
    ///        1623319461670
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct ConvertGetQuoteResponse {
        #[serde(rename = "fromAmount")]
        pub from_amount: String,
        #[serde(rename = "inverseRatio")]
        pub inverse_ratio: String,
        #[serde(rename = "quoteId")]
        pub quote_id: String,
        pub ratio: String,
        #[serde(rename = "toAmount")]
        pub to_amount: String,
        #[serde(rename = "validTimestamp")]
        pub valid_timestamp: i64,
    }
    impl From<&ConvertGetQuoteResponse> for ConvertGetQuoteResponse {
        fn from(value: &ConvertGetQuoteResponse) -> Self {
            value.clone()
        }
    }
    ///ConvertOrderStatusResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "createTime",
    ///    "fromAmount",
    ///    "fromAsset",
    ///    "inverseRatio",
    ///    "orderId",
    ///    "orderStatus",
    ///    "ratio",
    ///    "toAmount",
    ///    "toAsset"
    ///  ],
    ///  "properties": {
    ///    "createTime": {
    ///      "examples": [
    ///        1623381330472
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "fromAmount": {
    ///      "examples": [
    ///        "0.00054414"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "fromAsset": {
    ///      "examples": [
    ///        "BTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "inverseRatio": {
    ///      "examples": [
    ///        "0.00002721"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "orderId": {
    ///      "examples": [
    ///        933256278426274426
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "orderStatus": {
    ///      "examples": [
    ///        "SUCCESS"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "ratio": {
    ///      "examples": [
    ///        "36755"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "toAmount": {
    ///      "examples": [
    ///        "20"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "toAsset": {
    ///      "examples": [
    ///        "USDT"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct ConvertOrderStatusResponse {
        #[serde(rename = "createTime")]
        pub create_time: i64,
        #[serde(rename = "fromAmount")]
        pub from_amount: String,
        #[serde(rename = "fromAsset")]
        pub from_asset: String,
        #[serde(rename = "inverseRatio")]
        pub inverse_ratio: String,
        #[serde(rename = "orderId")]
        pub order_id: i64,
        #[serde(rename = "orderStatus")]
        pub order_status: String,
        pub ratio: String,
        #[serde(rename = "toAmount")]
        pub to_amount: String,
        #[serde(rename = "toAsset")]
        pub to_asset: String,
    }
    impl From<&ConvertOrderStatusResponse> for ConvertOrderStatusResponse {
        fn from(value: &ConvertOrderStatusResponse) -> Self {
            value.clone()
        }
    }
    ///ConvertTradeFlowResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "endTime",
    ///    "limit",
    ///    "list",
    ///    "moreData",
    ///    "startTime"
    ///  ],
    ///  "properties": {
    ///    "endTime": {
    ///      "examples": [
    ///        1626416139000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "limit": {
    ///      "examples": [
    ///        100
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    },
    ///    "list": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "createTime",
    ///          "fromAmount",
    ///          "fromAsset",
    ///          "inverseRatio",
    ///          "orderId",
    ///          "orderStatus",
    ///          "quoteId",
    ///          "ratio",
    ///          "toAmount",
    ///          "toAsset"
    ///        ],
    ///        "properties": {
    ///          "createTime": {
    ///            "examples": [
    ///              1624248872184
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "fromAmount": {
    ///            "examples": [
    ///              "20"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "fromAsset": {
    ///            "examples": [
    ///              "USDT"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "inverseRatio": {
    ///            "description": "inverse price",
    ///            "examples": [
    ///              "324.99"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "orderId": {
    ///            "examples": [
    ///              940708407462087200
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "orderStatus": {
    ///            "examples": [
    ///              "SUCCESS"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "quoteId": {
    ///            "examples": [
    ///              "f3b91c525b2644c7bc1e1cd31b6e1aa6"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "ratio": {
    ///            "description": "price ratio",
    ///            "examples": [
    ///              "0.00307702"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "toAmount": {
    ///            "examples": [
    ///              "0.06154036"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "toAsset": {
    ///            "examples": [
    ///              "BNB"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "moreData": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "startTime": {
    ///      "examples": [
    ///        1623824139000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct ConvertTradeFlowResponse {
        #[serde(rename = "endTime")]
        pub end_time: i64,
        pub limit: i32,
        pub list: Vec<ConvertTradeFlowResponseListItem>,
        #[serde(rename = "moreData")]
        pub more_data: bool,
        #[serde(rename = "startTime")]
        pub start_time: i64,
    }
    impl From<&ConvertTradeFlowResponse> for ConvertTradeFlowResponse {
        fn from(value: &ConvertTradeFlowResponse) -> Self {
            value.clone()
        }
    }
    ///ConvertTradeFlowResponseListItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "createTime",
    ///    "fromAmount",
    ///    "fromAsset",
    ///    "inverseRatio",
    ///    "orderId",
    ///    "orderStatus",
    ///    "quoteId",
    ///    "ratio",
    ///    "toAmount",
    ///    "toAsset"
    ///  ],
    ///  "properties": {
    ///    "createTime": {
    ///      "examples": [
    ///        1624248872184
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "fromAmount": {
    ///      "examples": [
    ///        "20"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "fromAsset": {
    ///      "examples": [
    ///        "USDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "inverseRatio": {
    ///      "description": "inverse price",
    ///      "examples": [
    ///        "324.99"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "orderId": {
    ///      "examples": [
    ///        940708407462087200
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "orderStatus": {
    ///      "examples": [
    ///        "SUCCESS"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "quoteId": {
    ///      "examples": [
    ///        "f3b91c525b2644c7bc1e1cd31b6e1aa6"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "ratio": {
    ///      "description": "price ratio",
    ///      "examples": [
    ///        "0.00307702"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "toAmount": {
    ///      "examples": [
    ///        "0.06154036"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "toAsset": {
    ///      "examples": [
    ///        "BNB"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct ConvertTradeFlowResponseListItem {
        #[serde(rename = "createTime")]
        pub create_time: i64,
        #[serde(rename = "fromAmount")]
        pub from_amount: String,
        #[serde(rename = "fromAsset")]
        pub from_asset: String,
        ///inverse price
        #[serde(rename = "inverseRatio")]
        pub inverse_ratio: String,
        #[serde(rename = "orderId")]
        pub order_id: i64,
        #[serde(rename = "orderStatus")]
        pub order_status: String,
        #[serde(rename = "quoteId")]
        pub quote_id: String,
        ///price ratio
        pub ratio: String,
        #[serde(rename = "toAmount")]
        pub to_amount: String,
        #[serde(rename = "toAsset")]
        pub to_asset: String,
    }
    impl From<&ConvertTradeFlowResponseListItem> for ConvertTradeFlowResponseListItem {
        fn from(value: &ConvertTradeFlowResponseListItem) -> Self {
            value.clone()
        }
    }
    ///CreateListenKeyUserDataStreamResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "listenKey"
    ///  ],
    ///  "properties": {
    ///    "listenKey": {
    ///      "examples": [
    ///        "pqia91ma19a5s61cv6a81va65sdf19v8a65a1a5s61cv6a81va65sdf19v8a65a1"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct CreateListenKeyUserDataStreamResponse {
        #[serde(rename = "listenKey")]
        pub listen_key: String,
    }
    impl From<&CreateListenKeyUserDataStreamResponse>
    for CreateListenKeyUserDataStreamResponse {
        fn from(value: &CreateListenKeyUserDataStreamResponse) -> Self {
            value.clone()
        }
    }
    ///CreateUserDataStreamResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "listenKey"
    ///  ],
    ///  "properties": {
    ///    "listenKey": {
    ///      "examples": [
    ///        "pqia91ma19a5s61cv6a81va65sdf19v8a65a1a5s61cv6a81va65sdf19v8a65a1"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct CreateUserDataStreamResponse {
        #[serde(rename = "listenKey")]
        pub listen_key: String,
    }
    impl From<&CreateUserDataStreamResponse> for CreateUserDataStreamResponse {
        fn from(value: &CreateUserDataStreamResponse) -> Self {
            value.clone()
        }
    }
    ///DepthResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "asks",
    ///    "bids",
    ///    "lastUpdateId"
    ///  ],
    ///  "properties": {
    ///    "asks": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "array",
    ///        "items": {
    ///          "type": "string",
    ///          "maxItems": 2,
    ///          "minItems": 2
    ///        }
    ///      }
    ///    },
    ///    "bids": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "array",
    ///        "items": {
    ///          "type": "string",
    ///          "maxItems": 2,
    ///          "minItems": 2
    ///        }
    ///      }
    ///    },
    ///    "lastUpdateId": {
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct DepthResponse {
        pub asks: Vec<Vec<String>>,
        pub bids: Vec<Vec<String>>,
        #[serde(rename = "lastUpdateId")]
        pub last_update_id: i64,
    }
    impl From<&DepthResponse> for DepthResponse {
        fn from(value: &DepthResponse) -> Self {
            value.clone()
        }
    }
    ///DisableIsolatedMarginAccountResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "success",
    ///    "symbol"
    ///  ],
    ///  "properties": {
    ///    "success": {
    ///      "type": "boolean"
    ///    },
    ///    "symbol": {
    ///      "examples": [
    ///        "BTCUSDT"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct DisableIsolatedMarginAccountResponse {
        pub success: bool,
        pub symbol: String,
    }
    impl From<&DisableIsolatedMarginAccountResponse>
    for DisableIsolatedMarginAccountResponse {
        fn from(value: &DisableIsolatedMarginAccountResponse) -> Self {
            value.clone()
        }
    }
    ///Error
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "code",
    ///    "msg"
    ///  ],
    ///  "properties": {
    ///    "code": {
    ///      "description": "Error code",
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "msg": {
    ///      "description": "Error message",
    ///      "examples": [
    ///        "error message"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct Error {
        ///Error code
        pub code: i64,
        ///Error message
        pub msg: String,
    }
    impl From<&Error> for Error {
        fn from(value: &Error) -> Self {
            value.clone()
        }
    }
    ///ExchangeInfoResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "exchangeFilters",
    ///    "rateLimits",
    ///    "serverTime",
    ///    "symbols",
    ///    "timezone"
    ///  ],
    ///  "properties": {
    ///    "exchangeFilters": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object"
    ///      }
    ///    },
    ///    "rateLimits": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "interval",
    ///          "intervalNum",
    ///          "limit",
    ///          "rateLimitType"
    ///        ],
    ///        "properties": {
    ///          "interval": {
    ///            "examples": [
    ///              "MINUTE"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "intervalNum": {
    ///            "examples": [
    ///              1
    ///            ],
    ///            "type": "integer",
    ///            "format": "int32"
    ///          },
    ///          "limit": {
    ///            "examples": [
    ///              1200
    ///            ],
    ///            "type": "integer",
    ///            "format": "int32"
    ///          },
    ///          "rateLimitType": {
    ///            "examples": [
    ///              "REQUEST_WEIGHT"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "serverTime": {
    ///      "examples": [
    ///        1592882214236
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "symbols": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "allowTrailingStop",
    ///          "allowedSelfTradePreventionModes",
    ///          "baseAsset",
    ///          "baseAssetPrecision",
    ///          "baseCommissionPrecision",
    ///          "defaultSelfTradePreventionMode",
    ///          "filters",
    ///          "icebergAllowed",
    ///          "isMarginTradingAllowed",
    ///          "isSpotTradingAllowed",
    ///          "ocoAllowed",
    ///          "orderTypes",
    ///          "permissions",
    ///          "quoteAsset",
    ///          "quoteAssetPrecision",
    ///          "quoteCommissionPrecision",
    ///          "quoteOrderQtyMarketAllowed",
    ///          "status",
    ///          "symbol"
    ///        ],
    ///        "properties": {
    ///          "allowTrailingStop": {
    ///            "examples": [
    ///              false
    ///            ],
    ///            "type": "boolean"
    ///          },
    ///          "allowedSelfTradePreventionModes": {
    ///            "type": "array",
    ///            "items": {
    ///              "examples": [
    ///                "NONE"
    ///              ],
    ///              "type": "string"
    ///            }
    ///          },
    ///          "baseAsset": {
    ///            "examples": [
    ///              "ETH"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "baseAssetPrecision": {
    ///            "examples": [
    ///              8
    ///            ],
    ///            "type": "integer",
    ///            "format": "int32"
    ///          },
    ///          "baseCommissionPrecision": {
    ///            "examples": [
    ///              8
    ///            ],
    ///            "type": "integer",
    ///            "format": "int32"
    ///          },
    ///          "defaultSelfTradePreventionMode": {
    ///            "examples": [
    ///              "NONE"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "filters": {
    ///            "type": "array",
    ///            "items": {
    ///              "type": "object",
    ///              "required": [
    ///                "filterType",
    ///                "maxPrice",
    ///                "minPrice",
    ///                "tickSize"
    ///              ],
    ///              "properties": {
    ///                "filterType": {
    ///                  "examples": [
    ///                    "PRICE_FILTER"
    ///                  ],
    ///                  "type": "string"
    ///                },
    ///                "maxPrice": {
    ///                  "examples": [
    ///                    "100000.00000000"
    ///                  ],
    ///                  "type": "string"
    ///                },
    ///                "minPrice": {
    ///                  "examples": [
    ///                    "0.00000100"
    ///                  ],
    ///                  "type": "string"
    ///                },
    ///                "tickSize": {
    ///                  "examples": [
    ///                    "0.00000100"
    ///                  ],
    ///                  "type": "string"
    ///                }
    ///              }
    ///            }
    ///          },
    ///          "icebergAllowed": {
    ///            "type": "boolean"
    ///          },
    ///          "isMarginTradingAllowed": {
    ///            "type": "boolean"
    ///          },
    ///          "isSpotTradingAllowed": {
    ///            "type": "boolean"
    ///          },
    ///          "ocoAllowed": {
    ///            "type": "boolean"
    ///          },
    ///          "orderTypes": {
    ///            "type": "array",
    ///            "items": {
    ///              "examples": [
    ///                "LIMIT"
    ///              ],
    ///              "type": "string"
    ///            }
    ///          },
    ///          "permissions": {
    ///            "type": "array",
    ///            "items": {
    ///              "examples": [
    ///                "SPOT"
    ///              ],
    ///              "type": "string"
    ///            }
    ///          },
    ///          "quoteAsset": {
    ///            "examples": [
    ///              "BTC"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "quoteAssetPrecision": {
    ///            "examples": [
    ///              8
    ///            ],
    ///            "type": "integer",
    ///            "format": "int32"
    ///          },
    ///          "quoteCommissionPrecision": {
    ///            "examples": [
    ///              8
    ///            ],
    ///            "type": "integer",
    ///            "format": "int32"
    ///          },
    ///          "quoteOrderQtyMarketAllowed": {
    ///            "type": "boolean"
    ///          },
    ///          "status": {
    ///            "examples": [
    ///              "TRADING"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "symbol": {
    ///            "examples": [
    ///              "ETHBTC"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "timezone": {
    ///      "examples": [
    ///        "UTC"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct ExchangeInfoResponse {
        #[serde(rename = "exchangeFilters")]
        pub exchange_filters: Vec<serde_json::Map<String, serde_json::Value>>,
        #[serde(rename = "rateLimits")]
        pub rate_limits: Vec<ExchangeInfoResponseRateLimitsItem>,
        #[serde(rename = "serverTime")]
        pub server_time: i64,
        pub symbols: Vec<ExchangeInfoResponseSymbolsItem>,
        pub timezone: String,
    }
    impl From<&ExchangeInfoResponse> for ExchangeInfoResponse {
        fn from(value: &ExchangeInfoResponse) -> Self {
            value.clone()
        }
    }
    ///ExchangeInfoResponseRateLimitsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "interval",
    ///    "intervalNum",
    ///    "limit",
    ///    "rateLimitType"
    ///  ],
    ///  "properties": {
    ///    "interval": {
    ///      "examples": [
    ///        "MINUTE"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "intervalNum": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    },
    ///    "limit": {
    ///      "examples": [
    ///        1200
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    },
    ///    "rateLimitType": {
    ///      "examples": [
    ///        "REQUEST_WEIGHT"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct ExchangeInfoResponseRateLimitsItem {
        pub interval: String,
        #[serde(rename = "intervalNum")]
        pub interval_num: i32,
        pub limit: i32,
        #[serde(rename = "rateLimitType")]
        pub rate_limit_type: String,
    }
    impl From<&ExchangeInfoResponseRateLimitsItem>
    for ExchangeInfoResponseRateLimitsItem {
        fn from(value: &ExchangeInfoResponseRateLimitsItem) -> Self {
            value.clone()
        }
    }
    ///ExchangeInfoResponseSymbolsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "allowTrailingStop",
    ///    "allowedSelfTradePreventionModes",
    ///    "baseAsset",
    ///    "baseAssetPrecision",
    ///    "baseCommissionPrecision",
    ///    "defaultSelfTradePreventionMode",
    ///    "filters",
    ///    "icebergAllowed",
    ///    "isMarginTradingAllowed",
    ///    "isSpotTradingAllowed",
    ///    "ocoAllowed",
    ///    "orderTypes",
    ///    "permissions",
    ///    "quoteAsset",
    ///    "quoteAssetPrecision",
    ///    "quoteCommissionPrecision",
    ///    "quoteOrderQtyMarketAllowed",
    ///    "status",
    ///    "symbol"
    ///  ],
    ///  "properties": {
    ///    "allowTrailingStop": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "allowedSelfTradePreventionModes": {
    ///      "type": "array",
    ///      "items": {
    ///        "examples": [
    ///          "NONE"
    ///        ],
    ///        "type": "string"
    ///      }
    ///    },
    ///    "baseAsset": {
    ///      "examples": [
    ///        "ETH"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "baseAssetPrecision": {
    ///      "examples": [
    ///        8
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    },
    ///    "baseCommissionPrecision": {
    ///      "examples": [
    ///        8
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    },
    ///    "defaultSelfTradePreventionMode": {
    ///      "examples": [
    ///        "NONE"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "filters": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "filterType",
    ///          "maxPrice",
    ///          "minPrice",
    ///          "tickSize"
    ///        ],
    ///        "properties": {
    ///          "filterType": {
    ///            "examples": [
    ///              "PRICE_FILTER"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "maxPrice": {
    ///            "examples": [
    ///              "100000.00000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "minPrice": {
    ///            "examples": [
    ///              "0.00000100"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "tickSize": {
    ///            "examples": [
    ///              "0.00000100"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "icebergAllowed": {
    ///      "type": "boolean"
    ///    },
    ///    "isMarginTradingAllowed": {
    ///      "type": "boolean"
    ///    },
    ///    "isSpotTradingAllowed": {
    ///      "type": "boolean"
    ///    },
    ///    "ocoAllowed": {
    ///      "type": "boolean"
    ///    },
    ///    "orderTypes": {
    ///      "type": "array",
    ///      "items": {
    ///        "examples": [
    ///          "LIMIT"
    ///        ],
    ///        "type": "string"
    ///      }
    ///    },
    ///    "permissions": {
    ///      "type": "array",
    ///      "items": {
    ///        "examples": [
    ///          "SPOT"
    ///        ],
    ///        "type": "string"
    ///      }
    ///    },
    ///    "quoteAsset": {
    ///      "examples": [
    ///        "BTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "quoteAssetPrecision": {
    ///      "examples": [
    ///        8
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    },
    ///    "quoteCommissionPrecision": {
    ///      "examples": [
    ///        8
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    },
    ///    "quoteOrderQtyMarketAllowed": {
    ///      "type": "boolean"
    ///    },
    ///    "status": {
    ///      "examples": [
    ///        "TRADING"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "symbol": {
    ///      "examples": [
    ///        "ETHBTC"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct ExchangeInfoResponseSymbolsItem {
        #[serde(rename = "allowTrailingStop")]
        pub allow_trailing_stop: bool,
        #[serde(rename = "allowedSelfTradePreventionModes")]
        pub allowed_self_trade_prevention_modes: Vec<String>,
        #[serde(rename = "baseAsset")]
        pub base_asset: String,
        #[serde(rename = "baseAssetPrecision")]
        pub base_asset_precision: i32,
        #[serde(rename = "baseCommissionPrecision")]
        pub base_commission_precision: i32,
        #[serde(rename = "defaultSelfTradePreventionMode")]
        pub default_self_trade_prevention_mode: String,
        pub filters: Vec<ExchangeInfoResponseSymbolsItemFiltersItem>,
        #[serde(rename = "icebergAllowed")]
        pub iceberg_allowed: bool,
        #[serde(rename = "isMarginTradingAllowed")]
        pub is_margin_trading_allowed: bool,
        #[serde(rename = "isSpotTradingAllowed")]
        pub is_spot_trading_allowed: bool,
        #[serde(rename = "ocoAllowed")]
        pub oco_allowed: bool,
        #[serde(rename = "orderTypes")]
        pub order_types: Vec<String>,
        pub permissions: Vec<String>,
        #[serde(rename = "quoteAsset")]
        pub quote_asset: String,
        #[serde(rename = "quoteAssetPrecision")]
        pub quote_asset_precision: i32,
        #[serde(rename = "quoteCommissionPrecision")]
        pub quote_commission_precision: i32,
        #[serde(rename = "quoteOrderQtyMarketAllowed")]
        pub quote_order_qty_market_allowed: bool,
        pub status: String,
        pub symbol: String,
    }
    impl From<&ExchangeInfoResponseSymbolsItem> for ExchangeInfoResponseSymbolsItem {
        fn from(value: &ExchangeInfoResponseSymbolsItem) -> Self {
            value.clone()
        }
    }
    ///ExchangeInfoResponseSymbolsItemFiltersItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "filterType",
    ///    "maxPrice",
    ///    "minPrice",
    ///    "tickSize"
    ///  ],
    ///  "properties": {
    ///    "filterType": {
    ///      "examples": [
    ///        "PRICE_FILTER"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "maxPrice": {
    ///      "examples": [
    ///        "100000.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "minPrice": {
    ///      "examples": [
    ///        "0.00000100"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "tickSize": {
    ///      "examples": [
    ///        "0.00000100"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct ExchangeInfoResponseSymbolsItemFiltersItem {
        #[serde(rename = "filterType")]
        pub filter_type: String,
        #[serde(rename = "maxPrice")]
        pub max_price: String,
        #[serde(rename = "minPrice")]
        pub min_price: String,
        #[serde(rename = "tickSize")]
        pub tick_size: String,
    }
    impl From<&ExchangeInfoResponseSymbolsItemFiltersItem>
    for ExchangeInfoResponseSymbolsItemFiltersItem {
        fn from(value: &ExchangeInfoResponseSymbolsItemFiltersItem) -> Self {
            value.clone()
        }
    }
    ///FiatOrdersResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "code",
    ///    "data",
    ///    "message",
    ///    "success",
    ///    "total"
    ///  ],
    ///  "properties": {
    ///    "code": {
    ///      "examples": [
    ///        "000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "data": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "amount",
    ///          "createTime",
    ///          "fiatCurrency",
    ///          "indicatedAmount",
    ///          "method",
    ///          "orderNo",
    ///          "status",
    ///          "totalFee",
    ///          "updateTime"
    ///        ],
    ///        "properties": {
    ///          "amount": {
    ///            "examples": [
    ///              "10.00"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "createTime": {
    ///            "examples": [
    ///              1626144956000
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "fiatCurrency": {
    ///            "examples": [
    ///              "BRL"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "indicatedAmount": {
    ///            "examples": [
    ///              "10.00"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "method": {
    ///            "examples": [
    ///              "BankAccount"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "orderNo": {
    ///            "examples": [
    ///              "7d76d611-0568-4f43-afb6-24cac7767365"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "status": {
    ///            "description": "Processing, Failed, Successful, Finished, Refunding, Refunded, Refund Failed, Order Partial credit Stopped",
    ///            "examples": [
    ///              "Expired"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "totalFee": {
    ///            "examples": [
    ///              "0.00"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "updateTime": {
    ///            "examples": [
    ///              1626400907000
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "message": {
    ///      "examples": [
    ///        "success"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "success": {
    ///      "type": "boolean"
    ///    },
    ///    "total": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct FiatOrdersResponse {
        pub code: String,
        pub data: Vec<FiatOrdersResponseDataItem>,
        pub message: String,
        pub success: bool,
        pub total: i32,
    }
    impl From<&FiatOrdersResponse> for FiatOrdersResponse {
        fn from(value: &FiatOrdersResponse) -> Self {
            value.clone()
        }
    }
    ///FiatOrdersResponseDataItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "createTime",
    ///    "fiatCurrency",
    ///    "indicatedAmount",
    ///    "method",
    ///    "orderNo",
    ///    "status",
    ///    "totalFee",
    ///    "updateTime"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "examples": [
    ///        "10.00"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "createTime": {
    ///      "examples": [
    ///        1626144956000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "fiatCurrency": {
    ///      "examples": [
    ///        "BRL"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "indicatedAmount": {
    ///      "examples": [
    ///        "10.00"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "method": {
    ///      "examples": [
    ///        "BankAccount"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "orderNo": {
    ///      "examples": [
    ///        "7d76d611-0568-4f43-afb6-24cac7767365"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "description": "Processing, Failed, Successful, Finished, Refunding, Refunded, Refund Failed, Order Partial credit Stopped",
    ///      "examples": [
    ///        "Expired"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalFee": {
    ///      "examples": [
    ///        "0.00"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "updateTime": {
    ///      "examples": [
    ///        1626400907000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct FiatOrdersResponseDataItem {
        pub amount: String,
        #[serde(rename = "createTime")]
        pub create_time: i64,
        #[serde(rename = "fiatCurrency")]
        pub fiat_currency: String,
        #[serde(rename = "indicatedAmount")]
        pub indicated_amount: String,
        pub method: String,
        #[serde(rename = "orderNo")]
        pub order_no: String,
        ///Processing, Failed, Successful, Finished, Refunding, Refunded, Refund Failed, Order Partial credit Stopped
        pub status: String,
        #[serde(rename = "totalFee")]
        pub total_fee: String,
        #[serde(rename = "updateTime")]
        pub update_time: i64,
    }
    impl From<&FiatOrdersResponseDataItem> for FiatOrdersResponseDataItem {
        fn from(value: &FiatOrdersResponseDataItem) -> Self {
            value.clone()
        }
    }
    ///FiatPaymentsResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "code",
    ///    "data",
    ///    "message",
    ///    "success",
    ///    "total"
    ///  ],
    ///  "properties": {
    ///    "code": {
    ///      "examples": [
    ///        "000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "data": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "createTime",
    ///          "cryptoCurrency",
    ///          "fiatCurrency",
    ///          "obtainAmount",
    ///          "orderNo",
    ///          "price",
    ///          "sourceAmount",
    ///          "status",
    ///          "totalFee",
    ///          "updateTime"
    ///        ],
    ///        "properties": {
    ///          "createTime": {
    ///            "examples": [
    ///              1624529919000
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "cryptoCurrency": {
    ///            "description": "Crypto token",
    ///            "examples": [
    ///              "LUNA"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "fiatCurrency": {
    ///            "description": "Fiat token",
    ///            "examples": [
    ///              "EUR"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "obtainAmount": {
    ///            "description": "Crypto trade amount",
    ///            "examples": [
    ///              "4.462"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "orderNo": {
    ///            "examples": [
    ///              "353fca443f06466db0c4dc89f94f027a"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "price": {
    ///            "examples": [
    ///              "4.437472"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "sourceAmount": {
    ///            "description": "Fiat trade amount",
    ///            "examples": [
    ///              "20.00"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "status": {
    ///            "description": "Processing, Completed, Failed, Refunded",
    ///            "examples": [
    ///              "Failed"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "totalFee": {
    ///            "description": "Trade fee",
    ///            "examples": [
    ///              "0.2"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "updateTime": {
    ///            "examples": [
    ///              1624529919000
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "message": {
    ///      "examples": [
    ///        "success"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "success": {
    ///      "type": "boolean"
    ///    },
    ///    "total": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct FiatPaymentsResponse {
        pub code: String,
        pub data: Vec<FiatPaymentsResponseDataItem>,
        pub message: String,
        pub success: bool,
        pub total: i32,
    }
    impl From<&FiatPaymentsResponse> for FiatPaymentsResponse {
        fn from(value: &FiatPaymentsResponse) -> Self {
            value.clone()
        }
    }
    ///FiatPaymentsResponseDataItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "createTime",
    ///    "cryptoCurrency",
    ///    "fiatCurrency",
    ///    "obtainAmount",
    ///    "orderNo",
    ///    "price",
    ///    "sourceAmount",
    ///    "status",
    ///    "totalFee",
    ///    "updateTime"
    ///  ],
    ///  "properties": {
    ///    "createTime": {
    ///      "examples": [
    ///        1624529919000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "cryptoCurrency": {
    ///      "description": "Crypto token",
    ///      "examples": [
    ///        "LUNA"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "fiatCurrency": {
    ///      "description": "Fiat token",
    ///      "examples": [
    ///        "EUR"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "obtainAmount": {
    ///      "description": "Crypto trade amount",
    ///      "examples": [
    ///        "4.462"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "orderNo": {
    ///      "examples": [
    ///        "353fca443f06466db0c4dc89f94f027a"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "price": {
    ///      "examples": [
    ///        "4.437472"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "sourceAmount": {
    ///      "description": "Fiat trade amount",
    ///      "examples": [
    ///        "20.00"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "description": "Processing, Completed, Failed, Refunded",
    ///      "examples": [
    ///        "Failed"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalFee": {
    ///      "description": "Trade fee",
    ///      "examples": [
    ///        "0.2"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "updateTime": {
    ///      "examples": [
    ///        1624529919000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct FiatPaymentsResponseDataItem {
        #[serde(rename = "createTime")]
        pub create_time: i64,
        ///Crypto token
        #[serde(rename = "cryptoCurrency")]
        pub crypto_currency: String,
        ///Fiat token
        #[serde(rename = "fiatCurrency")]
        pub fiat_currency: String,
        ///Crypto trade amount
        #[serde(rename = "obtainAmount")]
        pub obtain_amount: String,
        #[serde(rename = "orderNo")]
        pub order_no: String,
        pub price: String,
        ///Fiat trade amount
        #[serde(rename = "sourceAmount")]
        pub source_amount: String,
        ///Processing, Completed, Failed, Refunded
        pub status: String,
        ///Trade fee
        #[serde(rename = "totalFee")]
        pub total_fee: String,
        #[serde(rename = "updateTime")]
        pub update_time: i64,
    }
    impl From<&FiatPaymentsResponseDataItem> for FiatPaymentsResponseDataItem {
        fn from(value: &FiatPaymentsResponseDataItem) -> Self {
            value.clone()
        }
    }
    ///FuturesHistDataLinkDataType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "T_DEPTH"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "T_DEPTH",
    ///    "S_DEPTH"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum FuturesHistDataLinkDataType {
        #[serde(rename = "T_DEPTH")]
        TDepth,
        #[serde(rename = "S_DEPTH")]
        SDepth,
    }
    impl From<&FuturesHistDataLinkDataType> for FuturesHistDataLinkDataType {
        fn from(value: &FuturesHistDataLinkDataType) -> Self {
            value.clone()
        }
    }
    impl ToString for FuturesHistDataLinkDataType {
        fn to_string(&self) -> String {
            match *self {
                Self::TDepth => "T_DEPTH".to_string(),
                Self::SDepth => "S_DEPTH".to_string(),
            }
        }
    }
    impl std::str::FromStr for FuturesHistDataLinkDataType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "T_DEPTH" => Ok(Self::TDepth),
                "S_DEPTH" => Ok(Self::SDepth),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for FuturesHistDataLinkDataType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for FuturesHistDataLinkDataType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for FuturesHistDataLinkDataType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///FuturesHistDataLinkResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "data"
    ///  ],
    ///  "properties": {
    ///    "data": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "day",
    ///          "url"
    ///        ],
    ///        "properties": {
    ///          "day": {
    ///            "examples": [
    ///              "2023-06-30"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "url": {
    ///            "examples": [
    ///              "https://bin-prod-user-rebate-bucket.s3.ap-northeast-1.amazonaws.com/xxx"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct FuturesHistDataLinkResponse {
        pub data: Vec<FuturesHistDataLinkResponseDataItem>,
    }
    impl From<&FuturesHistDataLinkResponse> for FuturesHistDataLinkResponse {
        fn from(value: &FuturesHistDataLinkResponse) -> Self {
            value.clone()
        }
    }
    ///FuturesHistDataLinkResponseDataItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "day",
    ///    "url"
    ///  ],
    ///  "properties": {
    ///    "day": {
    ///      "examples": [
    ///        "2023-06-30"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "url": {
    ///      "examples": [
    ///        "https://bin-prod-user-rebate-bucket.s3.ap-northeast-1.amazonaws.com/xxx"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct FuturesHistDataLinkResponseDataItem {
        pub day: String,
        pub url: String,
    }
    impl From<&FuturesHistDataLinkResponseDataItem>
    for FuturesHistDataLinkResponseDataItem {
        fn from(value: &FuturesHistDataLinkResponseDataItem) -> Self {
            value.clone()
        }
    }
    ///FuturesTransferResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "tranId"
    ///  ],
    ///  "properties": {
    ///    "tranId": {
    ///      "examples": [
    ///        100000001
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct FuturesTransferResponse {
        #[serde(rename = "tranId")]
        pub tran_id: i64,
    }
    impl From<&FuturesTransferResponse> for FuturesTransferResponse {
        fn from(value: &FuturesTransferResponse) -> Self {
            value.clone()
        }
    }
    ///GetAutoRepayFuturesStatusResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "autoRepay"
    ///  ],
    ///  "properties": {
    ///    "autoRepay": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct GetAutoRepayFuturesStatusResponse {
        #[serde(rename = "autoRepay")]
        pub auto_repay: bool,
    }
    impl From<&GetAutoRepayFuturesStatusResponse> for GetAutoRepayFuturesStatusResponse {
        fn from(value: &GetAutoRepayFuturesStatusResponse) -> Self {
            value.clone()
        }
    }
    ///GetFutureAccountTransactionHistoryResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "rows",
    ///    "total"
    ///  ],
    ///  "properties": {
    ///    "rows": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "amount",
    ///          "asset",
    ///          "status",
    ///          "timestamp",
    ///          "tranId",
    ///          "type"
    ///        ],
    ///        "properties": {
    ///          "amount": {
    ///            "examples": [
    ///              "40.84624400"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "asset": {
    ///            "examples": [
    ///              "USDT"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "status": {
    ///            "description": "one of PENDING (pending to execution), CONFIRMED (successfully transfered), FAILED (execution failed, nothing happened to your account);",
    ///            "examples": [
    ///              "CONFIRMED"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "timestamp": {
    ///            "examples": [
    ///              1555056425000
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "tranId": {
    ///            "examples": [
    ///              100000001
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "type": {
    ///            "examples": [
    ///              "1"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "total": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct GetFutureAccountTransactionHistoryResponse {
        pub rows: Vec<GetFutureAccountTransactionHistoryResponseRowsItem>,
        pub total: i32,
    }
    impl From<&GetFutureAccountTransactionHistoryResponse>
    for GetFutureAccountTransactionHistoryResponse {
        fn from(value: &GetFutureAccountTransactionHistoryResponse) -> Self {
            value.clone()
        }
    }
    ///GetFutureAccountTransactionHistoryResponseRowsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "asset",
    ///    "status",
    ///    "timestamp",
    ///    "tranId",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "examples": [
    ///        "40.84624400"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "asset": {
    ///      "examples": [
    ///        "USDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "description": "one of PENDING (pending to execution), CONFIRMED (successfully transfered), FAILED (execution failed, nothing happened to your account);",
    ///      "examples": [
    ///        "CONFIRMED"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "timestamp": {
    ///      "examples": [
    ///        1555056425000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "tranId": {
    ///      "examples": [
    ///        100000001
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "type": {
    ///      "examples": [
    ///        "1"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct GetFutureAccountTransactionHistoryResponseRowsItem {
        pub amount: String,
        pub asset: String,
        ///one of PENDING (pending to execution), CONFIRMED (successfully transfered), FAILED (execution failed, nothing happened to your account);
        pub status: String,
        pub timestamp: i64,
        #[serde(rename = "tranId")]
        pub tran_id: i64,
        #[serde(rename = "type")]
        pub type_: String,
    }
    impl From<&GetFutureAccountTransactionHistoryResponseRowsItem>
    for GetFutureAccountTransactionHistoryResponseRowsItem {
        fn from(value: &GetFutureAccountTransactionHistoryResponseRowsItem) -> Self {
            value.clone()
        }
    }
    ///GetMarginTransferResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    {
    ///      "rows": [
    ///        {
    ///          "amount": "0.10000000",
    ///          "asset": "BNB",
    ///          "status": "CONFIRMED",
    ///          "timestamp": 1566898617,
    ///          "txId": 5240372201,
    ///          "type": "ROLL_IN"
    ///        }
    ///      ],
    ///      "total": 1
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "rows",
    ///    "total"
    ///  ],
    ///  "properties": {
    ///    "rows": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "amount",
    ///          "asset",
    ///          "status",
    ///          "timestamp",
    ///          "txId",
    ///          "type"
    ///        ],
    ///        "properties": {
    ///          "amount": {
    ///            "type": "string"
    ///          },
    ///          "asset": {
    ///            "type": "string"
    ///          },
    ///          "status": {
    ///            "type": "string"
    ///          },
    ///          "timestamp": {
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "txId": {
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "type": {
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "total": {
    ///      "examples": [
    ///        3
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct GetMarginTransferResponse {
        pub rows: Vec<GetMarginTransferResponseRowsItem>,
        pub total: i32,
    }
    impl From<&GetMarginTransferResponse> for GetMarginTransferResponse {
        fn from(value: &GetMarginTransferResponse) -> Self {
            value.clone()
        }
    }
    ///GetMarginTransferResponseRowsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "asset",
    ///    "status",
    ///    "timestamp",
    ///    "txId",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "type": "string"
    ///    },
    ///    "asset": {
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "type": "string"
    ///    },
    ///    "timestamp": {
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "txId": {
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "type": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct GetMarginTransferResponseRowsItem {
        pub amount: String,
        pub asset: String,
        pub status: String,
        pub timestamp: i64,
        #[serde(rename = "txId")]
        pub tx_id: i64,
        #[serde(rename = "type")]
        pub type_: String,
    }
    impl From<&GetMarginTransferResponseRowsItem> for GetMarginTransferResponseRowsItem {
        fn from(value: &GetMarginTransferResponseRowsItem) -> Self {
            value.clone()
        }
    }
    ///GetMarginTransferType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "ROLL_IN",
    ///    "ROLL_OUT"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum GetMarginTransferType {
        #[serde(rename = "ROLL_IN")]
        RollIn,
        #[serde(rename = "ROLL_OUT")]
        RollOut,
    }
    impl From<&GetMarginTransferType> for GetMarginTransferType {
        fn from(value: &GetMarginTransferType) -> Self {
            value.clone()
        }
    }
    impl ToString for GetMarginTransferType {
        fn to_string(&self) -> String {
            match *self {
                Self::RollIn => "ROLL_IN".to_string(),
                Self::RollOut => "ROLL_OUT".to_string(),
            }
        }
    }
    impl std::str::FromStr for GetMarginTransferType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "ROLL_IN" => Ok(Self::RollIn),
                "ROLL_OUT" => Ok(Self::RollOut),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for GetMarginTransferType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for GetMarginTransferType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for GetMarginTransferType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///GiftcardBuyCodeResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "code",
    ///    "data",
    ///    "message",
    ///    "success"
    ///  ],
    ///  "properties": {
    ///    "code": {
    ///      "examples": [
    ///        "000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "data": {
    ///      "type": "object",
    ///      "required": [
    ///        "code",
    ///        "referenceNo"
    ///      ],
    ///      "properties": {
    ///        "code": {
    ///          "examples": [
    ///            "AOGANK3NB4GIT3C6"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "referenceNo": {
    ///          "examples": [
    ///            "0033002327977405"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "message": {
    ///      "examples": [
    ///        "success"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "success": {
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct GiftcardBuyCodeResponse {
        pub code: String,
        pub data: GiftcardBuyCodeResponseData,
        pub message: String,
        pub success: bool,
    }
    impl From<&GiftcardBuyCodeResponse> for GiftcardBuyCodeResponse {
        fn from(value: &GiftcardBuyCodeResponse) -> Self {
            value.clone()
        }
    }
    ///GiftcardBuyCodeResponseData
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "code",
    ///    "referenceNo"
    ///  ],
    ///  "properties": {
    ///    "code": {
    ///      "examples": [
    ///        "AOGANK3NB4GIT3C6"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "referenceNo": {
    ///      "examples": [
    ///        "0033002327977405"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct GiftcardBuyCodeResponseData {
        pub code: String,
        #[serde(rename = "referenceNo")]
        pub reference_no: String,
    }
    impl From<&GiftcardBuyCodeResponseData> for GiftcardBuyCodeResponseData {
        fn from(value: &GiftcardBuyCodeResponseData) -> Self {
            value.clone()
        }
    }
    ///GiftcardBuyCodeTokenLimitResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "code",
    ///    "data",
    ///    "message",
    ///    "success"
    ///  ],
    ///  "properties": {
    ///    "code": {
    ///      "examples": [
    ///        "000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "data": {
    ///      "type": "object",
    ///      "required": [
    ///        "code",
    ///        "referenceNo"
    ///      ],
    ///      "properties": {
    ///        "coin": {
    ///          "examples": [
    ///            "BNB"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "fromMax": {
    ///          "examples": [
    ///            "1"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "fromMin": {
    ///          "examples": [
    ///            "0.01"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "message": {
    ///      "examples": [
    ///        "success"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "success": {
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct GiftcardBuyCodeTokenLimitResponse {
        pub code: String,
        pub data: GiftcardBuyCodeTokenLimitResponseData,
        pub message: String,
        pub success: bool,
    }
    impl From<&GiftcardBuyCodeTokenLimitResponse> for GiftcardBuyCodeTokenLimitResponse {
        fn from(value: &GiftcardBuyCodeTokenLimitResponse) -> Self {
            value.clone()
        }
    }
    ///GiftcardBuyCodeTokenLimitResponseData
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "code",
    ///    "referenceNo"
    ///  ],
    ///  "properties": {
    ///    "coin": {
    ///      "examples": [
    ///        "BNB"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "fromMax": {
    ///      "examples": [
    ///        "1"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "fromMin": {
    ///      "examples": [
    ///        "0.01"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct GiftcardBuyCodeTokenLimitResponseData {
        pub code: serde_json::Value,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub coin: Option<String>,
        #[serde(rename = "fromMax", default, skip_serializing_if = "Option::is_none")]
        pub from_max: Option<String>,
        #[serde(rename = "fromMin", default, skip_serializing_if = "Option::is_none")]
        pub from_min: Option<String>,
        #[serde(rename = "referenceNo")]
        pub reference_no: serde_json::Value,
    }
    impl From<&GiftcardBuyCodeTokenLimitResponseData>
    for GiftcardBuyCodeTokenLimitResponseData {
        fn from(value: &GiftcardBuyCodeTokenLimitResponseData) -> Self {
            value.clone()
        }
    }
    ///GiftcardCreateCodeResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "code",
    ///    "data",
    ///    "message",
    ///    "success"
    ///  ],
    ///  "properties": {
    ///    "code": {
    ///      "examples": [
    ///        "000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "data": {
    ///      "type": "object",
    ///      "required": [
    ///        "code",
    ///        "referenceNo"
    ///      ],
    ///      "properties": {
    ///        "code": {
    ///          "examples": [
    ///            "AOGANK3NB4GIT3C6"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "referenceNo": {
    ///          "examples": [
    ///            "0033002327977405"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "message": {
    ///      "examples": [
    ///        "success"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "success": {
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct GiftcardCreateCodeResponse {
        pub code: String,
        pub data: GiftcardCreateCodeResponseData,
        pub message: String,
        pub success: bool,
    }
    impl From<&GiftcardCreateCodeResponse> for GiftcardCreateCodeResponse {
        fn from(value: &GiftcardCreateCodeResponse) -> Self {
            value.clone()
        }
    }
    ///GiftcardCreateCodeResponseData
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "code",
    ///    "referenceNo"
    ///  ],
    ///  "properties": {
    ///    "code": {
    ///      "examples": [
    ///        "AOGANK3NB4GIT3C6"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "referenceNo": {
    ///      "examples": [
    ///        "0033002327977405"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct GiftcardCreateCodeResponseData {
        pub code: String,
        #[serde(rename = "referenceNo")]
        pub reference_no: String,
    }
    impl From<&GiftcardCreateCodeResponseData> for GiftcardCreateCodeResponseData {
        fn from(value: &GiftcardCreateCodeResponseData) -> Self {
            value.clone()
        }
    }
    ///GiftcardCryptographyRsaPublicKeyResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "code",
    ///    "data",
    ///    "message",
    ///    "success"
    ///  ],
    ///  "properties": {
    ///    "code": {
    ///      "examples": [
    ///        "000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "data": {
    ///      "examples": [
    ///        "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCXBBVKLAc1GQ5FsIFFqOHrPTox5noBONIKr+IAedTR9FkVxq6e65updEbfdhRNkMOeYIO2i0UylrjGC0X8YSoIszmrVHeV0l06Zh1oJuZos1+7N+WLuz9JvlPaawof3GUakTxYWWCa9+8KIbLKsoKMdfS96VT+8iOXO3quMGKUmQIDAQAB"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "message": {
    ///      "examples": [
    ///        "success"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "success": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct GiftcardCryptographyRsaPublicKeyResponse {
        pub code: String,
        pub data: String,
        pub message: String,
        pub success: bool,
    }
    impl From<&GiftcardCryptographyRsaPublicKeyResponse>
    for GiftcardCryptographyRsaPublicKeyResponse {
        fn from(value: &GiftcardCryptographyRsaPublicKeyResponse) -> Self {
            value.clone()
        }
    }
    ///GiftcardRedeemCodeResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "code",
    ///    "data",
    ///    "message",
    ///    "success"
    ///  ],
    ///  "properties": {
    ///    "code": {
    ///      "examples": [
    ///        "000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "data": {
    ///      "type": "object",
    ///      "required": [
    ///        "amount",
    ///        "identityNo",
    ///        "referenceNo",
    ///        "token"
    ///      ],
    ///      "properties": {
    ///        "amount": {
    ///          "examples": [
    ///            "10"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "identityNo": {
    ///          "examples": [
    ///            "10316281761814589440"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "referenceNo": {
    ///          "examples": [
    ///            "0033002327977405"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "token": {
    ///          "examples": [
    ///            "BNB"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "message": {
    ///      "examples": [
    ///        "success"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "success": {
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct GiftcardRedeemCodeResponse {
        pub code: String,
        pub data: GiftcardRedeemCodeResponseData,
        pub message: String,
        pub success: bool,
    }
    impl From<&GiftcardRedeemCodeResponse> for GiftcardRedeemCodeResponse {
        fn from(value: &GiftcardRedeemCodeResponse) -> Self {
            value.clone()
        }
    }
    ///GiftcardRedeemCodeResponseData
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "identityNo",
    ///    "referenceNo",
    ///    "token"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "examples": [
    ///        "10"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "identityNo": {
    ///      "examples": [
    ///        "10316281761814589440"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "referenceNo": {
    ///      "examples": [
    ///        "0033002327977405"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "token": {
    ///      "examples": [
    ///        "BNB"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct GiftcardRedeemCodeResponseData {
        pub amount: String,
        #[serde(rename = "identityNo")]
        pub identity_no: String,
        #[serde(rename = "referenceNo")]
        pub reference_no: String,
        pub token: String,
    }
    impl From<&GiftcardRedeemCodeResponseData> for GiftcardRedeemCodeResponseData {
        fn from(value: &GiftcardRedeemCodeResponseData) -> Self {
            value.clone()
        }
    }
    ///GiftcardVerifyResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "code",
    ///    "data",
    ///    "message",
    ///    "success"
    ///  ],
    ///  "properties": {
    ///    "code": {
    ///      "examples": [
    ///        "000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "data": {
    ///      "type": "object",
    ///      "required": [
    ///        "amount",
    ///        "token",
    ///        "valid"
    ///      ],
    ///      "properties": {
    ///        "amount": {
    ///          "examples": [
    ///            "0.00000001"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "token": {
    ///          "examples": [
    ///            "BNB"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "valid": {
    ///          "type": "boolean"
    ///        }
    ///      }
    ///    },
    ///    "message": {
    ///      "examples": [
    ///        "success"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "success": {
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct GiftcardVerifyResponse {
        pub code: String,
        pub data: GiftcardVerifyResponseData,
        pub message: String,
        pub success: bool,
    }
    impl From<&GiftcardVerifyResponse> for GiftcardVerifyResponse {
        fn from(value: &GiftcardVerifyResponse) -> Self {
            value.clone()
        }
    }
    ///GiftcardVerifyResponseData
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "token",
    ///    "valid"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "examples": [
    ///        "0.00000001"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "token": {
    ///      "examples": [
    ///        "BNB"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "valid": {
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct GiftcardVerifyResponseData {
        pub amount: String,
        pub token: String,
        pub valid: bool,
    }
    impl From<&GiftcardVerifyResponseData> for GiftcardVerifyResponseData {
        fn from(value: &GiftcardVerifyResponseData) -> Self {
            value.clone()
        }
    }
    ///IsolatedMarginAccountInfo
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "assets",
    ///    "totalAssetOfBtc",
    ///    "totalLiabilityOfBtc",
    ///    "totalNetAssetOfBtc"
    ///  ],
    ///  "properties": {
    ///    "assets": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "baseAsset",
    ///          "enabled",
    ///          "indexPrice",
    ///          "isolatedCreated",
    ///          "liquidatePrice",
    ///          "liquidateRate",
    ///          "marginLevel",
    ///          "marginLevelStatus",
    ///          "marginRatio",
    ///          "quoteAsset",
    ///          "symbol",
    ///          "tradeEnabled"
    ///        ],
    ///        "properties": {
    ///          "baseAsset": {
    ///            "type": "object",
    ///            "required": [
    ///              "asset",
    ///              "borrowEnabled",
    ///              "borrowed",
    ///              "free",
    ///              "interest",
    ///              "locked",
    ///              "netAsset",
    ///              "netAssetOfBtc",
    ///              "repayEnabled",
    ///              "totalAsset"
    ///            ],
    ///            "properties": {
    ///              "asset": {
    ///                "examples": [
    ///                  "BTC"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "borrowEnabled": {
    ///                "type": "boolean"
    ///              },
    ///              "borrowed": {
    ///                "examples": [
    ///                  "0.00000000"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "free": {
    ///                "examples": [
    ///                  "0.00000000"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "interest": {
    ///                "examples": [
    ///                  "0.00000000"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "locked": {
    ///                "examples": [
    ///                  "0.00000000"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "netAsset": {
    ///                "examples": [
    ///                  "0.00000000"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "netAssetOfBtc": {
    ///                "examples": [
    ///                  "0.00000000"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "repayEnabled": {
    ///                "type": "boolean"
    ///              },
    ///              "totalAsset": {
    ///                "examples": [
    ///                  "0.00000000"
    ///                ],
    ///                "type": "string"
    ///              }
    ///            }
    ///          },
    ///          "enabled": {
    ///            "description": "true-enabled, false-disabled",
    ///            "type": "boolean"
    ///          },
    ///          "indexPrice": {
    ///            "examples": [
    ///              "10000.00000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "isolatedCreated": {
    ///            "type": "boolean"
    ///          },
    ///          "liquidatePrice": {
    ///            "examples": [
    ///              "1000.00000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "liquidateRate": {
    ///            "examples": [
    ///              "1.00000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "marginLevel": {
    ///            "examples": [
    ///              "0.00000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "marginLevelStatus": {
    ///            "description": "\"EXCESSIVE\", \"NORMAL\", \"MARGIN_CALL\", \"PRE_LIQUIDATION\", \"FORCE_LIQUIDATION\"",
    ///            "examples": [
    ///              "EXCESSIVE"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "marginRatio": {
    ///            "examples": [
    ///              "0.00000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "quoteAsset": {
    ///            "type": "object",
    ///            "required": [
    ///              "asset",
    ///              "borrowEnabled",
    ///              "borrowed",
    ///              "free",
    ///              "interest",
    ///              "locked",
    ///              "netAsset",
    ///              "netAssetOfBtc",
    ///              "repayEnabled",
    ///              "totalAsset"
    ///            ],
    ///            "properties": {
    ///              "asset": {
    ///                "examples": [
    ///                  "USDT"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "borrowEnabled": {
    ///                "type": "boolean"
    ///              },
    ///              "borrowed": {
    ///                "examples": [
    ///                  "0.00000000"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "free": {
    ///                "examples": [
    ///                  "0.00000000"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "interest": {
    ///                "examples": [
    ///                  "0.00000000"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "locked": {
    ///                "examples": [
    ///                  "0.00000000"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "netAsset": {
    ///                "examples": [
    ///                  "0.00000000"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "netAssetOfBtc": {
    ///                "examples": [
    ///                  "0.00000000"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "repayEnabled": {
    ///                "type": "boolean"
    ///              },
    ///              "totalAsset": {
    ///                "examples": [
    ///                  "0.00000000"
    ///                ],
    ///                "type": "string"
    ///              }
    ///            }
    ///          },
    ///          "symbol": {
    ///            "examples": [
    ///              "BTCUSDT"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "tradeEnabled": {
    ///            "type": "boolean"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "totalAssetOfBtc": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalLiabilityOfBtc": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalNetAssetOfBtc": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct IsolatedMarginAccountInfo {
        pub assets: Vec<IsolatedMarginAccountInfoAssetsItem>,
        #[serde(rename = "totalAssetOfBtc")]
        pub total_asset_of_btc: String,
        #[serde(rename = "totalLiabilityOfBtc")]
        pub total_liability_of_btc: String,
        #[serde(rename = "totalNetAssetOfBtc")]
        pub total_net_asset_of_btc: String,
    }
    impl From<&IsolatedMarginAccountInfo> for IsolatedMarginAccountInfo {
        fn from(value: &IsolatedMarginAccountInfo) -> Self {
            value.clone()
        }
    }
    ///IsolatedMarginAccountInfoAssetsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "baseAsset",
    ///    "enabled",
    ///    "indexPrice",
    ///    "isolatedCreated",
    ///    "liquidatePrice",
    ///    "liquidateRate",
    ///    "marginLevel",
    ///    "marginLevelStatus",
    ///    "marginRatio",
    ///    "quoteAsset",
    ///    "symbol",
    ///    "tradeEnabled"
    ///  ],
    ///  "properties": {
    ///    "baseAsset": {
    ///      "type": "object",
    ///      "required": [
    ///        "asset",
    ///        "borrowEnabled",
    ///        "borrowed",
    ///        "free",
    ///        "interest",
    ///        "locked",
    ///        "netAsset",
    ///        "netAssetOfBtc",
    ///        "repayEnabled",
    ///        "totalAsset"
    ///      ],
    ///      "properties": {
    ///        "asset": {
    ///          "examples": [
    ///            "BTC"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "borrowEnabled": {
    ///          "type": "boolean"
    ///        },
    ///        "borrowed": {
    ///          "examples": [
    ///            "0.00000000"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "free": {
    ///          "examples": [
    ///            "0.00000000"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "interest": {
    ///          "examples": [
    ///            "0.00000000"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "locked": {
    ///          "examples": [
    ///            "0.00000000"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "netAsset": {
    ///          "examples": [
    ///            "0.00000000"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "netAssetOfBtc": {
    ///          "examples": [
    ///            "0.00000000"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "repayEnabled": {
    ///          "type": "boolean"
    ///        },
    ///        "totalAsset": {
    ///          "examples": [
    ///            "0.00000000"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "enabled": {
    ///      "description": "true-enabled, false-disabled",
    ///      "type": "boolean"
    ///    },
    ///    "indexPrice": {
    ///      "examples": [
    ///        "10000.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "isolatedCreated": {
    ///      "type": "boolean"
    ///    },
    ///    "liquidatePrice": {
    ///      "examples": [
    ///        "1000.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "liquidateRate": {
    ///      "examples": [
    ///        "1.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "marginLevel": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "marginLevelStatus": {
    ///      "description": "\"EXCESSIVE\", \"NORMAL\", \"MARGIN_CALL\", \"PRE_LIQUIDATION\", \"FORCE_LIQUIDATION\"",
    ///      "examples": [
    ///        "EXCESSIVE"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "marginRatio": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "quoteAsset": {
    ///      "type": "object",
    ///      "required": [
    ///        "asset",
    ///        "borrowEnabled",
    ///        "borrowed",
    ///        "free",
    ///        "interest",
    ///        "locked",
    ///        "netAsset",
    ///        "netAssetOfBtc",
    ///        "repayEnabled",
    ///        "totalAsset"
    ///      ],
    ///      "properties": {
    ///        "asset": {
    ///          "examples": [
    ///            "USDT"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "borrowEnabled": {
    ///          "type": "boolean"
    ///        },
    ///        "borrowed": {
    ///          "examples": [
    ///            "0.00000000"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "free": {
    ///          "examples": [
    ///            "0.00000000"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "interest": {
    ///          "examples": [
    ///            "0.00000000"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "locked": {
    ///          "examples": [
    ///            "0.00000000"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "netAsset": {
    ///          "examples": [
    ///            "0.00000000"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "netAssetOfBtc": {
    ///          "examples": [
    ///            "0.00000000"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "repayEnabled": {
    ///          "type": "boolean"
    ///        },
    ///        "totalAsset": {
    ///          "examples": [
    ///            "0.00000000"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "symbol": {
    ///      "examples": [
    ///        "BTCUSDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "tradeEnabled": {
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct IsolatedMarginAccountInfoAssetsItem {
        #[serde(rename = "baseAsset")]
        pub base_asset: IsolatedMarginAccountInfoAssetsItemBaseAsset,
        ///true-enabled, false-disabled
        pub enabled: bool,
        #[serde(rename = "indexPrice")]
        pub index_price: String,
        #[serde(rename = "isolatedCreated")]
        pub isolated_created: bool,
        #[serde(rename = "liquidatePrice")]
        pub liquidate_price: String,
        #[serde(rename = "liquidateRate")]
        pub liquidate_rate: String,
        #[serde(rename = "marginLevel")]
        pub margin_level: String,
        ///"EXCESSIVE", "NORMAL", "MARGIN_CALL", "PRE_LIQUIDATION", "FORCE_LIQUIDATION"
        #[serde(rename = "marginLevelStatus")]
        pub margin_level_status: String,
        #[serde(rename = "marginRatio")]
        pub margin_ratio: String,
        #[serde(rename = "quoteAsset")]
        pub quote_asset: IsolatedMarginAccountInfoAssetsItemQuoteAsset,
        pub symbol: String,
        #[serde(rename = "tradeEnabled")]
        pub trade_enabled: bool,
    }
    impl From<&IsolatedMarginAccountInfoAssetsItem>
    for IsolatedMarginAccountInfoAssetsItem {
        fn from(value: &IsolatedMarginAccountInfoAssetsItem) -> Self {
            value.clone()
        }
    }
    ///IsolatedMarginAccountInfoAssetsItemBaseAsset
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "asset",
    ///    "borrowEnabled",
    ///    "borrowed",
    ///    "free",
    ///    "interest",
    ///    "locked",
    ///    "netAsset",
    ///    "netAssetOfBtc",
    ///    "repayEnabled",
    ///    "totalAsset"
    ///  ],
    ///  "properties": {
    ///    "asset": {
    ///      "examples": [
    ///        "BTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "borrowEnabled": {
    ///      "type": "boolean"
    ///    },
    ///    "borrowed": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "free": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "interest": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "locked": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "netAsset": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "netAssetOfBtc": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "repayEnabled": {
    ///      "type": "boolean"
    ///    },
    ///    "totalAsset": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct IsolatedMarginAccountInfoAssetsItemBaseAsset {
        pub asset: String,
        #[serde(rename = "borrowEnabled")]
        pub borrow_enabled: bool,
        pub borrowed: String,
        pub free: String,
        pub interest: String,
        pub locked: String,
        #[serde(rename = "netAsset")]
        pub net_asset: String,
        #[serde(rename = "netAssetOfBtc")]
        pub net_asset_of_btc: String,
        #[serde(rename = "repayEnabled")]
        pub repay_enabled: bool,
        #[serde(rename = "totalAsset")]
        pub total_asset: String,
    }
    impl From<&IsolatedMarginAccountInfoAssetsItemBaseAsset>
    for IsolatedMarginAccountInfoAssetsItemBaseAsset {
        fn from(value: &IsolatedMarginAccountInfoAssetsItemBaseAsset) -> Self {
            value.clone()
        }
    }
    ///IsolatedMarginAccountInfoAssetsItemQuoteAsset
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "asset",
    ///    "borrowEnabled",
    ///    "borrowed",
    ///    "free",
    ///    "interest",
    ///    "locked",
    ///    "netAsset",
    ///    "netAssetOfBtc",
    ///    "repayEnabled",
    ///    "totalAsset"
    ///  ],
    ///  "properties": {
    ///    "asset": {
    ///      "examples": [
    ///        "USDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "borrowEnabled": {
    ///      "type": "boolean"
    ///    },
    ///    "borrowed": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "free": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "interest": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "locked": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "netAsset": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "netAssetOfBtc": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "repayEnabled": {
    ///      "type": "boolean"
    ///    },
    ///    "totalAsset": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct IsolatedMarginAccountInfoAssetsItemQuoteAsset {
        pub asset: String,
        #[serde(rename = "borrowEnabled")]
        pub borrow_enabled: bool,
        pub borrowed: String,
        pub free: String,
        pub interest: String,
        pub locked: String,
        #[serde(rename = "netAsset")]
        pub net_asset: String,
        #[serde(rename = "netAssetOfBtc")]
        pub net_asset_of_btc: String,
        #[serde(rename = "repayEnabled")]
        pub repay_enabled: bool,
        #[serde(rename = "totalAsset")]
        pub total_asset: String,
    }
    impl From<&IsolatedMarginAccountInfoAssetsItemQuoteAsset>
    for IsolatedMarginAccountInfoAssetsItemQuoteAsset {
        fn from(value: &IsolatedMarginAccountInfoAssetsItemQuoteAsset) -> Self {
            value.clone()
        }
    }
    ///KlineCandlestickDataInterval
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "\"1m\""
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "1s",
    ///    "1m",
    ///    "3m",
    ///    "5m",
    ///    "15m",
    ///    "30m",
    ///    "1h",
    ///    "2h",
    ///    "4h",
    ///    "6h",
    ///    "8h",
    ///    "12h",
    ///    "1d",
    ///    "3d",
    ///    "1w"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum KlineCandlestickDataInterval {
        #[serde(rename = "1s")]
        _1s,
        #[serde(rename = "1m")]
        _1m,
        #[serde(rename = "3m")]
        _3m,
        #[serde(rename = "5m")]
        _5m,
        #[serde(rename = "15m")]
        _15m,
        #[serde(rename = "30m")]
        _30m,
        #[serde(rename = "1h")]
        _1h,
        #[serde(rename = "2h")]
        _2h,
        #[serde(rename = "4h")]
        _4h,
        #[serde(rename = "6h")]
        _6h,
        #[serde(rename = "8h")]
        _8h,
        #[serde(rename = "12h")]
        _12h,
        #[serde(rename = "1d")]
        _1d,
        #[serde(rename = "3d")]
        _3d,
        #[serde(rename = "1w")]
        _1w,
    }
    impl From<&KlineCandlestickDataInterval> for KlineCandlestickDataInterval {
        fn from(value: &KlineCandlestickDataInterval) -> Self {
            value.clone()
        }
    }
    impl ToString for KlineCandlestickDataInterval {
        fn to_string(&self) -> String {
            match *self {
                Self::_1s => "1s".to_string(),
                Self::_1m => "1m".to_string(),
                Self::_3m => "3m".to_string(),
                Self::_5m => "5m".to_string(),
                Self::_15m => "15m".to_string(),
                Self::_30m => "30m".to_string(),
                Self::_1h => "1h".to_string(),
                Self::_2h => "2h".to_string(),
                Self::_4h => "4h".to_string(),
                Self::_6h => "6h".to_string(),
                Self::_8h => "8h".to_string(),
                Self::_12h => "12h".to_string(),
                Self::_1d => "1d".to_string(),
                Self::_3d => "3d".to_string(),
                Self::_1w => "1w".to_string(),
            }
        }
    }
    impl std::str::FromStr for KlineCandlestickDataInterval {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "1s" => Ok(Self::_1s),
                "1m" => Ok(Self::_1m),
                "3m" => Ok(Self::_3m),
                "5m" => Ok(Self::_5m),
                "15m" => Ok(Self::_15m),
                "30m" => Ok(Self::_30m),
                "1h" => Ok(Self::_1h),
                "2h" => Ok(Self::_2h),
                "4h" => Ok(Self::_4h),
                "6h" => Ok(Self::_6h),
                "8h" => Ok(Self::_8h),
                "12h" => Ok(Self::_12h),
                "1d" => Ok(Self::_1d),
                "3d" => Ok(Self::_3d),
                "1w" => Ok(Self::_1w),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for KlineCandlestickDataInterval {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for KlineCandlestickDataInterval {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for KlineCandlestickDataInterval {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///KlineCandlestickDataResponseItemItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    {
    ///      "type": "string"
    ///    }
    ///  ],
    ///  "maxItems": 12,
    ///  "minItems": 12
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    #[serde(untagged)]
    pub enum KlineCandlestickDataResponseItemItem {
        Variant0(i64),
        Variant1(String),
    }
    impl From<&KlineCandlestickDataResponseItemItem>
    for KlineCandlestickDataResponseItemItem {
        fn from(value: &KlineCandlestickDataResponseItemItem) -> Self {
            value.clone()
        }
    }
    impl std::str::FromStr for KlineCandlestickDataResponseItemItem {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if let Ok(v) = value.parse() {
                Ok(Self::Variant0(v))
            } else if let Ok(v) = value.parse() {
                Ok(Self::Variant1(v))
            } else {
                Err("string conversion failed for all variants".into())
            }
        }
    }
    impl std::convert::TryFrom<&str> for KlineCandlestickDataResponseItemItem {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for KlineCandlestickDataResponseItemItem {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for KlineCandlestickDataResponseItemItem {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ToString for KlineCandlestickDataResponseItemItem {
        fn to_string(&self) -> String {
            match self {
                Self::Variant0(x) => x.to_string(),
                Self::Variant1(x) => x.to_string(),
            }
        }
    }
    impl From<i64> for KlineCandlestickDataResponseItemItem {
        fn from(value: i64) -> Self {
            Self::Variant0(value)
        }
    }
    ///LendingAutoInvestAllAssetResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "sourceAssets",
    ///    "targetAssets"
    ///  ],
    ///  "properties": {
    ///    "sourceAssets": {
    ///      "type": "array",
    ///      "items": {
    ///        "examples": [
    ///          [
    ///            "BTC",
    ///            "BNB"
    ///          ]
    ///        ],
    ///        "type": "string"
    ///      }
    ///    },
    ///    "targetAssets": {
    ///      "type": "array",
    ///      "items": {
    ///        "examples": [
    ///          [
    ///            "BTC",
    ///            "BNB"
    ///          ]
    ///        ],
    ///        "type": "string"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct LendingAutoInvestAllAssetResponse {
        #[serde(rename = "sourceAssets")]
        pub source_assets: Vec<String>,
        #[serde(rename = "targetAssets")]
        pub target_assets: Vec<String>,
    }
    impl From<&LendingAutoInvestAllAssetResponse> for LendingAutoInvestAllAssetResponse {
        fn from(value: &LendingAutoInvestAllAssetResponse) -> Self {
            value.clone()
        }
    }
    ///LendingAutoInvestSourceAssetListResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "feeRate",
    ///    "sourceAssets"
    ///  ],
    ///  "properties": {
    ///    "feeRate": {
    ///      "examples": [
    ///        "0.002"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "sourceAssets": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "assetMaxAmount",
    ///          "assetMinAmount",
    ///          "flexibleAmount",
    ///          "scale",
    ///          "sourceAsset"
    ///        ],
    ///        "properties": {
    ///          "assetMaxAmount": {
    ///            "examples": [
    ///              "1000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "assetMinAmount": {
    ///            "examples": [
    ///              "0.1"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "flexibleAmount": {
    ///            "examples": [
    ///              "1111"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "scale": {
    ///            "examples": [
    ///              "2"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "sourceAsset": {
    ///            "examples": [
    ///              "USDT"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct LendingAutoInvestSourceAssetListResponse {
        #[serde(rename = "feeRate")]
        pub fee_rate: String,
        #[serde(rename = "sourceAssets")]
        pub source_assets: Vec<LendingAutoInvestSourceAssetListResponseSourceAssetsItem>,
    }
    impl From<&LendingAutoInvestSourceAssetListResponse>
    for LendingAutoInvestSourceAssetListResponse {
        fn from(value: &LendingAutoInvestSourceAssetListResponse) -> Self {
            value.clone()
        }
    }
    ///LendingAutoInvestSourceAssetListResponseSourceAssetsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "assetMaxAmount",
    ///    "assetMinAmount",
    ///    "flexibleAmount",
    ///    "scale",
    ///    "sourceAsset"
    ///  ],
    ///  "properties": {
    ///    "assetMaxAmount": {
    ///      "examples": [
    ///        "1000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "assetMinAmount": {
    ///      "examples": [
    ///        "0.1"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "flexibleAmount": {
    ///      "examples": [
    ///        "1111"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "scale": {
    ///      "examples": [
    ///        "2"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "sourceAsset": {
    ///      "examples": [
    ///        "USDT"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct LendingAutoInvestSourceAssetListResponseSourceAssetsItem {
        #[serde(rename = "assetMaxAmount")]
        pub asset_max_amount: String,
        #[serde(rename = "assetMinAmount")]
        pub asset_min_amount: String,
        #[serde(rename = "flexibleAmount")]
        pub flexible_amount: String,
        pub scale: String,
        #[serde(rename = "sourceAsset")]
        pub source_asset: String,
    }
    impl From<&LendingAutoInvestSourceAssetListResponseSourceAssetsItem>
    for LendingAutoInvestSourceAssetListResponseSourceAssetsItem {
        fn from(
            value: &LendingAutoInvestSourceAssetListResponseSourceAssetsItem,
        ) -> Self {
            value.clone()
        }
    }
    ///LendingAutoInvestTargetAssetListResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "autoInvestAssetList": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "roiAndDimensionTypeList",
    ///          "targetAsset"
    ///        ],
    ///        "properties": {
    ///          "roiAndDimensionTypeList": {
    ///            "type": "array",
    ///            "items": {
    ///              "type": "object",
    ///              "required": [
    ///                "dimensionUnit",
    ///                "dimensionValue",
    ///                "simulateRoi"
    ///              ],
    ///              "properties": {
    ///                "dimensionUnit": {
    ///                  "examples": [
    ///                    "year"
    ///                  ],
    ///                  "type": "string"
    ///                },
    ///                "dimensionValue": {
    ///                  "examples": [
    ///                    "3"
    ///                  ],
    ///                  "type": "string"
    ///                },
    ///                "simulateRoi": {
    ///                  "examples": [
    ///                    "5.004"
    ///                  ],
    ///                  "type": "string"
    ///                }
    ///              }
    ///            }
    ///          },
    ///          "targetAsset": {
    ///            "examples": [
    ///              "BTC"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "targetAssets": {
    ///      "examples": [
    ///        "BTC"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct LendingAutoInvestTargetAssetListResponse {
        #[serde(
            rename = "autoInvestAssetList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub auto_invest_asset_list: Vec<
            LendingAutoInvestTargetAssetListResponseAutoInvestAssetListItem,
        >,
        #[serde(
            rename = "targetAssets",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub target_assets: Option<String>,
    }
    impl From<&LendingAutoInvestTargetAssetListResponse>
    for LendingAutoInvestTargetAssetListResponse {
        fn from(value: &LendingAutoInvestTargetAssetListResponse) -> Self {
            value.clone()
        }
    }
    ///LendingAutoInvestTargetAssetListResponseAutoInvestAssetListItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "roiAndDimensionTypeList",
    ///    "targetAsset"
    ///  ],
    ///  "properties": {
    ///    "roiAndDimensionTypeList": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "dimensionUnit",
    ///          "dimensionValue",
    ///          "simulateRoi"
    ///        ],
    ///        "properties": {
    ///          "dimensionUnit": {
    ///            "examples": [
    ///              "year"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "dimensionValue": {
    ///            "examples": [
    ///              "3"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "simulateRoi": {
    ///            "examples": [
    ///              "5.004"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "targetAsset": {
    ///      "examples": [
    ///        "BTC"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct LendingAutoInvestTargetAssetListResponseAutoInvestAssetListItem {
        #[serde(rename = "roiAndDimensionTypeList")]
        pub roi_and_dimension_type_list: Vec<
            LendingAutoInvestTargetAssetListResponseAutoInvestAssetListItemRoiAndDimensionTypeListItem,
        >,
        #[serde(rename = "targetAsset")]
        pub target_asset: String,
    }
    impl From<&LendingAutoInvestTargetAssetListResponseAutoInvestAssetListItem>
    for LendingAutoInvestTargetAssetListResponseAutoInvestAssetListItem {
        fn from(
            value: &LendingAutoInvestTargetAssetListResponseAutoInvestAssetListItem,
        ) -> Self {
            value.clone()
        }
    }
    ///LendingAutoInvestTargetAssetListResponseAutoInvestAssetListItemRoiAndDimensionTypeListItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "dimensionUnit",
    ///    "dimensionValue",
    ///    "simulateRoi"
    ///  ],
    ///  "properties": {
    ///    "dimensionUnit": {
    ///      "examples": [
    ///        "year"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "dimensionValue": {
    ///      "examples": [
    ///        "3"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "simulateRoi": {
    ///      "examples": [
    ///        "5.004"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct LendingAutoInvestTargetAssetListResponseAutoInvestAssetListItemRoiAndDimensionTypeListItem {
        #[serde(rename = "dimensionUnit")]
        pub dimension_unit: String,
        #[serde(rename = "dimensionValue")]
        pub dimension_value: String,
        #[serde(rename = "simulateRoi")]
        pub simulate_roi: String,
    }
    impl From<
        &LendingAutoInvestTargetAssetListResponseAutoInvestAssetListItemRoiAndDimensionTypeListItem,
    >
    for LendingAutoInvestTargetAssetListResponseAutoInvestAssetListItemRoiAndDimensionTypeListItem {
        fn from(
            value: &LendingAutoInvestTargetAssetListResponseAutoInvestAssetListItemRoiAndDimensionTypeListItem,
        ) -> Self {
            value.clone()
        }
    }
    ///LendingAutoInvestTargetAssetRoiListResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "date",
    ///    "simulateRoi"
    ///  ],
    ///  "properties": {
    ///    "date": {
    ///      "examples": [
    ///        "1648378800000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "simulateRoi": {
    ///      "examples": [
    ///        "1.75"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct LendingAutoInvestTargetAssetRoiListResponseItem {
        pub date: String,
        #[serde(rename = "simulateRoi")]
        pub simulate_roi: String,
    }
    impl From<&LendingAutoInvestTargetAssetRoiListResponseItem>
    for LendingAutoInvestTargetAssetRoiListResponseItem {
        fn from(value: &LendingAutoInvestTargetAssetRoiListResponseItem) -> Self {
            value.clone()
        }
    }
    ///LendingCustomizedFixedPurchaseResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "purchaseId"
    ///  ],
    ///  "properties": {
    ///    "purchaseId": {
    ///      "examples": [
    ///        "18356"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct LendingCustomizedFixedPurchaseResponse {
        #[serde(rename = "purchaseId")]
        pub purchase_id: String,
    }
    impl From<&LendingCustomizedFixedPurchaseResponse>
    for LendingCustomizedFixedPurchaseResponse {
        fn from(value: &LendingCustomizedFixedPurchaseResponse) -> Self {
            value.clone()
        }
    }
    ///LendingPositionChangedResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "dailyPurchaseId",
    ///    "success",
    ///    "time"
    ///  ],
    ///  "properties": {
    ///    "dailyPurchaseId": {
    ///      "examples": [
    ///        862290
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "success": {
    ///      "type": "boolean"
    ///    },
    ///    "time": {
    ///      "examples": [
    ///        1577233578000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct LendingPositionChangedResponse {
        #[serde(rename = "dailyPurchaseId")]
        pub daily_purchase_id: i64,
        pub success: bool,
        pub time: i64,
    }
    impl From<&LendingPositionChangedResponse> for LendingPositionChangedResponse {
        fn from(value: &LendingPositionChangedResponse) -> Self {
            value.clone()
        }
    }
    ///LendingProjectListResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "asset",
    ///    "displayPriority",
    ///    "duration",
    ///    "interestPerLot",
    ///    "interestRate",
    ///    "lotSize",
    ///    "lotsLowLimit",
    ///    "lotsPurchased",
    ///    "lotsUpLimit",
    ///    "maxLotsPerUser",
    ///    "needKyc",
    ///    "projectId",
    ///    "projectName",
    ///    "status",
    ///    "type",
    ///    "withAreaLimitation"
    ///  ],
    ///  "properties": {
    ///    "asset": {
    ///      "examples": [
    ///        "USDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "displayPriority": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "duration": {
    ///      "examples": [
    ///        90
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "interestPerLot": {
    ///      "examples": [
    ///        "1.35810000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "interestRate": {
    ///      "examples": [
    ///        "0.05510000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "lotSize": {
    ///      "examples": [
    ///        "100.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "lotsLowLimit": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "lotsPurchased": {
    ///      "examples": [
    ///        74155
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "lotsUpLimit": {
    ///      "examples": [
    ///        80000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "maxLotsPerUser": {
    ///      "examples": [
    ///        2000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "needKyc": {
    ///      "type": "boolean"
    ///    },
    ///    "projectId": {
    ///      "examples": [
    ///        "CUSDT90DAYSS001"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "projectName": {
    ///      "examples": [
    ///        "USDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "examples": [
    ///        "PURCHASING"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "examples": [
    ///        "CUSTOMIZED_FIXED"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "withAreaLimitation": {
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct LendingProjectListResponseItem {
        pub asset: String,
        #[serde(rename = "displayPriority")]
        pub display_priority: i64,
        pub duration: i64,
        #[serde(rename = "interestPerLot")]
        pub interest_per_lot: String,
        #[serde(rename = "interestRate")]
        pub interest_rate: String,
        #[serde(rename = "lotSize")]
        pub lot_size: String,
        #[serde(rename = "lotsLowLimit")]
        pub lots_low_limit: i64,
        #[serde(rename = "lotsPurchased")]
        pub lots_purchased: i64,
        #[serde(rename = "lotsUpLimit")]
        pub lots_up_limit: i64,
        #[serde(rename = "maxLotsPerUser")]
        pub max_lots_per_user: i64,
        #[serde(rename = "needKyc")]
        pub need_kyc: bool,
        #[serde(rename = "projectId")]
        pub project_id: String,
        #[serde(rename = "projectName")]
        pub project_name: String,
        pub status: String,
        #[serde(rename = "type")]
        pub type_: String,
        #[serde(rename = "withAreaLimitation")]
        pub with_area_limitation: bool,
    }
    impl From<&LendingProjectListResponseItem> for LendingProjectListResponseItem {
        fn from(value: &LendingProjectListResponseItem) -> Self {
            value.clone()
        }
    }
    ///LendingProjectListSortBy
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "START_TIME",
    ///    "LOT_SIZE",
    ///    "INTEREST_RATE",
    ///    "DURATION"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum LendingProjectListSortBy {
        #[serde(rename = "START_TIME")]
        StartTime,
        #[serde(rename = "LOT_SIZE")]
        LotSize,
        #[serde(rename = "INTEREST_RATE")]
        InterestRate,
        #[serde(rename = "DURATION")]
        Duration,
    }
    impl From<&LendingProjectListSortBy> for LendingProjectListSortBy {
        fn from(value: &LendingProjectListSortBy) -> Self {
            value.clone()
        }
    }
    impl ToString for LendingProjectListSortBy {
        fn to_string(&self) -> String {
            match *self {
                Self::StartTime => "START_TIME".to_string(),
                Self::LotSize => "LOT_SIZE".to_string(),
                Self::InterestRate => "INTEREST_RATE".to_string(),
                Self::Duration => "DURATION".to_string(),
            }
        }
    }
    impl std::str::FromStr for LendingProjectListSortBy {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "START_TIME" => Ok(Self::StartTime),
                "LOT_SIZE" => Ok(Self::LotSize),
                "INTEREST_RATE" => Ok(Self::InterestRate),
                "DURATION" => Ok(Self::Duration),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for LendingProjectListSortBy {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for LendingProjectListSortBy {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for LendingProjectListSortBy {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///LendingProjectListStatus
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "ALL",
    ///    "SUBSCRIBABLE",
    ///    "UNSUBSCRIBABLE"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum LendingProjectListStatus {
        #[serde(rename = "ALL")]
        All,
        #[serde(rename = "SUBSCRIBABLE")]
        Subscribable,
        #[serde(rename = "UNSUBSCRIBABLE")]
        Unsubscribable,
    }
    impl From<&LendingProjectListStatus> for LendingProjectListStatus {
        fn from(value: &LendingProjectListStatus) -> Self {
            value.clone()
        }
    }
    impl ToString for LendingProjectListStatus {
        fn to_string(&self) -> String {
            match *self {
                Self::All => "ALL".to_string(),
                Self::Subscribable => "SUBSCRIBABLE".to_string(),
                Self::Unsubscribable => "UNSUBSCRIBABLE".to_string(),
            }
        }
    }
    impl std::str::FromStr for LendingProjectListStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "ALL" => Ok(Self::All),
                "SUBSCRIBABLE" => Ok(Self::Subscribable),
                "UNSUBSCRIBABLE" => Ok(Self::Unsubscribable),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for LendingProjectListStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for LendingProjectListStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for LendingProjectListStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///LendingProjectListType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "ACTIVITY",
    ///    "CUSTOMIZED_FIXED"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum LendingProjectListType {
        #[serde(rename = "ACTIVITY")]
        Activity,
        #[serde(rename = "CUSTOMIZED_FIXED")]
        CustomizedFixed,
    }
    impl From<&LendingProjectListType> for LendingProjectListType {
        fn from(value: &LendingProjectListType) -> Self {
            value.clone()
        }
    }
    impl ToString for LendingProjectListType {
        fn to_string(&self) -> String {
            match *self {
                Self::Activity => "ACTIVITY".to_string(),
                Self::CustomizedFixed => "CUSTOMIZED_FIXED".to_string(),
            }
        }
    }
    impl std::str::FromStr for LendingProjectListType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "ACTIVITY" => Ok(Self::Activity),
                "CUSTOMIZED_FIXED" => Ok(Self::CustomizedFixed),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for LendingProjectListType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for LendingProjectListType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for LendingProjectListType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///LendingProjectPositionListResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "asset",
    ///    "canTransfer",
    ///    "createTimestamp",
    ///    "duration",
    ///    "endTime",
    ///    "interest",
    ///    "interestRate",
    ///    "lot",
    ///    "positionId",
    ///    "principal",
    ///    "projectId",
    ///    "projectName",
    ///    "purchaseTime",
    ///    "redeemDate",
    ///    "startTime",
    ///    "status",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "asset": {
    ///      "examples": [
    ///        "USDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "canTransfer": {
    ///      "type": "boolean"
    ///    },
    ///    "createTimestamp": {
    ///      "examples": [
    ///        1587010770000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "duration": {
    ///      "examples": [
    ///        14
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "endTime": {
    ///      "examples": [
    ///        1588291200000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "interest": {
    ///      "examples": [
    ///        "0.19950000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "interestRate": {
    ///      "examples": [
    ///        "0.05201250"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "lot": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "positionId": {
    ///      "examples": [
    ///        51724
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "principal": {
    ///      "examples": [
    ///        "100.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "projectId": {
    ///      "examples": [
    ///        "CUSDT14DAYSS001"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "projectName": {
    ///      "examples": [
    ///        "USDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "purchaseTime": {
    ///      "examples": [
    ///        1587010771000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "redeemDate": {
    ///      "examples": [
    ///        "2020-05-01"
    ///      ],
    ///      "type": "string",
    ///      "format": "date"
    ///    },
    ///    "startTime": {
    ///      "examples": [
    ///        1587081600000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "status": {
    ///      "examples": [
    ///        "HOLDING"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "examples": [
    ///        "CUSTOMIZED_FIXED"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct LendingProjectPositionListResponseItem {
        pub asset: String,
        #[serde(rename = "canTransfer")]
        pub can_transfer: bool,
        #[serde(rename = "createTimestamp")]
        pub create_timestamp: i64,
        pub duration: i64,
        #[serde(rename = "endTime")]
        pub end_time: i64,
        pub interest: String,
        #[serde(rename = "interestRate")]
        pub interest_rate: String,
        pub lot: i64,
        #[serde(rename = "positionId")]
        pub position_id: i64,
        pub principal: String,
        #[serde(rename = "projectId")]
        pub project_id: String,
        #[serde(rename = "projectName")]
        pub project_name: String,
        #[serde(rename = "purchaseTime")]
        pub purchase_time: i64,
        #[serde(rename = "redeemDate")]
        pub redeem_date: crate::DateRfc3339,
        #[serde(rename = "startTime")]
        pub start_time: i64,
        pub status: String,
        #[serde(rename = "type")]
        pub type_: String,
    }
    impl From<&LendingProjectPositionListResponseItem>
    for LendingProjectPositionListResponseItem {
        fn from(value: &LendingProjectPositionListResponseItem) -> Self {
            value.clone()
        }
    }
    ///LendingProjectPositionListStatus
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "ALL",
    ///    "SUBSCRIBABLE",
    ///    "UNSUBSCRIBABLE"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum LendingProjectPositionListStatus {
        #[serde(rename = "ALL")]
        All,
        #[serde(rename = "SUBSCRIBABLE")]
        Subscribable,
        #[serde(rename = "UNSUBSCRIBABLE")]
        Unsubscribable,
    }
    impl From<&LendingProjectPositionListStatus> for LendingProjectPositionListStatus {
        fn from(value: &LendingProjectPositionListStatus) -> Self {
            value.clone()
        }
    }
    impl ToString for LendingProjectPositionListStatus {
        fn to_string(&self) -> String {
            match *self {
                Self::All => "ALL".to_string(),
                Self::Subscribable => "SUBSCRIBABLE".to_string(),
                Self::Unsubscribable => "UNSUBSCRIBABLE".to_string(),
            }
        }
    }
    impl std::str::FromStr for LendingProjectPositionListStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "ALL" => Ok(Self::All),
                "SUBSCRIBABLE" => Ok(Self::Subscribable),
                "UNSUBSCRIBABLE" => Ok(Self::Unsubscribable),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for LendingProjectPositionListStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for LendingProjectPositionListStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for LendingProjectPositionListStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///LoanAdjustLtvDirection
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "ADDITIONAL"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "ADDITIONAL",
    ///    "REDUCED"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum LoanAdjustLtvDirection {
        #[serde(rename = "ADDITIONAL")]
        Additional,
        #[serde(rename = "REDUCED")]
        Reduced,
    }
    impl From<&LoanAdjustLtvDirection> for LoanAdjustLtvDirection {
        fn from(value: &LoanAdjustLtvDirection) -> Self {
            value.clone()
        }
    }
    impl ToString for LoanAdjustLtvDirection {
        fn to_string(&self) -> String {
            match *self {
                Self::Additional => "ADDITIONAL".to_string(),
                Self::Reduced => "REDUCED".to_string(),
            }
        }
    }
    impl std::str::FromStr for LoanAdjustLtvDirection {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "ADDITIONAL" => Ok(Self::Additional),
                "REDUCED" => Ok(Self::Reduced),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for LoanAdjustLtvDirection {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for LoanAdjustLtvDirection {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for LoanAdjustLtvDirection {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///LoanAdjustLtvResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "collateralCoin",
    ///    "currentLTV",
    ///    "direction",
    ///    "loanCoin"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "examples": [
    ///        "5.235"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "collateralCoin": {
    ///      "examples": [
    ///        "BNB"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "currentLTV": {
    ///      "examples": [
    ///        "0.52"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "direction": {
    ///      "examples": [
    ///        "ADDITIONAL"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "loanCoin": {
    ///      "examples": [
    ///        "BUSD"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct LoanAdjustLtvResponse {
        pub amount: String,
        #[serde(rename = "collateralCoin")]
        pub collateral_coin: String,
        #[serde(rename = "currentLTV")]
        pub current_ltv: String,
        pub direction: String,
        #[serde(rename = "loanCoin")]
        pub loan_coin: String,
    }
    impl From<&LoanAdjustLtvResponse> for LoanAdjustLtvResponse {
        fn from(value: &LoanAdjustLtvResponse) -> Self {
            value.clone()
        }
    }
    ///LoanBorrowHistoryResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "rows",
    ///    "total"
    ///  ],
    ///  "properties": {
    ///    "rows": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "borrowTime",
    ///          "collateralCoin",
    ///          "hourlyInterestRate",
    ///          "initialCollateralAmount",
    ///          "initialLoanAmount",
    ///          "loanCoin",
    ///          "loanTerm",
    ///          "orderId",
    ///          "status"
    ///        ],
    ///        "properties": {
    ///          "borrowTime": {
    ///            "examples": [
    ///              1575018510000
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "collateralCoin": {
    ///            "examples": [
    ///              "BNB"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "hourlyInterestRate": {
    ///            "examples": [
    ///              "0.000057"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "initialCollateralAmount": {
    ///            "examples": [
    ///              "49.27565492"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "initialLoanAmount": {
    ///            "examples": [
    ///              "10000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "loanCoin": {
    ///            "examples": [
    ///              "BUSD"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "loanTerm": {
    ///            "examples": [
    ///              "7"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "orderId": {
    ///            "examples": [
    ///              100000001
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "status": {
    ///            "examples": [
    ///              "Accruing_Interest, Overdue, Liquidating, Repaying, Repaid, Liquidated, Pending, Failed"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "total": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct LoanBorrowHistoryResponse {
        pub rows: Vec<LoanBorrowHistoryResponseRowsItem>,
        pub total: i32,
    }
    impl From<&LoanBorrowHistoryResponse> for LoanBorrowHistoryResponse {
        fn from(value: &LoanBorrowHistoryResponse) -> Self {
            value.clone()
        }
    }
    ///LoanBorrowHistoryResponseRowsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "borrowTime",
    ///    "collateralCoin",
    ///    "hourlyInterestRate",
    ///    "initialCollateralAmount",
    ///    "initialLoanAmount",
    ///    "loanCoin",
    ///    "loanTerm",
    ///    "orderId",
    ///    "status"
    ///  ],
    ///  "properties": {
    ///    "borrowTime": {
    ///      "examples": [
    ///        1575018510000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "collateralCoin": {
    ///      "examples": [
    ///        "BNB"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "hourlyInterestRate": {
    ///      "examples": [
    ///        "0.000057"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "initialCollateralAmount": {
    ///      "examples": [
    ///        "49.27565492"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "initialLoanAmount": {
    ///      "examples": [
    ///        "10000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "loanCoin": {
    ///      "examples": [
    ///        "BUSD"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "loanTerm": {
    ///      "examples": [
    ///        "7"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "orderId": {
    ///      "examples": [
    ///        100000001
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "status": {
    ///      "examples": [
    ///        "Accruing_Interest, Overdue, Liquidating, Repaying, Repaid, Liquidated, Pending, Failed"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct LoanBorrowHistoryResponseRowsItem {
        #[serde(rename = "borrowTime")]
        pub borrow_time: i64,
        #[serde(rename = "collateralCoin")]
        pub collateral_coin: String,
        #[serde(rename = "hourlyInterestRate")]
        pub hourly_interest_rate: String,
        #[serde(rename = "initialCollateralAmount")]
        pub initial_collateral_amount: String,
        #[serde(rename = "initialLoanAmount")]
        pub initial_loan_amount: String,
        #[serde(rename = "loanCoin")]
        pub loan_coin: String,
        #[serde(rename = "loanTerm")]
        pub loan_term: String,
        #[serde(rename = "orderId")]
        pub order_id: i64,
        pub status: String,
    }
    impl From<&LoanBorrowHistoryResponseRowsItem> for LoanBorrowHistoryResponseRowsItem {
        fn from(value: &LoanBorrowHistoryResponseRowsItem) -> Self {
            value.clone()
        }
    }
    ///LoanBorrowResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "collateralAmount",
    ///    "collateralCoin",
    ///    "hourlyInterestRate",
    ///    "loanAmount",
    ///    "loanCoin",
    ///    "orderId"
    ///  ],
    ///  "properties": {
    ///    "collateralAmount": {
    ///      "examples": [
    ///        "50.5"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "collateralCoin": {
    ///      "examples": [
    ///        "BNB"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "hourlyInterestRate": {
    ///      "examples": [
    ///        "0.001234"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "loanAmount": {
    ///      "examples": [
    ///        "100.5"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "loanCoin": {
    ///      "examples": [
    ///        "BUSD"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "orderId": {
    ///      "examples": [
    ///        "100000001"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct LoanBorrowResponse {
        #[serde(rename = "collateralAmount")]
        pub collateral_amount: String,
        #[serde(rename = "collateralCoin")]
        pub collateral_coin: String,
        #[serde(rename = "hourlyInterestRate")]
        pub hourly_interest_rate: String,
        #[serde(rename = "loanAmount")]
        pub loan_amount: String,
        #[serde(rename = "loanCoin")]
        pub loan_coin: String,
        #[serde(rename = "orderId")]
        pub order_id: String,
    }
    impl From<&LoanBorrowResponse> for LoanBorrowResponse {
        fn from(value: &LoanBorrowResponse) -> Self {
            value.clone()
        }
    }
    ///LoanCollateralDataResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "rows",
    ///    "total"
    ///  ],
    ///  "properties": {
    ///    "rows": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "collateralCoin",
    ///          "initialLTV",
    ///          "liquidationLTV",
    ///          "marginCallLTV",
    ///          "maxLimit",
    ///          "vipLevel"
    ///        ],
    ///        "properties": {
    ///          "collateralCoin": {
    ///            "examples": [
    ///              "BNB"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "initialLTV": {
    ///            "examples": [
    ///              "0.65"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "liquidationLTV": {
    ///            "examples": [
    ///              "0.83"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "marginCallLTV": {
    ///            "examples": [
    ///              "0.75"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "maxLimit": {
    ///            "examples": [
    ///              "1000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "vipLevel": {
    ///            "examples": [
    ///              1
    ///            ],
    ///            "type": "integer",
    ///            "format": "int32"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "total": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct LoanCollateralDataResponse {
        pub rows: Vec<LoanCollateralDataResponseRowsItem>,
        pub total: i32,
    }
    impl From<&LoanCollateralDataResponse> for LoanCollateralDataResponse {
        fn from(value: &LoanCollateralDataResponse) -> Self {
            value.clone()
        }
    }
    ///LoanCollateralDataResponseRowsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "collateralCoin",
    ///    "initialLTV",
    ///    "liquidationLTV",
    ///    "marginCallLTV",
    ///    "maxLimit",
    ///    "vipLevel"
    ///  ],
    ///  "properties": {
    ///    "collateralCoin": {
    ///      "examples": [
    ///        "BNB"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "initialLTV": {
    ///      "examples": [
    ///        "0.65"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "liquidationLTV": {
    ///      "examples": [
    ///        "0.83"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "marginCallLTV": {
    ///      "examples": [
    ///        "0.75"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "maxLimit": {
    ///      "examples": [
    ///        "1000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "vipLevel": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct LoanCollateralDataResponseRowsItem {
        #[serde(rename = "collateralCoin")]
        pub collateral_coin: String,
        #[serde(rename = "initialLTV")]
        pub initial_ltv: String,
        #[serde(rename = "liquidationLTV")]
        pub liquidation_ltv: String,
        #[serde(rename = "marginCallLTV")]
        pub margin_call_ltv: String,
        #[serde(rename = "maxLimit")]
        pub max_limit: String,
        #[serde(rename = "vipLevel")]
        pub vip_level: i32,
    }
    impl From<&LoanCollateralDataResponseRowsItem>
    for LoanCollateralDataResponseRowsItem {
        fn from(value: &LoanCollateralDataResponseRowsItem) -> Self {
            value.clone()
        }
    }
    ///LoanCustomizeMarginCallResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "rows",
    ///    "total"
    ///  ],
    ///  "properties": {
    ///    "rows": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "afterMarginCall",
    ///          "collateralCoin",
    ///          "customizeTime",
    ///          "orderId",
    ///          "preMarginCall"
    ///        ],
    ///        "properties": {
    ///          "afterMarginCall": {
    ///            "examples": [
    ///              "0.7"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "collateralCoin": {
    ///            "examples": [
    ///              "BNB"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "customizeTime": {
    ///            "examples": [
    ///              1575018510000
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "orderId": {
    ///            "examples": [
    ///              "100000001"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "preMarginCall": {
    ///            "examples": [
    ///              "0.8"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "total": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct LoanCustomizeMarginCallResponse {
        pub rows: Vec<LoanCustomizeMarginCallResponseRowsItem>,
        pub total: i32,
    }
    impl From<&LoanCustomizeMarginCallResponse> for LoanCustomizeMarginCallResponse {
        fn from(value: &LoanCustomizeMarginCallResponse) -> Self {
            value.clone()
        }
    }
    ///LoanCustomizeMarginCallResponseRowsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "afterMarginCall",
    ///    "collateralCoin",
    ///    "customizeTime",
    ///    "orderId",
    ///    "preMarginCall"
    ///  ],
    ///  "properties": {
    ///    "afterMarginCall": {
    ///      "examples": [
    ///        "0.7"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "collateralCoin": {
    ///      "examples": [
    ///        "BNB"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "customizeTime": {
    ///      "examples": [
    ///        1575018510000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "orderId": {
    ///      "examples": [
    ///        "100000001"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "preMarginCall": {
    ///      "examples": [
    ///        "0.8"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct LoanCustomizeMarginCallResponseRowsItem {
        #[serde(rename = "afterMarginCall")]
        pub after_margin_call: String,
        #[serde(rename = "collateralCoin")]
        pub collateral_coin: String,
        #[serde(rename = "customizeTime")]
        pub customize_time: i64,
        #[serde(rename = "orderId")]
        pub order_id: String,
        #[serde(rename = "preMarginCall")]
        pub pre_margin_call: String,
    }
    impl From<&LoanCustomizeMarginCallResponseRowsItem>
    for LoanCustomizeMarginCallResponseRowsItem {
        fn from(value: &LoanCustomizeMarginCallResponseRowsItem) -> Self {
            value.clone()
        }
    }
    ///LoanFlexibleAdjustLtvDirection
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "ADDITIONAL",
    ///    "REDUCED"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum LoanFlexibleAdjustLtvDirection {
        #[serde(rename = "ADDITIONAL")]
        Additional,
        #[serde(rename = "REDUCED")]
        Reduced,
    }
    impl From<&LoanFlexibleAdjustLtvDirection> for LoanFlexibleAdjustLtvDirection {
        fn from(value: &LoanFlexibleAdjustLtvDirection) -> Self {
            value.clone()
        }
    }
    impl ToString for LoanFlexibleAdjustLtvDirection {
        fn to_string(&self) -> String {
            match *self {
                Self::Additional => "ADDITIONAL".to_string(),
                Self::Reduced => "REDUCED".to_string(),
            }
        }
    }
    impl std::str::FromStr for LoanFlexibleAdjustLtvDirection {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "ADDITIONAL" => Ok(Self::Additional),
                "REDUCED" => Ok(Self::Reduced),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for LoanFlexibleAdjustLtvDirection {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for LoanFlexibleAdjustLtvDirection {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for LoanFlexibleAdjustLtvDirection {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///LoanFlexibleAdjustLtvResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "adjustmentAmount",
    ///    "collateralCoin",
    ///    "currentLTV",
    ///    "direction",
    ///    "loanCoin",
    ///    "status"
    ///  ],
    ///  "properties": {
    ///    "adjustmentAmount": {
    ///      "examples": [
    ///        "5.235"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "collateralCoin": {
    ///      "examples": [
    ///        "BNB"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "currentLTV": {
    ///      "examples": [
    ///        "0.235"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "direction": {
    ///      "examples": [
    ///        "ADDITIONAL"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "loanCoin": {
    ///      "examples": [
    ///        "BUSD"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "examples": [
    ///        "Succeeds"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct LoanFlexibleAdjustLtvResponse {
        #[serde(rename = "adjustmentAmount")]
        pub adjustment_amount: String,
        #[serde(rename = "collateralCoin")]
        pub collateral_coin: String,
        #[serde(rename = "currentLTV")]
        pub current_ltv: String,
        pub direction: String,
        #[serde(rename = "loanCoin")]
        pub loan_coin: String,
        pub status: String,
    }
    impl From<&LoanFlexibleAdjustLtvResponse> for LoanFlexibleAdjustLtvResponse {
        fn from(value: &LoanFlexibleAdjustLtvResponse) -> Self {
            value.clone()
        }
    }
    ///LoanFlexibleBorrowHistoryResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "rows",
    ///    "total"
    ///  ],
    ///  "properties": {
    ///    "rows": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "borrowTime",
    ///          "collateralCoin",
    ///          "initialCollateralAmount",
    ///          "initialLoanAmount",
    ///          "loanCoin",
    ///          "status"
    ///        ],
    ///        "properties": {
    ///          "borrowTime": {
    ///            "examples": [
    ///              1575018510000
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "collateralCoin": {
    ///            "examples": [
    ///              "BNB"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "initialCollateralAmount": {
    ///            "examples": [
    ///              "49.27565492"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "initialLoanAmount": {
    ///            "examples": [
    ///              "10000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "loanCoin": {
    ///            "examples": [
    ///              "BUSD"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "status": {
    ///            "examples": [
    ///              "Succeeds"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "total": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct LoanFlexibleBorrowHistoryResponse {
        pub rows: Vec<LoanFlexibleBorrowHistoryResponseRowsItem>,
        pub total: i64,
    }
    impl From<&LoanFlexibleBorrowHistoryResponse> for LoanFlexibleBorrowHistoryResponse {
        fn from(value: &LoanFlexibleBorrowHistoryResponse) -> Self {
            value.clone()
        }
    }
    ///LoanFlexibleBorrowHistoryResponseRowsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "borrowTime",
    ///    "collateralCoin",
    ///    "initialCollateralAmount",
    ///    "initialLoanAmount",
    ///    "loanCoin",
    ///    "status"
    ///  ],
    ///  "properties": {
    ///    "borrowTime": {
    ///      "examples": [
    ///        1575018510000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "collateralCoin": {
    ///      "examples": [
    ///        "BNB"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "initialCollateralAmount": {
    ///      "examples": [
    ///        "49.27565492"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "initialLoanAmount": {
    ///      "examples": [
    ///        "10000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "loanCoin": {
    ///      "examples": [
    ///        "BUSD"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "examples": [
    ///        "Succeeds"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct LoanFlexibleBorrowHistoryResponseRowsItem {
        #[serde(rename = "borrowTime")]
        pub borrow_time: i64,
        #[serde(rename = "collateralCoin")]
        pub collateral_coin: String,
        #[serde(rename = "initialCollateralAmount")]
        pub initial_collateral_amount: String,
        #[serde(rename = "initialLoanAmount")]
        pub initial_loan_amount: String,
        #[serde(rename = "loanCoin")]
        pub loan_coin: String,
        pub status: String,
    }
    impl From<&LoanFlexibleBorrowHistoryResponseRowsItem>
    for LoanFlexibleBorrowHistoryResponseRowsItem {
        fn from(value: &LoanFlexibleBorrowHistoryResponseRowsItem) -> Self {
            value.clone()
        }
    }
    ///LoanFlexibleBorrowResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "collateralAmount",
    ///    "loanAmount",
    ///    "loanCoin",
    ///    "status"
    ///  ],
    ///  "properties": {
    ///    "collateralAmount": {
    ///      "examples": [
    ///        "50.5"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "collateralCoin": {
    ///      "examples": [
    ///        "BNB"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "loanAmount": {
    ///      "examples": [
    ///        "100.5"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "loanCoin": {
    ///      "examples": [
    ///        "BUSD"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "examples": [
    ///        "Succeeds"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct LoanFlexibleBorrowResponse {
        #[serde(rename = "collateralAmount")]
        pub collateral_amount: String,
        #[serde(
            rename = "collateralCoin",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub collateral_coin: Option<String>,
        #[serde(rename = "loanAmount")]
        pub loan_amount: String,
        #[serde(rename = "loanCoin")]
        pub loan_coin: String,
        pub status: String,
    }
    impl From<&LoanFlexibleBorrowResponse> for LoanFlexibleBorrowResponse {
        fn from(value: &LoanFlexibleBorrowResponse) -> Self {
            value.clone()
        }
    }
    ///LoanFlexibleCollateralDataResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "rows",
    ///    "total"
    ///  ],
    ///  "properties": {
    ///    "rows": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "collateralCoin",
    ///          "initialLTV",
    ///          "liquidationLTV",
    ///          "marginCallLTV",
    ///          "maxLimit"
    ///        ],
    ///        "properties": {
    ///          "collateralCoin": {
    ///            "examples": [
    ///              "BNB"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "initialLTV": {
    ///            "examples": [
    ///              "0.01"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "liquidationLTV": {
    ///            "examples": [
    ///              "0.8"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "marginCallLTV": {
    ///            "examples": [
    ///              "0.7"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "maxLimit": {
    ///            "examples": [
    ///              "1000000"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "total": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct LoanFlexibleCollateralDataResponse {
        pub rows: Vec<LoanFlexibleCollateralDataResponseRowsItem>,
        pub total: i32,
    }
    impl From<&LoanFlexibleCollateralDataResponse>
    for LoanFlexibleCollateralDataResponse {
        fn from(value: &LoanFlexibleCollateralDataResponse) -> Self {
            value.clone()
        }
    }
    ///LoanFlexibleCollateralDataResponseRowsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "collateralCoin",
    ///    "initialLTV",
    ///    "liquidationLTV",
    ///    "marginCallLTV",
    ///    "maxLimit"
    ///  ],
    ///  "properties": {
    ///    "collateralCoin": {
    ///      "examples": [
    ///        "BNB"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "initialLTV": {
    ///      "examples": [
    ///        "0.01"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "liquidationLTV": {
    ///      "examples": [
    ///        "0.8"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "marginCallLTV": {
    ///      "examples": [
    ///        "0.7"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "maxLimit": {
    ///      "examples": [
    ///        "1000000"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct LoanFlexibleCollateralDataResponseRowsItem {
        #[serde(rename = "collateralCoin")]
        pub collateral_coin: String,
        #[serde(rename = "initialLTV")]
        pub initial_ltv: String,
        #[serde(rename = "liquidationLTV")]
        pub liquidation_ltv: String,
        #[serde(rename = "marginCallLTV")]
        pub margin_call_ltv: String,
        #[serde(rename = "maxLimit")]
        pub max_limit: String,
    }
    impl From<&LoanFlexibleCollateralDataResponseRowsItem>
    for LoanFlexibleCollateralDataResponseRowsItem {
        fn from(value: &LoanFlexibleCollateralDataResponseRowsItem) -> Self {
            value.clone()
        }
    }
    ///LoanFlexibleLoanableDataResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "rows",
    ///    "total"
    ///  ],
    ///  "properties": {
    ///    "rows": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "flexibleInterestRate",
    ///          "flexibleMaxLimit",
    ///          "flexibleMinLimit",
    ///          "loanCoin"
    ///        ],
    ///        "properties": {
    ///          "flexibleInterestRate": {
    ///            "examples": [
    ///              "0.01"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "flexibleMaxLimit": {
    ///            "examples": [
    ///              "1000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "flexibleMinLimit": {
    ///            "examples": [
    ///              "100"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "loanCoin": {
    ///            "examples": [
    ///              "BNB"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "total": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct LoanFlexibleLoanableDataResponse {
        pub rows: Vec<LoanFlexibleLoanableDataResponseRowsItem>,
        pub total: i32,
    }
    impl From<&LoanFlexibleLoanableDataResponse> for LoanFlexibleLoanableDataResponse {
        fn from(value: &LoanFlexibleLoanableDataResponse) -> Self {
            value.clone()
        }
    }
    ///LoanFlexibleLoanableDataResponseRowsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "flexibleInterestRate",
    ///    "flexibleMaxLimit",
    ///    "flexibleMinLimit",
    ///    "loanCoin"
    ///  ],
    ///  "properties": {
    ///    "flexibleInterestRate": {
    ///      "examples": [
    ///        "0.01"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "flexibleMaxLimit": {
    ///      "examples": [
    ///        "1000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "flexibleMinLimit": {
    ///      "examples": [
    ///        "100"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "loanCoin": {
    ///      "examples": [
    ///        "BNB"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct LoanFlexibleLoanableDataResponseRowsItem {
        #[serde(rename = "flexibleInterestRate")]
        pub flexible_interest_rate: String,
        #[serde(rename = "flexibleMaxLimit")]
        pub flexible_max_limit: String,
        #[serde(rename = "flexibleMinLimit")]
        pub flexible_min_limit: String,
        #[serde(rename = "loanCoin")]
        pub loan_coin: String,
    }
    impl From<&LoanFlexibleLoanableDataResponseRowsItem>
    for LoanFlexibleLoanableDataResponseRowsItem {
        fn from(value: &LoanFlexibleLoanableDataResponseRowsItem) -> Self {
            value.clone()
        }
    }
    ///LoanFlexibleLtvAdjustmentHistoryResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "rows",
    ///    "total"
    ///  ],
    ///  "properties": {
    ///    "rows": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "adjustTime",
    ///          "afterLTV",
    ///          "collateralAmount",
    ///          "collateralCoin",
    ///          "direction",
    ///          "loanCoin",
    ///          "preLTV"
    ///        ],
    ///        "properties": {
    ///          "adjustTime": {
    ///            "examples": [
    ///              1575018510000
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "afterLTV": {
    ///            "examples": [
    ///              "0.5"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "collateralAmount": {
    ///            "examples": [
    ///              "5.75"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "collateralCoin": {
    ///            "examples": [
    ///              "BNB"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "direction": {
    ///            "examples": [
    ///              "ADDITIONAL"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "loanCoin": {
    ///            "examples": [
    ///              "BNB"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "preLTV": {
    ///            "examples": [
    ///              "0.83"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "total": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct LoanFlexibleLtvAdjustmentHistoryResponse {
        pub rows: Vec<LoanFlexibleLtvAdjustmentHistoryResponseRowsItem>,
        pub total: i32,
    }
    impl From<&LoanFlexibleLtvAdjustmentHistoryResponse>
    for LoanFlexibleLtvAdjustmentHistoryResponse {
        fn from(value: &LoanFlexibleLtvAdjustmentHistoryResponse) -> Self {
            value.clone()
        }
    }
    ///LoanFlexibleLtvAdjustmentHistoryResponseRowsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "adjustTime",
    ///    "afterLTV",
    ///    "collateralAmount",
    ///    "collateralCoin",
    ///    "direction",
    ///    "loanCoin",
    ///    "preLTV"
    ///  ],
    ///  "properties": {
    ///    "adjustTime": {
    ///      "examples": [
    ///        1575018510000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "afterLTV": {
    ///      "examples": [
    ///        "0.5"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "collateralAmount": {
    ///      "examples": [
    ///        "5.75"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "collateralCoin": {
    ///      "examples": [
    ///        "BNB"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "direction": {
    ///      "examples": [
    ///        "ADDITIONAL"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "loanCoin": {
    ///      "examples": [
    ///        "BNB"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "preLTV": {
    ///      "examples": [
    ///        "0.83"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct LoanFlexibleLtvAdjustmentHistoryResponseRowsItem {
        #[serde(rename = "adjustTime")]
        pub adjust_time: i64,
        #[serde(rename = "afterLTV")]
        pub after_ltv: String,
        #[serde(rename = "collateralAmount")]
        pub collateral_amount: String,
        #[serde(rename = "collateralCoin")]
        pub collateral_coin: String,
        pub direction: String,
        #[serde(rename = "loanCoin")]
        pub loan_coin: String,
        #[serde(rename = "preLTV")]
        pub pre_ltv: String,
    }
    impl From<&LoanFlexibleLtvAdjustmentHistoryResponseRowsItem>
    for LoanFlexibleLtvAdjustmentHistoryResponseRowsItem {
        fn from(value: &LoanFlexibleLtvAdjustmentHistoryResponseRowsItem) -> Self {
            value.clone()
        }
    }
    ///LoanFlexibleOngoingOrdersResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "rows",
    ///    "total"
    ///  ],
    ///  "properties": {
    ///    "rows": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "collateralAmount",
    ///          "collateralCoin",
    ///          "currentLTV",
    ///          "loanCoin",
    ///          "totalDebt"
    ///        ],
    ///        "properties": {
    ///          "collateralAmount": {
    ///            "examples": [
    ///              "49.27565492"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "collateralCoin": {
    ///            "examples": [
    ///              "BNB"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "currentLTV": {
    ///            "examples": [
    ///              "0.57"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "loanCoin": {
    ///            "examples": [
    ///              "BUSD"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "totalDebt": {
    ///            "examples": [
    ///              "10000"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "total": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct LoanFlexibleOngoingOrdersResponse {
        pub rows: Vec<LoanFlexibleOngoingOrdersResponseRowsItem>,
        pub total: i32,
    }
    impl From<&LoanFlexibleOngoingOrdersResponse> for LoanFlexibleOngoingOrdersResponse {
        fn from(value: &LoanFlexibleOngoingOrdersResponse) -> Self {
            value.clone()
        }
    }
    ///LoanFlexibleOngoingOrdersResponseRowsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "collateralAmount",
    ///    "collateralCoin",
    ///    "currentLTV",
    ///    "loanCoin",
    ///    "totalDebt"
    ///  ],
    ///  "properties": {
    ///    "collateralAmount": {
    ///      "examples": [
    ///        "49.27565492"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "collateralCoin": {
    ///      "examples": [
    ///        "BNB"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "currentLTV": {
    ///      "examples": [
    ///        "0.57"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "loanCoin": {
    ///      "examples": [
    ///        "BUSD"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalDebt": {
    ///      "examples": [
    ///        "10000"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct LoanFlexibleOngoingOrdersResponseRowsItem {
        #[serde(rename = "collateralAmount")]
        pub collateral_amount: String,
        #[serde(rename = "collateralCoin")]
        pub collateral_coin: String,
        #[serde(rename = "currentLTV")]
        pub current_ltv: String,
        #[serde(rename = "loanCoin")]
        pub loan_coin: String,
        #[serde(rename = "totalDebt")]
        pub total_debt: String,
    }
    impl From<&LoanFlexibleOngoingOrdersResponseRowsItem>
    for LoanFlexibleOngoingOrdersResponseRowsItem {
        fn from(value: &LoanFlexibleOngoingOrdersResponseRowsItem) -> Self {
            value.clone()
        }
    }
    ///LoanFlexibleRepayHistoryResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "rows",
    ///    "total"
    ///  ],
    ///  "properties": {
    ///    "rows": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "collateralCoin",
    ///          "collateralReturn",
    ///          "loanCoin",
    ///          "repayAmount",
    ///          "repayStatus",
    ///          "repayTime"
    ///        ],
    ///        "properties": {
    ///          "collateralCoin": {
    ///            "examples": [
    ///              "BNB"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "collateralReturn": {
    ///            "examples": [
    ///              "100"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "loanCoin": {
    ///            "examples": [
    ///              "BUSD"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "repayAmount": {
    ///            "examples": [
    ///              "10000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "repayStatus": {
    ///            "examples": [
    ///              "Repaid"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "repayTime": {
    ///            "examples": [
    ///              1575018510000
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "total": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct LoanFlexibleRepayHistoryResponse {
        pub rows: Vec<LoanFlexibleRepayHistoryResponseRowsItem>,
        pub total: i32,
    }
    impl From<&LoanFlexibleRepayHistoryResponse> for LoanFlexibleRepayHistoryResponse {
        fn from(value: &LoanFlexibleRepayHistoryResponse) -> Self {
            value.clone()
        }
    }
    ///LoanFlexibleRepayHistoryResponseRowsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "collateralCoin",
    ///    "collateralReturn",
    ///    "loanCoin",
    ///    "repayAmount",
    ///    "repayStatus",
    ///    "repayTime"
    ///  ],
    ///  "properties": {
    ///    "collateralCoin": {
    ///      "examples": [
    ///        "BNB"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "collateralReturn": {
    ///      "examples": [
    ///        "100"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "loanCoin": {
    ///      "examples": [
    ///        "BUSD"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "repayAmount": {
    ///      "examples": [
    ///        "10000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "repayStatus": {
    ///      "examples": [
    ///        "Repaid"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "repayTime": {
    ///      "examples": [
    ///        1575018510000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct LoanFlexibleRepayHistoryResponseRowsItem {
        #[serde(rename = "collateralCoin")]
        pub collateral_coin: String,
        #[serde(rename = "collateralReturn")]
        pub collateral_return: String,
        #[serde(rename = "loanCoin")]
        pub loan_coin: String,
        #[serde(rename = "repayAmount")]
        pub repay_amount: String,
        #[serde(rename = "repayStatus")]
        pub repay_status: String,
        #[serde(rename = "repayTime")]
        pub repay_time: i64,
    }
    impl From<&LoanFlexibleRepayHistoryResponseRowsItem>
    for LoanFlexibleRepayHistoryResponseRowsItem {
        fn from(value: &LoanFlexibleRepayHistoryResponseRowsItem) -> Self {
            value.clone()
        }
    }
    ///LoanFlexibleRepayResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "collateralCoin",
    ///    "currentLTV",
    ///    "fullRepayment",
    ///    "loanCoin",
    ///    "remainingCollateral",
    ///    "remainingDebt",
    ///    "repayStatus"
    ///  ],
    ///  "properties": {
    ///    "collateralCoin": {
    ///      "examples": [
    ///        "BNB"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "currentLTV": {
    ///      "examples": [
    ///        "50.5"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "fullRepayment": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "loanCoin": {
    ///      "examples": [
    ///        "BUSD"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "remainingCollateral": {
    ///      "examples": [
    ///        "50.5"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "remainingDebt": {
    ///      "examples": [
    ///        "50.5"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "repayStatus": {
    ///      "examples": [
    ///        "Repaid"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct LoanFlexibleRepayResponse {
        #[serde(rename = "collateralCoin")]
        pub collateral_coin: String,
        #[serde(rename = "currentLTV")]
        pub current_ltv: String,
        #[serde(rename = "fullRepayment")]
        pub full_repayment: bool,
        #[serde(rename = "loanCoin")]
        pub loan_coin: String,
        #[serde(rename = "remainingCollateral")]
        pub remaining_collateral: String,
        #[serde(rename = "remainingDebt")]
        pub remaining_debt: String,
        #[serde(rename = "repayStatus")]
        pub repay_status: String,
    }
    impl From<&LoanFlexibleRepayResponse> for LoanFlexibleRepayResponse {
        fn from(value: &LoanFlexibleRepayResponse) -> Self {
            value.clone()
        }
    }
    ///LoanIncomeResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "asset",
    ///    "timestamp",
    ///    "tranId",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "examples": [
    ///        "100"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "asset": {
    ///      "examples": [
    ///        "BUSD"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "timestamp": {
    ///      "examples": [
    ///        1633771139847
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "tranId": {
    ///      "examples": [
    ///        "80423589583"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "examples": [
    ///        "borrowIn"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct LoanIncomeResponseItem {
        pub amount: String,
        pub asset: String,
        pub timestamp: i64,
        #[serde(rename = "tranId")]
        pub tran_id: String,
        #[serde(rename = "type")]
        pub type_: String,
    }
    impl From<&LoanIncomeResponseItem> for LoanIncomeResponseItem {
        fn from(value: &LoanIncomeResponseItem) -> Self {
            value.clone()
        }
    }
    ///LoanIncomeType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "borrowIn",
    ///    "collateralSpent",
    ///    "repayAmount",
    ///    "collateralReturn",
    ///    "addCollateral",
    ///    "removeCollateral",
    ///    "collateralReturnAfterLiquidation"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum LoanIncomeType {
        #[serde(rename = "borrowIn")]
        BorrowIn,
        #[serde(rename = "collateralSpent")]
        CollateralSpent,
        #[serde(rename = "repayAmount")]
        RepayAmount,
        #[serde(rename = "collateralReturn")]
        CollateralReturn,
        #[serde(rename = "addCollateral")]
        AddCollateral,
        #[serde(rename = "removeCollateral")]
        RemoveCollateral,
        #[serde(rename = "collateralReturnAfterLiquidation")]
        CollateralReturnAfterLiquidation,
    }
    impl From<&LoanIncomeType> for LoanIncomeType {
        fn from(value: &LoanIncomeType) -> Self {
            value.clone()
        }
    }
    impl ToString for LoanIncomeType {
        fn to_string(&self) -> String {
            match *self {
                Self::BorrowIn => "borrowIn".to_string(),
                Self::CollateralSpent => "collateralSpent".to_string(),
                Self::RepayAmount => "repayAmount".to_string(),
                Self::CollateralReturn => "collateralReturn".to_string(),
                Self::AddCollateral => "addCollateral".to_string(),
                Self::RemoveCollateral => "removeCollateral".to_string(),
                Self::CollateralReturnAfterLiquidation => {
                    "collateralReturnAfterLiquidation".to_string()
                }
            }
        }
    }
    impl std::str::FromStr for LoanIncomeType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "borrowIn" => Ok(Self::BorrowIn),
                "collateralSpent" => Ok(Self::CollateralSpent),
                "repayAmount" => Ok(Self::RepayAmount),
                "collateralReturn" => Ok(Self::CollateralReturn),
                "addCollateral" => Ok(Self::AddCollateral),
                "removeCollateral" => Ok(Self::RemoveCollateral),
                "collateralReturnAfterLiquidation" => {
                    Ok(Self::CollateralReturnAfterLiquidation)
                }
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for LoanIncomeType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for LoanIncomeType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for LoanIncomeType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///LoanLoanableDataResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "rows",
    ///    "total"
    ///  ],
    ///  "properties": {
    ///    "rows": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "_14dDailyInterestRate",
    ///          "_14dHourlyInterestRate",
    ///          "_180dDailyInterestRate",
    ///          "_180dHourlyInterestRate",
    ///          "_30dDailyInterestRate",
    ///          "_30dHourlyInterestRate",
    ///          "_7dDailyInterestRate",
    ///          "_7dHourlyInterestRate",
    ///          "_90dDailyInterestRate",
    ///          "_90dHourlyInterestRate",
    ///          "loanCoin",
    ///          "maxLimit",
    ///          "minLimit",
    ///          "vipLevel"
    ///        ],
    ///        "properties": {
    ///          "_14dDailyInterestRate": {
    ///            "examples": [
    ///              "0.000118"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "_14dHourlyInterestRate": {
    ///            "examples": [
    ///              "0.00000491"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "_180dDailyInterestRate": {
    ///            "examples": [
    ///              "0.000151"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "_180dHourlyInterestRate": {
    ///            "examples": [
    ///              "0.00000631"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "_30dDailyInterestRate": {
    ///            "examples": [
    ///              "0.000136"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "_30dHourlyInterestRate": {
    ///            "examples": [
    ///              "0.00000567"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "_7dDailyInterestRate": {
    ///            "examples": [
    ///              "0.000118"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "_7dHourlyInterestRate": {
    ///            "examples": [
    ///              "0.00000491"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "_90dDailyInterestRate": {
    ///            "examples": [
    ///              "0.000143"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "_90dHourlyInterestRate": {
    ///            "examples": [
    ///              "0.00000596"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "loanCoin": {
    ///            "examples": [
    ///              "BUSD"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "maxLimit": {
    ///            "examples": [
    ///              "1000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "minLimit": {
    ///            "examples": [
    ///              "100"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "vipLevel": {
    ///            "examples": [
    ///              1
    ///            ],
    ///            "type": "integer",
    ///            "format": "int32"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "total": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct LoanLoanableDataResponse {
        pub rows: Vec<LoanLoanableDataResponseRowsItem>,
        pub total: i32,
    }
    impl From<&LoanLoanableDataResponse> for LoanLoanableDataResponse {
        fn from(value: &LoanLoanableDataResponse) -> Self {
            value.clone()
        }
    }
    ///LoanLoanableDataResponseRowsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "_14dDailyInterestRate",
    ///    "_14dHourlyInterestRate",
    ///    "_180dDailyInterestRate",
    ///    "_180dHourlyInterestRate",
    ///    "_30dDailyInterestRate",
    ///    "_30dHourlyInterestRate",
    ///    "_7dDailyInterestRate",
    ///    "_7dHourlyInterestRate",
    ///    "_90dDailyInterestRate",
    ///    "_90dHourlyInterestRate",
    ///    "loanCoin",
    ///    "maxLimit",
    ///    "minLimit",
    ///    "vipLevel"
    ///  ],
    ///  "properties": {
    ///    "_14dDailyInterestRate": {
    ///      "examples": [
    ///        "0.000118"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "_14dHourlyInterestRate": {
    ///      "examples": [
    ///        "0.00000491"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "_180dDailyInterestRate": {
    ///      "examples": [
    ///        "0.000151"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "_180dHourlyInterestRate": {
    ///      "examples": [
    ///        "0.00000631"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "_30dDailyInterestRate": {
    ///      "examples": [
    ///        "0.000136"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "_30dHourlyInterestRate": {
    ///      "examples": [
    ///        "0.00000567"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "_7dDailyInterestRate": {
    ///      "examples": [
    ///        "0.000118"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "_7dHourlyInterestRate": {
    ///      "examples": [
    ///        "0.00000491"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "_90dDailyInterestRate": {
    ///      "examples": [
    ///        "0.000143"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "_90dHourlyInterestRate": {
    ///      "examples": [
    ///        "0.00000596"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "loanCoin": {
    ///      "examples": [
    ///        "BUSD"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "maxLimit": {
    ///      "examples": [
    ///        "1000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "minLimit": {
    ///      "examples": [
    ///        "100"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "vipLevel": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct LoanLoanableDataResponseRowsItem {
        #[serde(rename = "_14dDailyInterestRate")]
        pub _14d_daily_interest_rate: String,
        #[serde(rename = "_14dHourlyInterestRate")]
        pub _14d_hourly_interest_rate: String,
        #[serde(rename = "_180dDailyInterestRate")]
        pub _180d_daily_interest_rate: String,
        #[serde(rename = "_180dHourlyInterestRate")]
        pub _180d_hourly_interest_rate: String,
        #[serde(rename = "_30dDailyInterestRate")]
        pub _30d_daily_interest_rate: String,
        #[serde(rename = "_30dHourlyInterestRate")]
        pub _30d_hourly_interest_rate: String,
        #[serde(rename = "_7dDailyInterestRate")]
        pub _7d_daily_interest_rate: String,
        #[serde(rename = "_7dHourlyInterestRate")]
        pub _7d_hourly_interest_rate: String,
        #[serde(rename = "_90dDailyInterestRate")]
        pub _90d_daily_interest_rate: String,
        #[serde(rename = "_90dHourlyInterestRate")]
        pub _90d_hourly_interest_rate: String,
        #[serde(rename = "loanCoin")]
        pub loan_coin: String,
        #[serde(rename = "maxLimit")]
        pub max_limit: String,
        #[serde(rename = "minLimit")]
        pub min_limit: String,
        #[serde(rename = "vipLevel")]
        pub vip_level: i32,
    }
    impl From<&LoanLoanableDataResponseRowsItem> for LoanLoanableDataResponseRowsItem {
        fn from(value: &LoanLoanableDataResponseRowsItem) -> Self {
            value.clone()
        }
    }
    ///LoanLtvAdjustmentHistoryResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "rows",
    ///    "total"
    ///  ],
    ///  "properties": {
    ///    "rows": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "adjustTime",
    ///          "afterLTV",
    ///          "amount",
    ///          "collateralCoin",
    ///          "direction",
    ///          "loanCoin",
    ///          "orderId",
    ///          "preLTV"
    ///        ],
    ///        "properties": {
    ///          "adjustTime": {
    ///            "examples": [
    ///              1575018510000
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "afterLTV": {
    ///            "examples": [
    ///              "0.56"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "amount": {
    ///            "examples": [
    ///              "5.235"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "collateralCoin": {
    ///            "examples": [
    ///              "BNB"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "direction": {
    ///            "examples": [
    ///              "ADDITIONAL"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "loanCoin": {
    ///            "examples": [
    ///              "BUSD"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "orderId": {
    ///            "examples": [
    ///              756783308056935434
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "preLTV": {
    ///            "examples": [
    ///              "0.78"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "total": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct LoanLtvAdjustmentHistoryResponse {
        pub rows: Vec<LoanLtvAdjustmentHistoryResponseRowsItem>,
        pub total: i32,
    }
    impl From<&LoanLtvAdjustmentHistoryResponse> for LoanLtvAdjustmentHistoryResponse {
        fn from(value: &LoanLtvAdjustmentHistoryResponse) -> Self {
            value.clone()
        }
    }
    ///LoanLtvAdjustmentHistoryResponseRowsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "adjustTime",
    ///    "afterLTV",
    ///    "amount",
    ///    "collateralCoin",
    ///    "direction",
    ///    "loanCoin",
    ///    "orderId",
    ///    "preLTV"
    ///  ],
    ///  "properties": {
    ///    "adjustTime": {
    ///      "examples": [
    ///        1575018510000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "afterLTV": {
    ///      "examples": [
    ///        "0.56"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "amount": {
    ///      "examples": [
    ///        "5.235"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "collateralCoin": {
    ///      "examples": [
    ///        "BNB"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "direction": {
    ///      "examples": [
    ///        "ADDITIONAL"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "loanCoin": {
    ///      "examples": [
    ///        "BUSD"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "orderId": {
    ///      "examples": [
    ///        756783308056935434
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "preLTV": {
    ///      "examples": [
    ///        "0.78"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct LoanLtvAdjustmentHistoryResponseRowsItem {
        #[serde(rename = "adjustTime")]
        pub adjust_time: i64,
        #[serde(rename = "afterLTV")]
        pub after_ltv: String,
        pub amount: String,
        #[serde(rename = "collateralCoin")]
        pub collateral_coin: String,
        pub direction: String,
        #[serde(rename = "loanCoin")]
        pub loan_coin: String,
        #[serde(rename = "orderId")]
        pub order_id: i64,
        #[serde(rename = "preLTV")]
        pub pre_ltv: String,
    }
    impl From<&LoanLtvAdjustmentHistoryResponseRowsItem>
    for LoanLtvAdjustmentHistoryResponseRowsItem {
        fn from(value: &LoanLtvAdjustmentHistoryResponseRowsItem) -> Self {
            value.clone()
        }
    }
    ///LoanOngoingOrdersResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "rows",
    ///    "total"
    ///  ],
    ///  "properties": {
    ///    "rows": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "collateralAmount",
    ///          "collateralCoin",
    ///          "currentLTV",
    ///          "expirationTime",
    ///          "loanCoin",
    ///          "orderId",
    ///          "residualInterest",
    ///          "totalDebt"
    ///        ],
    ///        "properties": {
    ///          "collateralAmount": {
    ///            "examples": [
    ///              "49.27565492"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "collateralCoin": {
    ///            "examples": [
    ///              "BNB"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "currentLTV": {
    ///            "examples": [
    ///              "0.57"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "expirationTime": {
    ///            "examples": [
    ///              1575018510000
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "loanCoin": {
    ///            "examples": [
    ///              "BUSD"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "orderId": {
    ///            "examples": [
    ///              100000001
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "residualInterest": {
    ///            "examples": [
    ///              "10.27687923"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "totalDebt": {
    ///            "examples": [
    ///              "10000"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "total": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct LoanOngoingOrdersResponse {
        pub rows: Vec<LoanOngoingOrdersResponseRowsItem>,
        pub total: i32,
    }
    impl From<&LoanOngoingOrdersResponse> for LoanOngoingOrdersResponse {
        fn from(value: &LoanOngoingOrdersResponse) -> Self {
            value.clone()
        }
    }
    ///LoanOngoingOrdersResponseRowsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "collateralAmount",
    ///    "collateralCoin",
    ///    "currentLTV",
    ///    "expirationTime",
    ///    "loanCoin",
    ///    "orderId",
    ///    "residualInterest",
    ///    "totalDebt"
    ///  ],
    ///  "properties": {
    ///    "collateralAmount": {
    ///      "examples": [
    ///        "49.27565492"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "collateralCoin": {
    ///      "examples": [
    ///        "BNB"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "currentLTV": {
    ///      "examples": [
    ///        "0.57"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "expirationTime": {
    ///      "examples": [
    ///        1575018510000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "loanCoin": {
    ///      "examples": [
    ///        "BUSD"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "orderId": {
    ///      "examples": [
    ///        100000001
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "residualInterest": {
    ///      "examples": [
    ///        "10.27687923"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalDebt": {
    ///      "examples": [
    ///        "10000"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct LoanOngoingOrdersResponseRowsItem {
        #[serde(rename = "collateralAmount")]
        pub collateral_amount: String,
        #[serde(rename = "collateralCoin")]
        pub collateral_coin: String,
        #[serde(rename = "currentLTV")]
        pub current_ltv: String,
        #[serde(rename = "expirationTime")]
        pub expiration_time: i64,
        #[serde(rename = "loanCoin")]
        pub loan_coin: String,
        #[serde(rename = "orderId")]
        pub order_id: i64,
        #[serde(rename = "residualInterest")]
        pub residual_interest: String,
        #[serde(rename = "totalDebt")]
        pub total_debt: String,
    }
    impl From<&LoanOngoingOrdersResponseRowsItem> for LoanOngoingOrdersResponseRowsItem {
        fn from(value: &LoanOngoingOrdersResponseRowsItem) -> Self {
            value.clone()
        }
    }
    ///LoanRepayCollateralRateResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "collateralCoin",
    ///    "loanCoin",
    ///    "rate",
    ///    "repayAmount"
    ///  ],
    ///  "properties": {
    ///    "collateralCoin": {
    ///      "examples": [
    ///        "BUSD"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "loanCoin": {
    ///      "examples": [
    ///        "BUSD"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "rate": {
    ///      "description": "rate of collateral coin/loan coin",
    ///      "examples": [
    ///        "300.36781234"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "repayAmount": {
    ///      "examples": [
    ///        "1000"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct LoanRepayCollateralRateResponse {
        #[serde(rename = "collateralCoin")]
        pub collateral_coin: String,
        #[serde(rename = "loanCoin")]
        pub loan_coin: String,
        ///rate of collateral coin/loan coin
        pub rate: String,
        #[serde(rename = "repayAmount")]
        pub repay_amount: String,
    }
    impl From<&LoanRepayCollateralRateResponse> for LoanRepayCollateralRateResponse {
        fn from(value: &LoanRepayCollateralRateResponse) -> Self {
            value.clone()
        }
    }
    ///LoanRepayHistoryResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "rows",
    ///    "total"
    ///  ],
    ///  "properties": {
    ///    "rows": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "collateralCoin",
    ///          "collateralReturn",
    ///          "collateralUsed",
    ///          "loanCoin",
    ///          "orderId",
    ///          "repayAmount",
    ///          "repayStatus",
    ///          "repayTime",
    ///          "repayType"
    ///        ],
    ///        "properties": {
    ///          "collateralCoin": {
    ///            "examples": [
    ///              "BNB"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "collateralReturn": {
    ///            "examples": [
    ///              "49.27565492"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "collateralUsed": {
    ///            "examples": [
    ///              "0"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "loanCoin": {
    ///            "examples": [
    ///              "BUSD"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "orderId": {
    ///            "examples": [
    ///              756783308056935434
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "repayAmount": {
    ///            "examples": [
    ///              "10000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "repayStatus": {
    ///            "description": "'repayType': '1' // 1 for 'repay with borrowed coin', 2 for 'repay with collateral' 'repayStatus': 'Repaid' // Repaid, Repaying, Failed",
    ///            "examples": [
    ///              "Repaid"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "repayTime": {
    ///            "examples": [
    ///              1575018510000
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "repayType": {
    ///            "examples": [
    ///              "1"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "total": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct LoanRepayHistoryResponse {
        pub rows: Vec<LoanRepayHistoryResponseRowsItem>,
        pub total: i32,
    }
    impl From<&LoanRepayHistoryResponse> for LoanRepayHistoryResponse {
        fn from(value: &LoanRepayHistoryResponse) -> Self {
            value.clone()
        }
    }
    ///LoanRepayHistoryResponseRowsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "collateralCoin",
    ///    "collateralReturn",
    ///    "collateralUsed",
    ///    "loanCoin",
    ///    "orderId",
    ///    "repayAmount",
    ///    "repayStatus",
    ///    "repayTime",
    ///    "repayType"
    ///  ],
    ///  "properties": {
    ///    "collateralCoin": {
    ///      "examples": [
    ///        "BNB"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "collateralReturn": {
    ///      "examples": [
    ///        "49.27565492"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "collateralUsed": {
    ///      "examples": [
    ///        "0"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "loanCoin": {
    ///      "examples": [
    ///        "BUSD"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "orderId": {
    ///      "examples": [
    ///        756783308056935434
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "repayAmount": {
    ///      "examples": [
    ///        "10000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "repayStatus": {
    ///      "description": "'repayType': '1' // 1 for 'repay with borrowed coin', 2 for 'repay with collateral' 'repayStatus': 'Repaid' // Repaid, Repaying, Failed",
    ///      "examples": [
    ///        "Repaid"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "repayTime": {
    ///      "examples": [
    ///        1575018510000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "repayType": {
    ///      "examples": [
    ///        "1"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct LoanRepayHistoryResponseRowsItem {
        #[serde(rename = "collateralCoin")]
        pub collateral_coin: String,
        #[serde(rename = "collateralReturn")]
        pub collateral_return: String,
        #[serde(rename = "collateralUsed")]
        pub collateral_used: String,
        #[serde(rename = "loanCoin")]
        pub loan_coin: String,
        #[serde(rename = "orderId")]
        pub order_id: i64,
        #[serde(rename = "repayAmount")]
        pub repay_amount: String,
        ///'repayType': '1' // 1 for 'repay with borrowed coin', 2 for 'repay with collateral' 'repayStatus': 'Repaid' // Repaid, Repaying, Failed
        #[serde(rename = "repayStatus")]
        pub repay_status: String,
        #[serde(rename = "repayTime")]
        pub repay_time: i64,
        #[serde(rename = "repayType")]
        pub repay_type: String,
    }
    impl From<&LoanRepayHistoryResponseRowsItem> for LoanRepayHistoryResponseRowsItem {
        fn from(value: &LoanRepayHistoryResponseRowsItem) -> Self {
            value.clone()
        }
    }
    ///LoanRepayResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/repaymentInfo"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/repaymentInfo2"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    #[serde(untagged)]
    pub enum LoanRepayResponse {
        Info(RepaymentInfo),
        Info2(RepaymentInfo2),
    }
    impl From<&LoanRepayResponse> for LoanRepayResponse {
        fn from(value: &LoanRepayResponse) -> Self {
            value.clone()
        }
    }
    impl From<RepaymentInfo> for LoanRepayResponse {
        fn from(value: RepaymentInfo) -> Self {
            Self::Info(value)
        }
    }
    impl From<RepaymentInfo2> for LoanRepayResponse {
        fn from(value: RepaymentInfo2) -> Self {
            Self::Info2(value)
        }
    }
    ///LoanVipBorrowIsFlexibleRate
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "TRUE"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "TRUE",
    ///    "FALSE"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum LoanVipBorrowIsFlexibleRate {
        #[serde(rename = "TRUE")]
        True,
        #[serde(rename = "FALSE")]
        False,
    }
    impl From<&LoanVipBorrowIsFlexibleRate> for LoanVipBorrowIsFlexibleRate {
        fn from(value: &LoanVipBorrowIsFlexibleRate) -> Self {
            value.clone()
        }
    }
    impl ToString for LoanVipBorrowIsFlexibleRate {
        fn to_string(&self) -> String {
            match *self {
                Self::True => "TRUE".to_string(),
                Self::False => "FALSE".to_string(),
            }
        }
    }
    impl std::str::FromStr for LoanVipBorrowIsFlexibleRate {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "TRUE" => Ok(Self::True),
                "FALSE" => Ok(Self::False),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for LoanVipBorrowIsFlexibleRate {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for LoanVipBorrowIsFlexibleRate {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for LoanVipBorrowIsFlexibleRate {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///LoanVipBorrowResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "collateralAccountId",
    ///    "collateralCoin",
    ///    "isFlexibleRate",
    ///    "loanAccountId",
    ///    "loanAmount",
    ///    "loanCoin",
    ///    "requestId"
    ///  ],
    ///  "properties": {
    ///    "collateralAccountId": {
    ///      "examples": [
    ///        "12345678,12345678,12345678"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "collateralCoin": {
    ///      "examples": [
    ///        "BUSD,USDT,ETH"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "isFlexibleRate": {
    ///      "examples": [
    ///        "No"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "loanAccountId": {
    ///      "examples": [
    ///        "12345678"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "loanAmount": {
    ///      "examples": [
    ///        "100.55"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "loanCoin": {
    ///      "examples": [
    ///        "BTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "loanTerm": {
    ///      "examples": [
    ///        "30"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "requestId": {
    ///      "examples": [
    ///        "12345678"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct LoanVipBorrowResponse {
        #[serde(rename = "collateralAccountId")]
        pub collateral_account_id: String,
        #[serde(rename = "collateralCoin")]
        pub collateral_coin: String,
        #[serde(rename = "isFlexibleRate")]
        pub is_flexible_rate: String,
        #[serde(rename = "loanAccountId")]
        pub loan_account_id: String,
        #[serde(rename = "loanAmount")]
        pub loan_amount: String,
        #[serde(rename = "loanCoin")]
        pub loan_coin: String,
        #[serde(rename = "loanTerm", default, skip_serializing_if = "Option::is_none")]
        pub loan_term: Option<String>,
        #[serde(rename = "requestId")]
        pub request_id: String,
    }
    impl From<&LoanVipBorrowResponse> for LoanVipBorrowResponse {
        fn from(value: &LoanVipBorrowResponse) -> Self {
            value.clone()
        }
    }
    ///LoanVipCollateralAccountResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "rows",
    ///    "total"
    ///  ],
    ///  "properties": {
    ///    "rows": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "collateralAccountId",
    ///          "collateralCoin",
    ///          "collateralValue"
    ///        ],
    ///        "properties": {
    ///          "collateralAccountId": {
    ///            "examples": [
    ///              "12345678"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "collateralCoin": {
    ///            "examples": [
    ///              "BNB,BTC,ETH"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "collateralValue": {
    ///            "description": "locked collateral value shown in USD value",
    ///            "examples": [
    ///              "500.27565492"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "total": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct LoanVipCollateralAccountResponse {
        pub rows: Vec<LoanVipCollateralAccountResponseRowsItem>,
        pub total: i32,
    }
    impl From<&LoanVipCollateralAccountResponse> for LoanVipCollateralAccountResponse {
        fn from(value: &LoanVipCollateralAccountResponse) -> Self {
            value.clone()
        }
    }
    ///LoanVipCollateralAccountResponseRowsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "collateralAccountId",
    ///    "collateralCoin",
    ///    "collateralValue"
    ///  ],
    ///  "properties": {
    ///    "collateralAccountId": {
    ///      "examples": [
    ///        "12345678"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "collateralCoin": {
    ///      "examples": [
    ///        "BNB,BTC,ETH"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "collateralValue": {
    ///      "description": "locked collateral value shown in USD value",
    ///      "examples": [
    ///        "500.27565492"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct LoanVipCollateralAccountResponseRowsItem {
        #[serde(rename = "collateralAccountId")]
        pub collateral_account_id: String,
        #[serde(rename = "collateralCoin")]
        pub collateral_coin: String,
        ///locked collateral value shown in USD value
        #[serde(rename = "collateralValue")]
        pub collateral_value: String,
    }
    impl From<&LoanVipCollateralAccountResponseRowsItem>
    for LoanVipCollateralAccountResponseRowsItem {
        fn from(value: &LoanVipCollateralAccountResponseRowsItem) -> Self {
            value.clone()
        }
    }
    ///LoanVipCollateralDataResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "rows",
    ///    "total"
    ///  ],
    ///  "properties": {
    ///    "rows": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "_1stCollateralRange",
    ///          "_1stCollateralRatio",
    ///          "_2ndCollateralRange",
    ///          "_2ndCollateralRatio",
    ///          "_3rdCollateralRange",
    ///          "_3rdCollateralRatio",
    ///          "_4thCollateralRange",
    ///          "_4thCollateralRatio",
    ///          "collateralCoin"
    ///        ],
    ///        "properties": {
    ///          "_1stCollateralRange": {
    ///            "examples": [
    ///              "1-10000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "_1stCollateralRatio": {
    ///            "examples": [
    ///              "100%"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "_2ndCollateralRange": {
    ///            "examples": [
    ///              "10000000-100000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "_2ndCollateralRatio": {
    ///            "examples": [
    ///              "80%"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "_3rdCollateralRange": {
    ///            "examples": [
    ///              "100000000-1000000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "_3rdCollateralRatio": {
    ///            "examples": [
    ///              "60%"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "_4thCollateralRange": {
    ///            "examples": [
    ///              ">10000000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "_4thCollateralRatio": {
    ///            "examples": [
    ///              "0%"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "collateralCoin": {
    ///            "examples": [
    ///              "BUSD"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "total": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct LoanVipCollateralDataResponse {
        pub rows: Vec<LoanVipCollateralDataResponseRowsItem>,
        pub total: i32,
    }
    impl From<&LoanVipCollateralDataResponse> for LoanVipCollateralDataResponse {
        fn from(value: &LoanVipCollateralDataResponse) -> Self {
            value.clone()
        }
    }
    ///LoanVipCollateralDataResponseRowsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "_1stCollateralRange",
    ///    "_1stCollateralRatio",
    ///    "_2ndCollateralRange",
    ///    "_2ndCollateralRatio",
    ///    "_3rdCollateralRange",
    ///    "_3rdCollateralRatio",
    ///    "_4thCollateralRange",
    ///    "_4thCollateralRatio",
    ///    "collateralCoin"
    ///  ],
    ///  "properties": {
    ///    "_1stCollateralRange": {
    ///      "examples": [
    ///        "1-10000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "_1stCollateralRatio": {
    ///      "examples": [
    ///        "100%"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "_2ndCollateralRange": {
    ///      "examples": [
    ///        "10000000-100000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "_2ndCollateralRatio": {
    ///      "examples": [
    ///        "80%"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "_3rdCollateralRange": {
    ///      "examples": [
    ///        "100000000-1000000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "_3rdCollateralRatio": {
    ///      "examples": [
    ///        "60%"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "_4thCollateralRange": {
    ///      "examples": [
    ///        ">10000000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "_4thCollateralRatio": {
    ///      "examples": [
    ///        "0%"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "collateralCoin": {
    ///      "examples": [
    ///        "BUSD"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct LoanVipCollateralDataResponseRowsItem {
        #[serde(rename = "_1stCollateralRange")]
        pub _1st_collateral_range: String,
        #[serde(rename = "_1stCollateralRatio")]
        pub _1st_collateral_ratio: String,
        #[serde(rename = "_2ndCollateralRange")]
        pub _2nd_collateral_range: String,
        #[serde(rename = "_2ndCollateralRatio")]
        pub _2nd_collateral_ratio: String,
        #[serde(rename = "_3rdCollateralRange")]
        pub _3rd_collateral_range: String,
        #[serde(rename = "_3rdCollateralRatio")]
        pub _3rd_collateral_ratio: String,
        #[serde(rename = "_4thCollateralRange")]
        pub _4th_collateral_range: String,
        #[serde(rename = "_4thCollateralRatio")]
        pub _4th_collateral_ratio: String,
        #[serde(rename = "collateralCoin")]
        pub collateral_coin: String,
    }
    impl From<&LoanVipCollateralDataResponseRowsItem>
    for LoanVipCollateralDataResponseRowsItem {
        fn from(value: &LoanVipCollateralDataResponseRowsItem) -> Self {
            value.clone()
        }
    }
    ///LoanVipLoanableDataResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "rows",
    ///    "total"
    ///  ],
    ///  "properties": {
    ///    "rows": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "_30dDailyInterestRate",
    ///          "_30dYearlyInterestRate",
    ///          "_60dDailyInterestRate",
    ///          "_60dYearlyInterestRate",
    ///          "_flexibleDailyInterestRate",
    ///          "_flexibleYearlyInterestRate",
    ///          "loanCoin",
    ///          "maxLimit",
    ///          "minLimit",
    ///          "vipLevel"
    ///        ],
    ///        "properties": {
    ///          "_30dDailyInterestRate": {
    ///            "examples": [
    ///              "0.000136"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "_30dYearlyInterestRate": {
    ///            "examples": [
    ///              "0.03450"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "_60dDailyInterestRate": {
    ///            "examples": [
    ///              "0.000145"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "_60dYearlyInterestRate": {
    ///            "examples": [
    ///              "0.04103"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "_flexibleDailyInterestRate": {
    ///            "examples": [
    ///              "0.001503"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "_flexibleYearlyInterestRate": {
    ///            "examples": [
    ///              "0.548595"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "loanCoin": {
    ///            "examples": [
    ///              "BUSD"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "maxLimit": {
    ///            "examples": [
    ///              "1000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "minLimit": {
    ///            "examples": [
    ///              "100"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "vipLevel": {
    ///            "examples": [
    ///              1
    ///            ],
    ///            "type": "integer"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "total": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct LoanVipLoanableDataResponse {
        pub rows: Vec<LoanVipLoanableDataResponseRowsItem>,
        pub total: i64,
    }
    impl From<&LoanVipLoanableDataResponse> for LoanVipLoanableDataResponse {
        fn from(value: &LoanVipLoanableDataResponse) -> Self {
            value.clone()
        }
    }
    ///LoanVipLoanableDataResponseRowsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "_30dDailyInterestRate",
    ///    "_30dYearlyInterestRate",
    ///    "_60dDailyInterestRate",
    ///    "_60dYearlyInterestRate",
    ///    "_flexibleDailyInterestRate",
    ///    "_flexibleYearlyInterestRate",
    ///    "loanCoin",
    ///    "maxLimit",
    ///    "minLimit",
    ///    "vipLevel"
    ///  ],
    ///  "properties": {
    ///    "_30dDailyInterestRate": {
    ///      "examples": [
    ///        "0.000136"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "_30dYearlyInterestRate": {
    ///      "examples": [
    ///        "0.03450"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "_60dDailyInterestRate": {
    ///      "examples": [
    ///        "0.000145"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "_60dYearlyInterestRate": {
    ///      "examples": [
    ///        "0.04103"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "_flexibleDailyInterestRate": {
    ///      "examples": [
    ///        "0.001503"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "_flexibleYearlyInterestRate": {
    ///      "examples": [
    ///        "0.548595"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "loanCoin": {
    ///      "examples": [
    ///        "BUSD"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "maxLimit": {
    ///      "examples": [
    ///        "1000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "minLimit": {
    ///      "examples": [
    ///        "100"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "vipLevel": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct LoanVipLoanableDataResponseRowsItem {
        #[serde(rename = "_30dDailyInterestRate")]
        pub _30d_daily_interest_rate: String,
        #[serde(rename = "_30dYearlyInterestRate")]
        pub _30d_yearly_interest_rate: String,
        #[serde(rename = "_60dDailyInterestRate")]
        pub _60d_daily_interest_rate: String,
        #[serde(rename = "_60dYearlyInterestRate")]
        pub _60d_yearly_interest_rate: String,
        #[serde(rename = "_flexibleDailyInterestRate")]
        pub flexible_daily_interest_rate: String,
        #[serde(rename = "_flexibleYearlyInterestRate")]
        pub flexible_yearly_interest_rate: String,
        #[serde(rename = "loanCoin")]
        pub loan_coin: String,
        #[serde(rename = "maxLimit")]
        pub max_limit: String,
        #[serde(rename = "minLimit")]
        pub min_limit: String,
        #[serde(rename = "vipLevel")]
        pub vip_level: i64,
    }
    impl From<&LoanVipLoanableDataResponseRowsItem>
    for LoanVipLoanableDataResponseRowsItem {
        fn from(value: &LoanVipLoanableDataResponseRowsItem) -> Self {
            value.clone()
        }
    }
    ///LoanVipOngoingOrdersResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "rows",
    ///    "total"
    ///  ],
    ///  "properties": {
    ///    "rows": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "collateralAccountId",
    ///          "collateralCoin",
    ///          "collateralValue",
    ///          "currentLTV",
    ///          "expirationTime",
    ///          "loanCoin",
    ///          "loanDate",
    ///          "loanRate",
    ///          "loanTerm",
    ///          "orderId",
    ///          "residualInterest",
    ///          "totalDebt"
    ///        ],
    ///        "properties": {
    ///          "collateralAccountId": {
    ///            "examples": [
    ///              "12345678, 23456789"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "collateralCoin": {
    ///            "examples": [
    ///              "BNB,BTC,ETH"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "collateralValue": {
    ///            "description": "locked collateral value shown in USD value",
    ///            "examples": [
    ///              "25000.27565492"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "currentLTV": {
    ///            "examples": [
    ///              "0.57"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "expirationTime": {
    ///            "examples": [
    ///              1575018510000
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "loanCoin": {
    ///            "examples": [
    ///              "BUSD"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "loanDate": {
    ///            "examples": [
    ///              "1676851200000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "loanRate": {
    ///            "examples": [
    ///              "0.0123"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "loanTerm": {
    ///            "examples": [
    ///              "30days"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "lockedCollateralValue": {
    ///            "examples": [
    ///              "25000.27565492"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "orderId": {
    ///            "examples": [
    ///              100000001
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "residualInterest": {
    ///            "examples": [
    ///              "10.27687923"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "totalCollateralValueAfterHaircut": {
    ///            "examples": [
    ///              "25000.27565492"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "totalDebt": {
    ///            "examples": [
    ///              "10000"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "total": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct LoanVipOngoingOrdersResponse {
        pub rows: Vec<LoanVipOngoingOrdersResponseRowsItem>,
        pub total: i32,
    }
    impl From<&LoanVipOngoingOrdersResponse> for LoanVipOngoingOrdersResponse {
        fn from(value: &LoanVipOngoingOrdersResponse) -> Self {
            value.clone()
        }
    }
    ///LoanVipOngoingOrdersResponseRowsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "collateralAccountId",
    ///    "collateralCoin",
    ///    "collateralValue",
    ///    "currentLTV",
    ///    "expirationTime",
    ///    "loanCoin",
    ///    "loanDate",
    ///    "loanRate",
    ///    "loanTerm",
    ///    "orderId",
    ///    "residualInterest",
    ///    "totalDebt"
    ///  ],
    ///  "properties": {
    ///    "collateralAccountId": {
    ///      "examples": [
    ///        "12345678, 23456789"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "collateralCoin": {
    ///      "examples": [
    ///        "BNB,BTC,ETH"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "collateralValue": {
    ///      "description": "locked collateral value shown in USD value",
    ///      "examples": [
    ///        "25000.27565492"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "currentLTV": {
    ///      "examples": [
    ///        "0.57"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "expirationTime": {
    ///      "examples": [
    ///        1575018510000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "loanCoin": {
    ///      "examples": [
    ///        "BUSD"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "loanDate": {
    ///      "examples": [
    ///        "1676851200000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "loanRate": {
    ///      "examples": [
    ///        "0.0123"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "loanTerm": {
    ///      "examples": [
    ///        "30days"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "lockedCollateralValue": {
    ///      "examples": [
    ///        "25000.27565492"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "orderId": {
    ///      "examples": [
    ///        100000001
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "residualInterest": {
    ///      "examples": [
    ///        "10.27687923"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalCollateralValueAfterHaircut": {
    ///      "examples": [
    ///        "25000.27565492"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalDebt": {
    ///      "examples": [
    ///        "10000"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct LoanVipOngoingOrdersResponseRowsItem {
        #[serde(rename = "collateralAccountId")]
        pub collateral_account_id: String,
        #[serde(rename = "collateralCoin")]
        pub collateral_coin: String,
        ///locked collateral value shown in USD value
        #[serde(rename = "collateralValue")]
        pub collateral_value: String,
        #[serde(rename = "currentLTV")]
        pub current_ltv: String,
        #[serde(rename = "expirationTime")]
        pub expiration_time: i64,
        #[serde(rename = "loanCoin")]
        pub loan_coin: String,
        #[serde(rename = "loanDate")]
        pub loan_date: String,
        #[serde(rename = "loanRate")]
        pub loan_rate: String,
        #[serde(rename = "loanTerm")]
        pub loan_term: String,
        #[serde(
            rename = "lockedCollateralValue",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub locked_collateral_value: Option<String>,
        #[serde(rename = "orderId")]
        pub order_id: i64,
        #[serde(rename = "residualInterest")]
        pub residual_interest: String,
        #[serde(
            rename = "totalCollateralValueAfterHaircut",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub total_collateral_value_after_haircut: Option<String>,
        #[serde(rename = "totalDebt")]
        pub total_debt: String,
    }
    impl From<&LoanVipOngoingOrdersResponseRowsItem>
    for LoanVipOngoingOrdersResponseRowsItem {
        fn from(value: &LoanVipOngoingOrdersResponseRowsItem) -> Self {
            value.clone()
        }
    }
    ///LoanVipRenewResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "collateralAccountId",
    ///    "collateralCoin",
    ///    "loanAccountId",
    ///    "loanAmount",
    ///    "loanCoin",
    ///    "loanTerm"
    ///  ],
    ///  "properties": {
    ///    "collateralAccountId": {
    ///      "examples": [
    ///        "12345677,12345678,12345679"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "collateralCoin": {
    ///      "examples": [
    ///        "BUSD,USDT,ETH"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "loanAccountId": {
    ///      "examples": [
    ///        "12345678"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "loanAmount": {
    ///      "examples": [
    ///        "100.55"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "loanCoin": {
    ///      "examples": [
    ///        "BTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "loanTerm": {
    ///      "examples": [
    ///        "30"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct LoanVipRenewResponse {
        #[serde(rename = "collateralAccountId")]
        pub collateral_account_id: String,
        #[serde(rename = "collateralCoin")]
        pub collateral_coin: String,
        #[serde(rename = "loanAccountId")]
        pub loan_account_id: String,
        #[serde(rename = "loanAmount")]
        pub loan_amount: String,
        #[serde(rename = "loanCoin")]
        pub loan_coin: String,
        #[serde(rename = "loanTerm")]
        pub loan_term: String,
    }
    impl From<&LoanVipRenewResponse> for LoanVipRenewResponse {
        fn from(value: &LoanVipRenewResponse) -> Self {
            value.clone()
        }
    }
    ///LoanVipRepayHistoryResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "rows",
    ///    "total"
    ///  ],
    ///  "properties": {
    ///    "rows": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "collateralCoin",
    ///          "loanCoin",
    ///          "orderId",
    ///          "repayAmount",
    ///          "repayStatus",
    ///          "repayTime"
    ///        ],
    ///        "properties": {
    ///          "collateralCoin": {
    ///            "examples": [
    ///              "BNB,BTC,ETH"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "loanCoin": {
    ///            "examples": [
    ///              "BUSD"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "orderId": {
    ///            "examples": [
    ///              "756783308056935434"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "repayAmount": {
    ///            "examples": [
    ///              "10000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "repayStatus": {
    ///            "description": "Repaid, Repaying, Failed",
    ///            "examples": [
    ///              "Repaid"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "repayTime": {
    ///            "examples": [
    ///              "1575018510000"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "total": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct LoanVipRepayHistoryResponse {
        pub rows: Vec<LoanVipRepayHistoryResponseRowsItem>,
        pub total: i32,
    }
    impl From<&LoanVipRepayHistoryResponse> for LoanVipRepayHistoryResponse {
        fn from(value: &LoanVipRepayHistoryResponse) -> Self {
            value.clone()
        }
    }
    ///LoanVipRepayHistoryResponseRowsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "collateralCoin",
    ///    "loanCoin",
    ///    "orderId",
    ///    "repayAmount",
    ///    "repayStatus",
    ///    "repayTime"
    ///  ],
    ///  "properties": {
    ///    "collateralCoin": {
    ///      "examples": [
    ///        "BNB,BTC,ETH"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "loanCoin": {
    ///      "examples": [
    ///        "BUSD"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "orderId": {
    ///      "examples": [
    ///        "756783308056935434"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "repayAmount": {
    ///      "examples": [
    ///        "10000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "repayStatus": {
    ///      "description": "Repaid, Repaying, Failed",
    ///      "examples": [
    ///        "Repaid"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "repayTime": {
    ///      "examples": [
    ///        "1575018510000"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct LoanVipRepayHistoryResponseRowsItem {
        #[serde(rename = "collateralCoin")]
        pub collateral_coin: String,
        #[serde(rename = "loanCoin")]
        pub loan_coin: String,
        #[serde(rename = "orderId")]
        pub order_id: String,
        #[serde(rename = "repayAmount")]
        pub repay_amount: String,
        ///Repaid, Repaying, Failed
        #[serde(rename = "repayStatus")]
        pub repay_status: String,
        #[serde(rename = "repayTime")]
        pub repay_time: String,
    }
    impl From<&LoanVipRepayHistoryResponseRowsItem>
    for LoanVipRepayHistoryResponseRowsItem {
        fn from(value: &LoanVipRepayHistoryResponseRowsItem) -> Self {
            value.clone()
        }
    }
    ///LoanVipRepayResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "collateralCoin",
    ///    "currentLTV",
    ///    "loanCoin",
    ///    "remainingInterest",
    ///    "remainingPrincipal",
    ///    "repayAmount",
    ///    "repayStatus"
    ///  ],
    ///  "properties": {
    ///    "collateralCoin": {
    ///      "examples": [
    ///        "BNB,BTC,ETH"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "currentLTV": {
    ///      "examples": [
    ///        "0.25"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "loanCoin": {
    ///      "examples": [
    ///        "BUSD"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "remainingInterest": {
    ///      "examples": [
    ///        "0"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "remainingPrincipal": {
    ///      "examples": [
    ///        "100.5"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "repayAmount": {
    ///      "examples": [
    ///        "200.5"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "repayStatus": {
    ///      "description": "Repaid, Repaying, Failed",
    ///      "examples": [
    ///        "Repaid"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct LoanVipRepayResponse {
        #[serde(rename = "collateralCoin")]
        pub collateral_coin: String,
        #[serde(rename = "currentLTV")]
        pub current_ltv: String,
        #[serde(rename = "loanCoin")]
        pub loan_coin: String,
        #[serde(rename = "remainingInterest")]
        pub remaining_interest: String,
        #[serde(rename = "remainingPrincipal")]
        pub remaining_principal: String,
        #[serde(rename = "repayAmount")]
        pub repay_amount: String,
        ///Repaid, Repaying, Failed
        #[serde(rename = "repayStatus")]
        pub repay_status: String,
    }
    impl From<&LoanVipRepayResponse> for LoanVipRepayResponse {
        fn from(value: &LoanVipRepayResponse) -> Self {
            value.clone()
        }
    }
    ///LoanVipRequestDataResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "rows",
    ///    "total"
    ///  ],
    ///  "properties": {
    ///    "rows": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "collateralAccountId",
    ///          "collateralCoin",
    ///          "loanAccountId",
    ///          "loanAmount",
    ///          "loanCoin",
    ///          "loanTerm",
    ///          "orderId",
    ///          "requestId",
    ///          "status"
    ///        ],
    ///        "properties": {
    ///          "collateralAccountId": {
    ///            "examples": [
    ///              "12345678,12345678,12345678"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "collateralCoin": {
    ///            "examples": [
    ///              "BUSD,USDT,ETH"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "loanAccountId": {
    ///            "examples": [
    ///              "12345678"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "loanAmount": {
    ///            "examples": [
    ///              "100.5"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "loanCoin": {
    ///            "examples": [
    ///              "BTC"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "loanTerm": {
    ///            "examples": [
    ///              "30"
    ///            ],
    ///            "type": "integer"
    ///          },
    ///          "orderId": {
    ///            "examples": [
    ///              "12345678"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "requestId": {
    ///            "examples": [
    ///              "12345678"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "status": {
    ///            "examples": [
    ///              "Repaid"
    ///            ],
    ///            "type": "integer"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "total": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct LoanVipRequestDataResponse {
        pub rows: Vec<LoanVipRequestDataResponseRowsItem>,
        pub total: i64,
    }
    impl From<&LoanVipRequestDataResponse> for LoanVipRequestDataResponse {
        fn from(value: &LoanVipRequestDataResponse) -> Self {
            value.clone()
        }
    }
    ///LoanVipRequestDataResponseRowsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "collateralAccountId",
    ///    "collateralCoin",
    ///    "loanAccountId",
    ///    "loanAmount",
    ///    "loanCoin",
    ///    "loanTerm",
    ///    "orderId",
    ///    "requestId",
    ///    "status"
    ///  ],
    ///  "properties": {
    ///    "collateralAccountId": {
    ///      "examples": [
    ///        "12345678,12345678,12345678"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "collateralCoin": {
    ///      "examples": [
    ///        "BUSD,USDT,ETH"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "loanAccountId": {
    ///      "examples": [
    ///        "12345678"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "loanAmount": {
    ///      "examples": [
    ///        "100.5"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "loanCoin": {
    ///      "examples": [
    ///        "BTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "loanTerm": {
    ///      "examples": [
    ///        "30"
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "orderId": {
    ///      "examples": [
    ///        "12345678"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "requestId": {
    ///      "examples": [
    ///        "12345678"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "examples": [
    ///        "Repaid"
    ///      ],
    ///      "type": "integer"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct LoanVipRequestDataResponseRowsItem {
        #[serde(rename = "collateralAccountId")]
        pub collateral_account_id: String,
        #[serde(rename = "collateralCoin")]
        pub collateral_coin: String,
        #[serde(rename = "loanAccountId")]
        pub loan_account_id: String,
        #[serde(rename = "loanAmount")]
        pub loan_amount: String,
        #[serde(rename = "loanCoin")]
        pub loan_coin: String,
        #[serde(rename = "loanTerm")]
        pub loan_term: i64,
        #[serde(rename = "orderId")]
        pub order_id: String,
        #[serde(rename = "requestId")]
        pub request_id: String,
        pub status: i64,
    }
    impl From<&LoanVipRequestDataResponseRowsItem>
    for LoanVipRequestDataResponseRowsItem {
        fn from(value: &LoanVipRequestDataResponseRowsItem) -> Self {
            value.clone()
        }
    }
    ///LoanVipRequestInterestRateResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "asset",
    ///    "flexibleDailyInterestRate",
    ///    "flexibleYearlyInterestRate",
    ///    "time"
    ///  ],
    ///  "properties": {
    ///    "asset": {
    ///      "examples": [
    ///        "BUSD"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "flexibleDailyInterestRate": {
    ///      "examples": [
    ///        "0.001503"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "flexibleYearlyInterestRate": {
    ///      "examples": [
    ///        "0.548595"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "time": {
    ///      "examples": [
    ///        1577233578000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct LoanVipRequestInterestRateResponseItem {
        pub asset: String,
        #[serde(rename = "flexibleDailyInterestRate")]
        pub flexible_daily_interest_rate: String,
        #[serde(rename = "flexibleYearlyInterestRate")]
        pub flexible_yearly_interest_rate: String,
        pub time: i64,
    }
    impl From<&LoanVipRequestInterestRateResponseItem>
    for LoanVipRequestInterestRateResponseItem {
        fn from(value: &LoanVipRequestInterestRateResponseItem) -> Self {
            value.clone()
        }
    }
    ///ManagedSubaccountAccountSnapshotResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "code",
    ///    "msg",
    ///    "snapshotVos"
    ///  ],
    ///  "properties": {
    ///    "code": {
    ///      "examples": [
    ///        200
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    },
    ///    "msg": {
    ///      "examples": [
    ///        ""
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "snapshotVos": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "data",
    ///          "type",
    ///          "updateTime"
    ///        ],
    ///        "properties": {
    ///          "data": {
    ///            "type": "object",
    ///            "required": [
    ///              "balances",
    ///              "totalAssetOfBtc"
    ///            ],
    ///            "properties": {
    ///              "balances": {
    ///                "type": "array",
    ///                "items": {
    ///                  "type": "object",
    ///                  "required": [
    ///                    "asset",
    ///                    "free",
    ///                    "locked"
    ///                  ],
    ///                  "properties": {
    ///                    "asset": {
    ///                      "examples": [
    ///                        "BTC"
    ///                      ],
    ///                      "type": "string"
    ///                    },
    ///                    "free": {
    ///                      "examples": [
    ///                        "0.09905021"
    ///                      ],
    ///                      "type": "string"
    ///                    },
    ///                    "locked": {
    ///                      "examples": [
    ///                        "0.00000000"
    ///                      ],
    ///                      "type": "string"
    ///                    }
    ///                  }
    ///                }
    ///              },
    ///              "totalAssetOfBtc": {
    ///                "examples": [
    ///                  "0.09942700"
    ///                ],
    ///                "type": "string"
    ///              }
    ///            }
    ///          },
    ///          "type": {
    ///            "examples": [
    ///              "spot"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "updateTime": {
    ///            "examples": [
    ///              1576281599000
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct ManagedSubaccountAccountSnapshotResponse {
        pub code: i32,
        pub msg: String,
        #[serde(rename = "snapshotVos")]
        pub snapshot_vos: Vec<ManagedSubaccountAccountSnapshotResponseSnapshotVosItem>,
    }
    impl From<&ManagedSubaccountAccountSnapshotResponse>
    for ManagedSubaccountAccountSnapshotResponse {
        fn from(value: &ManagedSubaccountAccountSnapshotResponse) -> Self {
            value.clone()
        }
    }
    ///ManagedSubaccountAccountSnapshotResponseSnapshotVosItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "data",
    ///    "type",
    ///    "updateTime"
    ///  ],
    ///  "properties": {
    ///    "data": {
    ///      "type": "object",
    ///      "required": [
    ///        "balances",
    ///        "totalAssetOfBtc"
    ///      ],
    ///      "properties": {
    ///        "balances": {
    ///          "type": "array",
    ///          "items": {
    ///            "type": "object",
    ///            "required": [
    ///              "asset",
    ///              "free",
    ///              "locked"
    ///            ],
    ///            "properties": {
    ///              "asset": {
    ///                "examples": [
    ///                  "BTC"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "free": {
    ///                "examples": [
    ///                  "0.09905021"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "locked": {
    ///                "examples": [
    ///                  "0.00000000"
    ///                ],
    ///                "type": "string"
    ///              }
    ///            }
    ///          }
    ///        },
    ///        "totalAssetOfBtc": {
    ///          "examples": [
    ///            "0.09942700"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "type": {
    ///      "examples": [
    ///        "spot"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "updateTime": {
    ///      "examples": [
    ///        1576281599000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct ManagedSubaccountAccountSnapshotResponseSnapshotVosItem {
        pub data: ManagedSubaccountAccountSnapshotResponseSnapshotVosItemData,
        #[serde(rename = "type")]
        pub type_: String,
        #[serde(rename = "updateTime")]
        pub update_time: i64,
    }
    impl From<&ManagedSubaccountAccountSnapshotResponseSnapshotVosItem>
    for ManagedSubaccountAccountSnapshotResponseSnapshotVosItem {
        fn from(
            value: &ManagedSubaccountAccountSnapshotResponseSnapshotVosItem,
        ) -> Self {
            value.clone()
        }
    }
    ///ManagedSubaccountAccountSnapshotResponseSnapshotVosItemData
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "balances",
    ///    "totalAssetOfBtc"
    ///  ],
    ///  "properties": {
    ///    "balances": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "asset",
    ///          "free",
    ///          "locked"
    ///        ],
    ///        "properties": {
    ///          "asset": {
    ///            "examples": [
    ///              "BTC"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "free": {
    ///            "examples": [
    ///              "0.09905021"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "locked": {
    ///            "examples": [
    ///              "0.00000000"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "totalAssetOfBtc": {
    ///      "examples": [
    ///        "0.09942700"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct ManagedSubaccountAccountSnapshotResponseSnapshotVosItemData {
        pub balances: Vec<
            ManagedSubaccountAccountSnapshotResponseSnapshotVosItemDataBalancesItem,
        >,
        #[serde(rename = "totalAssetOfBtc")]
        pub total_asset_of_btc: String,
    }
    impl From<&ManagedSubaccountAccountSnapshotResponseSnapshotVosItemData>
    for ManagedSubaccountAccountSnapshotResponseSnapshotVosItemData {
        fn from(
            value: &ManagedSubaccountAccountSnapshotResponseSnapshotVosItemData,
        ) -> Self {
            value.clone()
        }
    }
    ///ManagedSubaccountAccountSnapshotResponseSnapshotVosItemDataBalancesItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "asset",
    ///    "free",
    ///    "locked"
    ///  ],
    ///  "properties": {
    ///    "asset": {
    ///      "examples": [
    ///        "BTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "free": {
    ///      "examples": [
    ///        "0.09905021"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "locked": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct ManagedSubaccountAccountSnapshotResponseSnapshotVosItemDataBalancesItem {
        pub asset: String,
        pub free: String,
        pub locked: String,
    }
    impl From<&ManagedSubaccountAccountSnapshotResponseSnapshotVosItemDataBalancesItem>
    for ManagedSubaccountAccountSnapshotResponseSnapshotVosItemDataBalancesItem {
        fn from(
            value: &ManagedSubaccountAccountSnapshotResponseSnapshotVosItemDataBalancesItem,
        ) -> Self {
            value.clone()
        }
    }
    ///ManagedSubaccountAssetResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "availableBalance",
    ///    "btcValue",
    ///    "coin",
    ///    "inOrder",
    ///    "name",
    ///    "totalBalance"
    ///  ],
    ///  "properties": {
    ///    "availableBalance": {
    ///      "examples": [
    ///        "0"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "btcValue": {
    ///      "examples": [
    ///        "0"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "coin": {
    ///      "examples": [
    ///        "INJ"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "inOrder": {
    ///      "examples": [
    ///        "0"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "examples": [
    ///        "Injective Protocol"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalBalance": {
    ///      "examples": [
    ///        "0"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct ManagedSubaccountAssetResponseItem {
        #[serde(rename = "availableBalance")]
        pub available_balance: String,
        #[serde(rename = "btcValue")]
        pub btc_value: String,
        pub coin: String,
        #[serde(rename = "inOrder")]
        pub in_order: String,
        pub name: String,
        #[serde(rename = "totalBalance")]
        pub total_balance: String,
    }
    impl From<&ManagedSubaccountAssetResponseItem>
    for ManagedSubaccountAssetResponseItem {
        fn from(value: &ManagedSubaccountAssetResponseItem) -> Self {
            value.clone()
        }
    }
    ///ManagedSubaccountDepositAddressResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "address",
    ///    "coin",
    ///    "tag",
    ///    "url"
    ///  ],
    ///  "properties": {
    ///    "address": {
    ///      "examples": [
    ///        "0x206c22d833bb0bb2102da6b7c7d4c3eb14bcf73d"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "coin": {
    ///      "examples": [
    ///        "USDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "tag": {
    ///      "type": "string"
    ///    },
    ///    "url": {
    ///      "examples": [
    ///        "https://etherscan.io/address/0x206c22d833bb0bb2102da6b7c7d4c3eb14bcf73d"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct ManagedSubaccountDepositAddressResponse {
        pub address: String,
        pub coin: String,
        pub tag: String,
        pub url: String,
    }
    impl From<&ManagedSubaccountDepositAddressResponse>
    for ManagedSubaccountDepositAddressResponse {
        fn from(value: &ManagedSubaccountDepositAddressResponse) -> Self {
            value.clone()
        }
    }
    ///ManagedSubaccountDepositResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "tranId"
    ///  ],
    ///  "properties": {
    ///    "tranId": {
    ///      "examples": [
    ///        66157362489
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct ManagedSubaccountDepositResponse {
        #[serde(rename = "tranId")]
        pub tran_id: i64,
    }
    impl From<&ManagedSubaccountDepositResponse> for ManagedSubaccountDepositResponse {
        fn from(value: &ManagedSubaccountDepositResponse) -> Self {
            value.clone()
        }
    }
    ///ManagedSubaccountFetchFutureAssetResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "code",
    ///    "message",
    ///    "snapshotVos"
    ///  ],
    ///  "properties": {
    ///    "code": {
    ///      "examples": [
    ///        200
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    },
    ///    "message": {
    ///      "examples": [
    ///        "OK"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "snapshotVos": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "data",
    ///          "type",
    ///          "updateTime"
    ///        ],
    ///        "properties": {
    ///          "data": {
    ///            "type": "object",
    ///            "required": [
    ///              "assets",
    ///              "position"
    ///            ],
    ///            "properties": {
    ///              "assets": {
    ///                "type": "array",
    ///                "items": {
    ///                  "type": "object",
    ///                  "required": [
    ///                    "asset",
    ///                    "marginBalance",
    ///                    "walletBalance"
    ///                  ],
    ///                  "properties": {
    ///                    "asset": {
    ///                      "examples": [
    ///                        "USDT"
    ///                      ],
    ///                      "type": "string"
    ///                    },
    ///                    "marginBalance": {
    ///                      "examples": [
    ///                        100
    ///                      ],
    ///                      "type": "number",
    ///                      "format": "float"
    ///                    },
    ///                    "walletBalance": {
    ///                      "examples": [
    ///                        100
    ///                      ],
    ///                      "type": "number",
    ///                      "format": "float"
    ///                    }
    ///                  }
    ///                }
    ///              },
    ///              "position": {
    ///                "type": "array",
    ///                "items": {
    ///                  "type": "object",
    ///                  "required": [
    ///                    "entryPrice",
    ///                    "markPrice",
    ///                    "positionAmt",
    ///                    "symbol"
    ///                  ],
    ///                  "properties": {
    ///                    "entryPrice": {
    ///                      "examples": [
    ///                        17000
    ///                      ],
    ///                      "type": "number",
    ///                      "format": "float"
    ///                    },
    ///                    "markPrice": {
    ///                      "examples": [
    ///                        17000
    ///                      ],
    ///                      "type": "number",
    ///                      "format": "float"
    ///                    },
    ///                    "positionAmt": {
    ///                      "examples": [
    ///                        0.1
    ///                      ],
    ///                      "type": "number",
    ///                      "format": "float"
    ///                    },
    ///                    "symbol": {
    ///                      "examples": [
    ///                        "BTCUSDT"
    ///                      ],
    ///                      "type": "string"
    ///                    }
    ///                  }
    ///                }
    ///              }
    ///            }
    ///          },
    ///          "type": {
    ///            "examples": [
    ///              "FUTURES"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "updateTime": {
    ///            "examples": [
    ///              1626400907000
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct ManagedSubaccountFetchFutureAssetResponse {
        pub code: i32,
        pub message: String,
        #[serde(rename = "snapshotVos")]
        pub snapshot_vos: Vec<ManagedSubaccountFetchFutureAssetResponseSnapshotVosItem>,
    }
    impl From<&ManagedSubaccountFetchFutureAssetResponse>
    for ManagedSubaccountFetchFutureAssetResponse {
        fn from(value: &ManagedSubaccountFetchFutureAssetResponse) -> Self {
            value.clone()
        }
    }
    ///ManagedSubaccountFetchFutureAssetResponseSnapshotVosItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "data",
    ///    "type",
    ///    "updateTime"
    ///  ],
    ///  "properties": {
    ///    "data": {
    ///      "type": "object",
    ///      "required": [
    ///        "assets",
    ///        "position"
    ///      ],
    ///      "properties": {
    ///        "assets": {
    ///          "type": "array",
    ///          "items": {
    ///            "type": "object",
    ///            "required": [
    ///              "asset",
    ///              "marginBalance",
    ///              "walletBalance"
    ///            ],
    ///            "properties": {
    ///              "asset": {
    ///                "examples": [
    ///                  "USDT"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "marginBalance": {
    ///                "examples": [
    ///                  100
    ///                ],
    ///                "type": "number",
    ///                "format": "float"
    ///              },
    ///              "walletBalance": {
    ///                "examples": [
    ///                  100
    ///                ],
    ///                "type": "number",
    ///                "format": "float"
    ///              }
    ///            }
    ///          }
    ///        },
    ///        "position": {
    ///          "type": "array",
    ///          "items": {
    ///            "type": "object",
    ///            "required": [
    ///              "entryPrice",
    ///              "markPrice",
    ///              "positionAmt",
    ///              "symbol"
    ///            ],
    ///            "properties": {
    ///              "entryPrice": {
    ///                "examples": [
    ///                  17000
    ///                ],
    ///                "type": "number",
    ///                "format": "float"
    ///              },
    ///              "markPrice": {
    ///                "examples": [
    ///                  17000
    ///                ],
    ///                "type": "number",
    ///                "format": "float"
    ///              },
    ///              "positionAmt": {
    ///                "examples": [
    ///                  0.1
    ///                ],
    ///                "type": "number",
    ///                "format": "float"
    ///              },
    ///              "symbol": {
    ///                "examples": [
    ///                  "BTCUSDT"
    ///                ],
    ///                "type": "string"
    ///              }
    ///            }
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "type": {
    ///      "examples": [
    ///        "FUTURES"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "updateTime": {
    ///      "examples": [
    ///        1626400907000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct ManagedSubaccountFetchFutureAssetResponseSnapshotVosItem {
        pub data: ManagedSubaccountFetchFutureAssetResponseSnapshotVosItemData,
        #[serde(rename = "type")]
        pub type_: String,
        #[serde(rename = "updateTime")]
        pub update_time: i64,
    }
    impl From<&ManagedSubaccountFetchFutureAssetResponseSnapshotVosItem>
    for ManagedSubaccountFetchFutureAssetResponseSnapshotVosItem {
        fn from(
            value: &ManagedSubaccountFetchFutureAssetResponseSnapshotVosItem,
        ) -> Self {
            value.clone()
        }
    }
    ///ManagedSubaccountFetchFutureAssetResponseSnapshotVosItemData
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "assets",
    ///    "position"
    ///  ],
    ///  "properties": {
    ///    "assets": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "asset",
    ///          "marginBalance",
    ///          "walletBalance"
    ///        ],
    ///        "properties": {
    ///          "asset": {
    ///            "examples": [
    ///              "USDT"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "marginBalance": {
    ///            "examples": [
    ///              100
    ///            ],
    ///            "type": "number",
    ///            "format": "float"
    ///          },
    ///          "walletBalance": {
    ///            "examples": [
    ///              100
    ///            ],
    ///            "type": "number",
    ///            "format": "float"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "position": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "entryPrice",
    ///          "markPrice",
    ///          "positionAmt",
    ///          "symbol"
    ///        ],
    ///        "properties": {
    ///          "entryPrice": {
    ///            "examples": [
    ///              17000
    ///            ],
    ///            "type": "number",
    ///            "format": "float"
    ///          },
    ///          "markPrice": {
    ///            "examples": [
    ///              17000
    ///            ],
    ///            "type": "number",
    ///            "format": "float"
    ///          },
    ///          "positionAmt": {
    ///            "examples": [
    ///              0.1
    ///            ],
    ///            "type": "number",
    ///            "format": "float"
    ///          },
    ///          "symbol": {
    ///            "examples": [
    ///              "BTCUSDT"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct ManagedSubaccountFetchFutureAssetResponseSnapshotVosItemData {
        pub assets: Vec<
            ManagedSubaccountFetchFutureAssetResponseSnapshotVosItemDataAssetsItem,
        >,
        pub position: Vec<
            ManagedSubaccountFetchFutureAssetResponseSnapshotVosItemDataPositionItem,
        >,
    }
    impl From<&ManagedSubaccountFetchFutureAssetResponseSnapshotVosItemData>
    for ManagedSubaccountFetchFutureAssetResponseSnapshotVosItemData {
        fn from(
            value: &ManagedSubaccountFetchFutureAssetResponseSnapshotVosItemData,
        ) -> Self {
            value.clone()
        }
    }
    ///ManagedSubaccountFetchFutureAssetResponseSnapshotVosItemDataAssetsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "asset",
    ///    "marginBalance",
    ///    "walletBalance"
    ///  ],
    ///  "properties": {
    ///    "asset": {
    ///      "examples": [
    ///        "USDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "marginBalance": {
    ///      "examples": [
    ///        100
    ///      ],
    ///      "type": "number",
    ///      "format": "float"
    ///    },
    ///    "walletBalance": {
    ///      "examples": [
    ///        100
    ///      ],
    ///      "type": "number",
    ///      "format": "float"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct ManagedSubaccountFetchFutureAssetResponseSnapshotVosItemDataAssetsItem {
        pub asset: String,
        #[serde(rename = "marginBalance")]
        pub margin_balance: f32,
        #[serde(rename = "walletBalance")]
        pub wallet_balance: f32,
    }
    impl From<&ManagedSubaccountFetchFutureAssetResponseSnapshotVosItemDataAssetsItem>
    for ManagedSubaccountFetchFutureAssetResponseSnapshotVosItemDataAssetsItem {
        fn from(
            value: &ManagedSubaccountFetchFutureAssetResponseSnapshotVosItemDataAssetsItem,
        ) -> Self {
            value.clone()
        }
    }
    ///ManagedSubaccountFetchFutureAssetResponseSnapshotVosItemDataPositionItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "entryPrice",
    ///    "markPrice",
    ///    "positionAmt",
    ///    "symbol"
    ///  ],
    ///  "properties": {
    ///    "entryPrice": {
    ///      "examples": [
    ///        17000
    ///      ],
    ///      "type": "number",
    ///      "format": "float"
    ///    },
    ///    "markPrice": {
    ///      "examples": [
    ///        17000
    ///      ],
    ///      "type": "number",
    ///      "format": "float"
    ///    },
    ///    "positionAmt": {
    ///      "examples": [
    ///        0.1
    ///      ],
    ///      "type": "number",
    ///      "format": "float"
    ///    },
    ///    "symbol": {
    ///      "examples": [
    ///        "BTCUSDT"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct ManagedSubaccountFetchFutureAssetResponseSnapshotVosItemDataPositionItem {
        #[serde(rename = "entryPrice")]
        pub entry_price: f32,
        #[serde(rename = "markPrice")]
        pub mark_price: f32,
        #[serde(rename = "positionAmt")]
        pub position_amt: f32,
        pub symbol: String,
    }
    impl From<&ManagedSubaccountFetchFutureAssetResponseSnapshotVosItemDataPositionItem>
    for ManagedSubaccountFetchFutureAssetResponseSnapshotVosItemDataPositionItem {
        fn from(
            value: &ManagedSubaccountFetchFutureAssetResponseSnapshotVosItemDataPositionItem,
        ) -> Self {
            value.clone()
        }
    }
    ///ManagedSubaccountInfoResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "managerSubUserInfoVoList",
    ///    "total"
    ///  ],
    ///  "properties": {
    ///    "managerSubUserInfoVoList": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "bindParentEmail",
    ///          "bindParentUserId",
    ///          "insertTimeStamp",
    ///          "isFutureEnabled",
    ///          "isMarginEnabled",
    ///          "isSignedLVTRiskAgreement",
    ///          "isSubUserEnabled",
    ///          "isUserActive",
    ///          "managersubUserId",
    ///          "rootUserId"
    ///        ],
    ///        "properties": {
    ///          "bindParentEmail": {
    ///            "examples": [
    ///              "wdyw8xsh8pey@test.com"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "bindParentUserId": {
    ///            "examples": [
    ///              1000138475669
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "email": {
    ///            "examples": [
    ///              "test_0_virtual@kq3kno9imanagedsub.com"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "insertTimeStamp": {
    ///            "examples": [
    ///              1678435149000
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "isFutureEnabled": {
    ///            "examples": [
    ///              true
    ///            ],
    ///            "type": "boolean"
    ///          },
    ///          "isMarginEnabled": {
    ///            "examples": [
    ///              true
    ///            ],
    ///            "type": "boolean"
    ///          },
    ///          "isSignedLVTRiskAgreement": {
    ///            "examples": [
    ///              true
    ///            ],
    ///            "type": "boolean"
    ///          },
    ///          "isSubUserEnabled": {
    ///            "examples": [
    ///              true
    ///            ],
    ///            "type": "boolean"
    ///          },
    ///          "isUserActive": {
    ///            "examples": [
    ///              true
    ///            ],
    ///            "type": "boolean"
    ///          },
    ///          "managersubUserId": {
    ///            "examples": [
    ///              1000137842513
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "rootUserId": {
    ///            "examples": [
    ///              1000138475670
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "total": {
    ///      "examples": [
    ///        3
    ///      ],
    ///      "type": "integer"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct ManagedSubaccountInfoResponse {
        #[serde(rename = "managerSubUserInfoVoList")]
        pub manager_sub_user_info_vo_list: Vec<
            ManagedSubaccountInfoResponseManagerSubUserInfoVoListItem,
        >,
        pub total: i64,
    }
    impl From<&ManagedSubaccountInfoResponse> for ManagedSubaccountInfoResponse {
        fn from(value: &ManagedSubaccountInfoResponse) -> Self {
            value.clone()
        }
    }
    ///ManagedSubaccountInfoResponseManagerSubUserInfoVoListItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "bindParentEmail",
    ///    "bindParentUserId",
    ///    "insertTimeStamp",
    ///    "isFutureEnabled",
    ///    "isMarginEnabled",
    ///    "isSignedLVTRiskAgreement",
    ///    "isSubUserEnabled",
    ///    "isUserActive",
    ///    "managersubUserId",
    ///    "rootUserId"
    ///  ],
    ///  "properties": {
    ///    "bindParentEmail": {
    ///      "examples": [
    ///        "wdyw8xsh8pey@test.com"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "bindParentUserId": {
    ///      "examples": [
    ///        1000138475669
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "email": {
    ///      "examples": [
    ///        "test_0_virtual@kq3kno9imanagedsub.com"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "insertTimeStamp": {
    ///      "examples": [
    ///        1678435149000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "isFutureEnabled": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "isMarginEnabled": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "isSignedLVTRiskAgreement": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "isSubUserEnabled": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "isUserActive": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "managersubUserId": {
    ///      "examples": [
    ///        1000137842513
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "rootUserId": {
    ///      "examples": [
    ///        1000138475670
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct ManagedSubaccountInfoResponseManagerSubUserInfoVoListItem {
        #[serde(rename = "bindParentEmail")]
        pub bind_parent_email: String,
        #[serde(rename = "bindParentUserId")]
        pub bind_parent_user_id: i64,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub email: Option<String>,
        #[serde(rename = "insertTimeStamp")]
        pub insert_time_stamp: i64,
        #[serde(rename = "isFutureEnabled")]
        pub is_future_enabled: bool,
        #[serde(rename = "isMarginEnabled")]
        pub is_margin_enabled: bool,
        #[serde(rename = "isSignedLVTRiskAgreement")]
        pub is_signed_lvt_risk_agreement: bool,
        #[serde(rename = "isSubUserEnabled")]
        pub is_sub_user_enabled: bool,
        #[serde(rename = "isUserActive")]
        pub is_user_active: bool,
        #[serde(rename = "managersubUserId")]
        pub managersub_user_id: i64,
        #[serde(rename = "rootUserId")]
        pub root_user_id: i64,
    }
    impl From<&ManagedSubaccountInfoResponseManagerSubUserInfoVoListItem>
    for ManagedSubaccountInfoResponseManagerSubUserInfoVoListItem {
        fn from(
            value: &ManagedSubaccountInfoResponseManagerSubUserInfoVoListItem,
        ) -> Self {
            value.clone()
        }
    }
    ///ManagedSubaccountMarginAssetResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "marginLevel",
    ///    "totalAssetOfBtc",
    ///    "totalLiabilityOfBtc",
    ///    "totalNetAssetOfBtc",
    ///    "userAssets"
    ///  ],
    ///  "properties": {
    ///    "marginLevel": {
    ///      "examples": [
    ///        "999"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalAssetOfBtc": {
    ///      "examples": [
    ///        "0"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalLiabilityOfBtc": {
    ///      "examples": [
    ///        "0"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalNetAssetOfBtc": {
    ///      "examples": [
    ///        "0"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "userAssets": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "asset",
    ///          "borrowed",
    ///          "free",
    ///          "interest",
    ///          "locked",
    ///          "netAsset"
    ///        ],
    ///        "properties": {
    ///          "asset": {
    ///            "examples": [
    ///              "BTC"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "borrowed": {
    ///            "examples": [
    ///              "0"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "free": {
    ///            "examples": [
    ///              "0"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "interest": {
    ///            "examples": [
    ///              "0"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "locked": {
    ///            "examples": [
    ///              "0"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "netAsset": {
    ///            "examples": [
    ///              "0"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct ManagedSubaccountMarginAssetResponse {
        #[serde(rename = "marginLevel")]
        pub margin_level: String,
        #[serde(rename = "totalAssetOfBtc")]
        pub total_asset_of_btc: String,
        #[serde(rename = "totalLiabilityOfBtc")]
        pub total_liability_of_btc: String,
        #[serde(rename = "totalNetAssetOfBtc")]
        pub total_net_asset_of_btc: String,
        #[serde(rename = "userAssets")]
        pub user_assets: Vec<ManagedSubaccountMarginAssetResponseUserAssetsItem>,
    }
    impl From<&ManagedSubaccountMarginAssetResponse>
    for ManagedSubaccountMarginAssetResponse {
        fn from(value: &ManagedSubaccountMarginAssetResponse) -> Self {
            value.clone()
        }
    }
    ///ManagedSubaccountMarginAssetResponseUserAssetsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "asset",
    ///    "borrowed",
    ///    "free",
    ///    "interest",
    ///    "locked",
    ///    "netAsset"
    ///  ],
    ///  "properties": {
    ///    "asset": {
    ///      "examples": [
    ///        "BTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "borrowed": {
    ///      "examples": [
    ///        "0"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "free": {
    ///      "examples": [
    ///        "0"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "interest": {
    ///      "examples": [
    ///        "0"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "locked": {
    ///      "examples": [
    ///        "0"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "netAsset": {
    ///      "examples": [
    ///        "0"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct ManagedSubaccountMarginAssetResponseUserAssetsItem {
        pub asset: String,
        pub borrowed: String,
        pub free: String,
        pub interest: String,
        pub locked: String,
        #[serde(rename = "netAsset")]
        pub net_asset: String,
    }
    impl From<&ManagedSubaccountMarginAssetResponseUserAssetsItem>
    for ManagedSubaccountMarginAssetResponseUserAssetsItem {
        fn from(value: &ManagedSubaccountMarginAssetResponseUserAssetsItem) -> Self {
            value.clone()
        }
    }
    ///ManagedSubaccountQueryTransLogForInvestorResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "count",
    ///    "managerSubTransferHistoryVos"
    ///  ],
    ///  "properties": {
    ///    "count": {
    ///      "examples": [
    ///        2
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    },
    ///    "managerSubTransferHistoryVos": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "amount",
    ///          "asset",
    ///          "createTime",
    ///          "fromAccountType",
    ///          "fromEmail",
    ///          "scheduledData",
    ///          "status",
    ///          "toAccountType",
    ///          "toEmail",
    ///          "tranId"
    ///        ],
    ///        "properties": {
    ///          "amount": {
    ///            "examples": [
    ///              "0.01"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "asset": {
    ///            "examples": [
    ///              "BNB"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "createTime": {
    ///            "examples": [
    ///              1626144956000
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "fromAccountType": {
    ///            "examples": [
    ///              "SPOT"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "fromEmail": {
    ///            "examples": [
    ///              "test_0_virtual@kq3kno9imanagedsub.com"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "scheduledData": {
    ///            "examples": [
    ///              1626144956000
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "status": {
    ///            "examples": [
    ///              "SUCCESS"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "toAccountType": {
    ///            "examples": [
    ///              "SPOT"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "toEmail": {
    ///            "examples": [
    ///              "wdywl0lddakh@test.com"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "tranId": {
    ///            "examples": [
    ///              91077779
    ///            ],
    ///            "type": "integer"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct ManagedSubaccountQueryTransLogForInvestorResponse {
        pub count: i32,
        #[serde(rename = "managerSubTransferHistoryVos")]
        pub manager_sub_transfer_history_vos: Vec<
            ManagedSubaccountQueryTransLogForInvestorResponseManagerSubTransferHistoryVosItem,
        >,
    }
    impl From<&ManagedSubaccountQueryTransLogForInvestorResponse>
    for ManagedSubaccountQueryTransLogForInvestorResponse {
        fn from(value: &ManagedSubaccountQueryTransLogForInvestorResponse) -> Self {
            value.clone()
        }
    }
    ///ManagedSubaccountQueryTransLogForInvestorResponseManagerSubTransferHistoryVosItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "asset",
    ///    "createTime",
    ///    "fromAccountType",
    ///    "fromEmail",
    ///    "scheduledData",
    ///    "status",
    ///    "toAccountType",
    ///    "toEmail",
    ///    "tranId"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "examples": [
    ///        "0.01"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "asset": {
    ///      "examples": [
    ///        "BNB"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "createTime": {
    ///      "examples": [
    ///        1626144956000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "fromAccountType": {
    ///      "examples": [
    ///        "SPOT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "fromEmail": {
    ///      "examples": [
    ///        "test_0_virtual@kq3kno9imanagedsub.com"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "scheduledData": {
    ///      "examples": [
    ///        1626144956000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "status": {
    ///      "examples": [
    ///        "SUCCESS"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "toAccountType": {
    ///      "examples": [
    ///        "SPOT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "toEmail": {
    ///      "examples": [
    ///        "wdywl0lddakh@test.com"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "tranId": {
    ///      "examples": [
    ///        91077779
    ///      ],
    ///      "type": "integer"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct ManagedSubaccountQueryTransLogForInvestorResponseManagerSubTransferHistoryVosItem {
        pub amount: String,
        pub asset: String,
        #[serde(rename = "createTime")]
        pub create_time: i64,
        #[serde(rename = "fromAccountType")]
        pub from_account_type: String,
        #[serde(rename = "fromEmail")]
        pub from_email: String,
        #[serde(rename = "scheduledData")]
        pub scheduled_data: i64,
        pub status: String,
        #[serde(rename = "toAccountType")]
        pub to_account_type: String,
        #[serde(rename = "toEmail")]
        pub to_email: String,
        #[serde(rename = "tranId")]
        pub tran_id: i64,
    }
    impl From<
        &ManagedSubaccountQueryTransLogForInvestorResponseManagerSubTransferHistoryVosItem,
    >
    for ManagedSubaccountQueryTransLogForInvestorResponseManagerSubTransferHistoryVosItem {
        fn from(
            value: &ManagedSubaccountQueryTransLogForInvestorResponseManagerSubTransferHistoryVosItem,
        ) -> Self {
            value.clone()
        }
    }
    ///ManagedSubaccountQueryTransLogForTradeParentResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "count",
    ///    "managerSubTransferHistoryVos"
    ///  ],
    ///  "properties": {
    ///    "count": {
    ///      "examples": [
    ///        2
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    },
    ///    "managerSubTransferHistoryVos": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "amount",
    ///          "asset",
    ///          "createTime",
    ///          "fromAccountType",
    ///          "fromEmail",
    ///          "scheduledData",
    ///          "status",
    ///          "toAccountType",
    ///          "toEmail",
    ///          "tranId"
    ///        ],
    ///        "properties": {
    ///          "amount": {
    ///            "examples": [
    ///              "0.01"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "asset": {
    ///            "examples": [
    ///              "BNB"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "createTime": {
    ///            "examples": [
    ///              1626144956000
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "fromAccountType": {
    ///            "examples": [
    ///              "SPOT"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "fromEmail": {
    ///            "examples": [
    ///              "test_0_virtual@kq3kno9imanagedsub.com"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "scheduledData": {
    ///            "examples": [
    ///              1626144956000
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "status": {
    ///            "examples": [
    ///              "SUCCESS"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "toAccountType": {
    ///            "examples": [
    ///              "SPOT"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "toEmail": {
    ///            "examples": [
    ///              "wdywl0lddakh@test.com"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "tranId": {
    ///            "examples": [
    ///              91077779
    ///            ],
    ///            "type": "integer"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct ManagedSubaccountQueryTransLogForTradeParentResponse {
        pub count: i32,
        #[serde(rename = "managerSubTransferHistoryVos")]
        pub manager_sub_transfer_history_vos: Vec<
            ManagedSubaccountQueryTransLogForTradeParentResponseManagerSubTransferHistoryVosItem,
        >,
    }
    impl From<&ManagedSubaccountQueryTransLogForTradeParentResponse>
    for ManagedSubaccountQueryTransLogForTradeParentResponse {
        fn from(value: &ManagedSubaccountQueryTransLogForTradeParentResponse) -> Self {
            value.clone()
        }
    }
    ///ManagedSubaccountQueryTransLogForTradeParentResponseManagerSubTransferHistoryVosItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "asset",
    ///    "createTime",
    ///    "fromAccountType",
    ///    "fromEmail",
    ///    "scheduledData",
    ///    "status",
    ///    "toAccountType",
    ///    "toEmail",
    ///    "tranId"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "examples": [
    ///        "0.01"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "asset": {
    ///      "examples": [
    ///        "BNB"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "createTime": {
    ///      "examples": [
    ///        1626144956000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "fromAccountType": {
    ///      "examples": [
    ///        "SPOT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "fromEmail": {
    ///      "examples": [
    ///        "test_0_virtual@kq3kno9imanagedsub.com"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "scheduledData": {
    ///      "examples": [
    ///        1626144956000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "status": {
    ///      "examples": [
    ///        "SUCCESS"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "toAccountType": {
    ///      "examples": [
    ///        "SPOT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "toEmail": {
    ///      "examples": [
    ///        "wdywl0lddakh@test.com"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "tranId": {
    ///      "examples": [
    ///        91077779
    ///      ],
    ///      "type": "integer"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct ManagedSubaccountQueryTransLogForTradeParentResponseManagerSubTransferHistoryVosItem {
        pub amount: String,
        pub asset: String,
        #[serde(rename = "createTime")]
        pub create_time: i64,
        #[serde(rename = "fromAccountType")]
        pub from_account_type: String,
        #[serde(rename = "fromEmail")]
        pub from_email: String,
        #[serde(rename = "scheduledData")]
        pub scheduled_data: i64,
        pub status: String,
        #[serde(rename = "toAccountType")]
        pub to_account_type: String,
        #[serde(rename = "toEmail")]
        pub to_email: String,
        #[serde(rename = "tranId")]
        pub tran_id: i64,
    }
    impl From<
        &ManagedSubaccountQueryTransLogForTradeParentResponseManagerSubTransferHistoryVosItem,
    >
    for ManagedSubaccountQueryTransLogForTradeParentResponseManagerSubTransferHistoryVosItem {
        fn from(
            value: &ManagedSubaccountQueryTransLogForTradeParentResponseManagerSubTransferHistoryVosItem,
        ) -> Self {
            value.clone()
        }
    }
    ///ManagedSubaccountQueryTransLogResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "count",
    ///    "managerSubTransferHistoryVos"
    ///  ],
    ///  "properties": {
    ///    "count": {
    ///      "examples": [
    ///        2
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "managerSubTransferHistoryVos": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "amount",
    ///          "asset",
    ///          "createTime",
    ///          "fromAccountType",
    ///          "fromEmail",
    ///          "scheduledData",
    ///          "status",
    ///          "toAccountType",
    ///          "toEmail",
    ///          "tranId"
    ///        ],
    ///        "properties": {
    ///          "amount": {
    ///            "examples": [
    ///              "0.01"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "asset": {
    ///            "examples": [
    ///              "BNB"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "createTime": {
    ///            "examples": [
    ///              1679416673000
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "fromAccountType": {
    ///            "examples": [
    ///              "SPOT"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "fromEmail": {
    ///            "examples": [
    ///              "test_0_virtual@kq3kno9imanagedsub.com"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "scheduledData": {
    ///            "examples": [
    ///              1679416673000
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "status": {
    ///            "examples": [
    ///              "SUCCESS"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "toAccountType": {
    ///            "examples": [
    ///              "SPOT"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "toEmail": {
    ///            "examples": [
    ///              "wdywl0lddakh@test.com"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "tranId": {
    ///            "examples": [
    ///              91077779
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct ManagedSubaccountQueryTransLogResponse {
        pub count: i64,
        #[serde(rename = "managerSubTransferHistoryVos")]
        pub manager_sub_transfer_history_vos: Vec<
            ManagedSubaccountQueryTransLogResponseManagerSubTransferHistoryVosItem,
        >,
    }
    impl From<&ManagedSubaccountQueryTransLogResponse>
    for ManagedSubaccountQueryTransLogResponse {
        fn from(value: &ManagedSubaccountQueryTransLogResponse) -> Self {
            value.clone()
        }
    }
    ///ManagedSubaccountQueryTransLogResponseManagerSubTransferHistoryVosItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "asset",
    ///    "createTime",
    ///    "fromAccountType",
    ///    "fromEmail",
    ///    "scheduledData",
    ///    "status",
    ///    "toAccountType",
    ///    "toEmail",
    ///    "tranId"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "examples": [
    ///        "0.01"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "asset": {
    ///      "examples": [
    ///        "BNB"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "createTime": {
    ///      "examples": [
    ///        1679416673000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "fromAccountType": {
    ///      "examples": [
    ///        "SPOT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "fromEmail": {
    ///      "examples": [
    ///        "test_0_virtual@kq3kno9imanagedsub.com"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "scheduledData": {
    ///      "examples": [
    ///        1679416673000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "status": {
    ///      "examples": [
    ///        "SUCCESS"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "toAccountType": {
    ///      "examples": [
    ///        "SPOT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "toEmail": {
    ///      "examples": [
    ///        "wdywl0lddakh@test.com"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "tranId": {
    ///      "examples": [
    ///        91077779
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct ManagedSubaccountQueryTransLogResponseManagerSubTransferHistoryVosItem {
        pub amount: String,
        pub asset: String,
        #[serde(rename = "createTime")]
        pub create_time: i64,
        #[serde(rename = "fromAccountType")]
        pub from_account_type: String,
        #[serde(rename = "fromEmail")]
        pub from_email: String,
        #[serde(rename = "scheduledData")]
        pub scheduled_data: i64,
        pub status: String,
        #[serde(rename = "toAccountType")]
        pub to_account_type: String,
        #[serde(rename = "toEmail")]
        pub to_email: String,
        #[serde(rename = "tranId")]
        pub tran_id: i64,
    }
    impl From<&ManagedSubaccountQueryTransLogResponseManagerSubTransferHistoryVosItem>
    for ManagedSubaccountQueryTransLogResponseManagerSubTransferHistoryVosItem {
        fn from(
            value: &ManagedSubaccountQueryTransLogResponseManagerSubTransferHistoryVosItem,
        ) -> Self {
            value.clone()
        }
    }
    ///ManagedSubaccountQueryTransLogTransferFunctionAccountType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "SPOT",
    ///    "MARGIN",
    ///    "ISOLATED_MARGIN",
    ///    "USDT_FUTURE",
    ///    "COIN_FUTURE"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum ManagedSubaccountQueryTransLogTransferFunctionAccountType {
        #[serde(rename = "SPOT")]
        Spot,
        #[serde(rename = "MARGIN")]
        Margin,
        #[serde(rename = "ISOLATED_MARGIN")]
        IsolatedMargin,
        #[serde(rename = "USDT_FUTURE")]
        UsdtFuture,
        #[serde(rename = "COIN_FUTURE")]
        CoinFuture,
    }
    impl From<&ManagedSubaccountQueryTransLogTransferFunctionAccountType>
    for ManagedSubaccountQueryTransLogTransferFunctionAccountType {
        fn from(
            value: &ManagedSubaccountQueryTransLogTransferFunctionAccountType,
        ) -> Self {
            value.clone()
        }
    }
    impl ToString for ManagedSubaccountQueryTransLogTransferFunctionAccountType {
        fn to_string(&self) -> String {
            match *self {
                Self::Spot => "SPOT".to_string(),
                Self::Margin => "MARGIN".to_string(),
                Self::IsolatedMargin => "ISOLATED_MARGIN".to_string(),
                Self::UsdtFuture => "USDT_FUTURE".to_string(),
                Self::CoinFuture => "COIN_FUTURE".to_string(),
            }
        }
    }
    impl std::str::FromStr
    for ManagedSubaccountQueryTransLogTransferFunctionAccountType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "SPOT" => Ok(Self::Spot),
                "MARGIN" => Ok(Self::Margin),
                "ISOLATED_MARGIN" => Ok(Self::IsolatedMargin),
                "USDT_FUTURE" => Ok(Self::UsdtFuture),
                "COIN_FUTURE" => Ok(Self::CoinFuture),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str>
    for ManagedSubaccountQueryTransLogTransferFunctionAccountType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String>
    for ManagedSubaccountQueryTransLogTransferFunctionAccountType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String>
    for ManagedSubaccountQueryTransLogTransferFunctionAccountType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///ManagedSubaccountQueryTransLogTransfers
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "FROM",
    ///    "TO"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum ManagedSubaccountQueryTransLogTransfers {
        #[serde(rename = "FROM")]
        From,
        #[serde(rename = "TO")]
        To,
    }
    impl From<&ManagedSubaccountQueryTransLogTransfers>
    for ManagedSubaccountQueryTransLogTransfers {
        fn from(value: &ManagedSubaccountQueryTransLogTransfers) -> Self {
            value.clone()
        }
    }
    impl ToString for ManagedSubaccountQueryTransLogTransfers {
        fn to_string(&self) -> String {
            match *self {
                Self::From => "FROM".to_string(),
                Self::To => "TO".to_string(),
            }
        }
    }
    impl std::str::FromStr for ManagedSubaccountQueryTransLogTransfers {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "FROM" => Ok(Self::From),
                "TO" => Ok(Self::To),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for ManagedSubaccountQueryTransLogTransfers {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for ManagedSubaccountQueryTransLogTransfers {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for ManagedSubaccountQueryTransLogTransfers {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///ManagedSubaccountWithdrawResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "tranId"
    ///  ],
    ///  "properties": {
    ///    "tranId": {
    ///      "examples": [
    ///        66157362489
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct ManagedSubaccountWithdrawResponse {
        #[serde(rename = "tranId")]
        pub tran_id: i64,
    }
    impl From<&ManagedSubaccountWithdrawResponse> for ManagedSubaccountWithdrawResponse {
        fn from(value: &ManagedSubaccountWithdrawResponse) -> Self {
            value.clone()
        }
    }
    ///MarginAccountResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "borrowEnabled",
    ///    "marginLevel",
    ///    "totalAssetOfBtc",
    ///    "totalLiabilityOfBtc",
    ///    "totalNetAssetOfBtc",
    ///    "tradeEnabled",
    ///    "transferEnabled",
    ///    "userAssets"
    ///  ],
    ///  "properties": {
    ///    "borrowEnabled": {
    ///      "type": "boolean"
    ///    },
    ///    "marginLevel": {
    ///      "examples": [
    ///        "11.64405625"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalAssetOfBtc": {
    ///      "examples": [
    ///        "6.82728457"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalLiabilityOfBtc": {
    ///      "examples": [
    ///        "0.58633215"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalNetAssetOfBtc": {
    ///      "examples": [
    ///        "6.24095242"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "tradeEnabled": {
    ///      "type": "boolean"
    ///    },
    ///    "transferEnabled": {
    ///      "type": "boolean"
    ///    },
    ///    "userAssets": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "asset",
    ///          "borrowed",
    ///          "free",
    ///          "interest",
    ///          "locked",
    ///          "netAsset"
    ///        ],
    ///        "properties": {
    ///          "asset": {
    ///            "examples": [
    ///              "BTC"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "borrowed": {
    ///            "examples": [
    ///              "0.00000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "free": {
    ///            "examples": [
    ///              "0.00499500"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "interest": {
    ///            "examples": [
    ///              "0.00000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "locked": {
    ///            "examples": [
    ///              "0.00000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "netAsset": {
    ///            "examples": [
    ///              "0.00499500"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MarginAccountResponse {
        #[serde(rename = "borrowEnabled")]
        pub borrow_enabled: bool,
        #[serde(rename = "marginLevel")]
        pub margin_level: String,
        #[serde(rename = "totalAssetOfBtc")]
        pub total_asset_of_btc: String,
        #[serde(rename = "totalLiabilityOfBtc")]
        pub total_liability_of_btc: String,
        #[serde(rename = "totalNetAssetOfBtc")]
        pub total_net_asset_of_btc: String,
        #[serde(rename = "tradeEnabled")]
        pub trade_enabled: bool,
        #[serde(rename = "transferEnabled")]
        pub transfer_enabled: bool,
        #[serde(rename = "userAssets")]
        pub user_assets: Vec<MarginAccountResponseUserAssetsItem>,
    }
    impl From<&MarginAccountResponse> for MarginAccountResponse {
        fn from(value: &MarginAccountResponse) -> Self {
            value.clone()
        }
    }
    ///MarginAccountResponseUserAssetsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "asset",
    ///    "borrowed",
    ///    "free",
    ///    "interest",
    ///    "locked",
    ///    "netAsset"
    ///  ],
    ///  "properties": {
    ///    "asset": {
    ///      "examples": [
    ///        "BTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "borrowed": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "free": {
    ///      "examples": [
    ///        "0.00499500"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "interest": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "locked": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "netAsset": {
    ///      "examples": [
    ///        "0.00499500"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MarginAccountResponseUserAssetsItem {
        pub asset: String,
        pub borrowed: String,
        pub free: String,
        pub interest: String,
        pub locked: String,
        #[serde(rename = "netAsset")]
        pub net_asset: String,
    }
    impl From<&MarginAccountResponseUserAssetsItem>
    for MarginAccountResponseUserAssetsItem {
        fn from(value: &MarginAccountResponseUserAssetsItem) -> Self {
            value.clone()
        }
    }
    ///MarginAllAssetsResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "assetFullName",
    ///    "assetName",
    ///    "isBorrowable",
    ///    "isMortgageable",
    ///    "userMinBorrow",
    ///    "userMinRepay"
    ///  ],
    ///  "properties": {
    ///    "assetFullName": {
    ///      "examples": [
    ///        "Binance coin"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "assetName": {
    ///      "examples": [
    ///        "BNB"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "isBorrowable": {
    ///      "type": "boolean"
    ///    },
    ///    "isMortgageable": {
    ///      "type": "boolean"
    ///    },
    ///    "userMinBorrow": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "userMinRepay": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MarginAllAssetsResponseItem {
        #[serde(rename = "assetFullName")]
        pub asset_full_name: String,
        #[serde(rename = "assetName")]
        pub asset_name: String,
        #[serde(rename = "isBorrowable")]
        pub is_borrowable: bool,
        #[serde(rename = "isMortgageable")]
        pub is_mortgageable: bool,
        #[serde(rename = "userMinBorrow")]
        pub user_min_borrow: String,
        #[serde(rename = "userMinRepay")]
        pub user_min_repay: String,
    }
    impl From<&MarginAllAssetsResponseItem> for MarginAllAssetsResponseItem {
        fn from(value: &MarginAllAssetsResponseItem) -> Self {
            value.clone()
        }
    }
    ///MarginAllOrderListIsIsolated
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "TRUE",
    ///    "FALSE"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum MarginAllOrderListIsIsolated {
        #[serde(rename = "TRUE")]
        True,
        #[serde(rename = "FALSE")]
        False,
    }
    impl From<&MarginAllOrderListIsIsolated> for MarginAllOrderListIsIsolated {
        fn from(value: &MarginAllOrderListIsIsolated) -> Self {
            value.clone()
        }
    }
    impl ToString for MarginAllOrderListIsIsolated {
        fn to_string(&self) -> String {
            match *self {
                Self::True => "TRUE".to_string(),
                Self::False => "FALSE".to_string(),
            }
        }
    }
    impl std::str::FromStr for MarginAllOrderListIsIsolated {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "TRUE" => Ok(Self::True),
                "FALSE" => Ok(Self::False),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for MarginAllOrderListIsIsolated {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for MarginAllOrderListIsIsolated {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for MarginAllOrderListIsIsolated {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///MarginAllOrderListResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "contingencyType",
    ///    "isIsolated",
    ///    "listClientOrderId",
    ///    "listOrderStatus",
    ///    "listStatusType",
    ///    "orderListId",
    ///    "orders",
    ///    "symbol",
    ///    "transactionTime"
    ///  ],
    ///  "properties": {
    ///    "contingencyType": {
    ///      "examples": [
    ///        "OCO"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "isIsolated": {
    ///      "type": "boolean"
    ///    },
    ///    "listClientOrderId": {
    ///      "examples": [
    ///        "amEEAXryFzFwYF1FeRpUoZ"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "listOrderStatus": {
    ///      "examples": [
    ///        "EXECUTING"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "listStatusType": {
    ///      "examples": [
    ///        "EXEC_STARTED"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "orderListId": {
    ///      "examples": [
    ///        29
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "orders": {
    ///      "type": "array",
    ///      "items": {
    ///        "examples": [
    ///          [
    ///            {
    ///              "clientOrderId": "oD7aesZqjEGlZrbtRpy5zB",
    ///              "orderId": 4,
    ///              "symbol": "LTCBTC"
    ///            },
    ///            {
    ///              "clientOrderId": "Jr1h6xirOxgeJOUuYQS7V3",
    ///              "orderId": 5,
    ///              "symbol": "LTCBTC"
    ///            }
    ///          ]
    ///        ],
    ///        "type": "object",
    ///        "required": [
    ///          "clientOrderId",
    ///          "orderId",
    ///          "symbol"
    ///        ],
    ///        "properties": {
    ///          "clientOrderId": {
    ///            "type": "string"
    ///          },
    ///          "orderId": {
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "symbol": {
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "symbol": {
    ///      "examples": [
    ///        "LTCBTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "transactionTime": {
    ///      "examples": [
    ///        1565245913483
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MarginAllOrderListResponseItem {
        #[serde(rename = "contingencyType")]
        pub contingency_type: String,
        #[serde(rename = "isIsolated")]
        pub is_isolated: bool,
        #[serde(rename = "listClientOrderId")]
        pub list_client_order_id: String,
        #[serde(rename = "listOrderStatus")]
        pub list_order_status: String,
        #[serde(rename = "listStatusType")]
        pub list_status_type: String,
        #[serde(rename = "orderListId")]
        pub order_list_id: i64,
        pub orders: Vec<MarginAllOrderListResponseItemOrdersItem>,
        pub symbol: String,
        #[serde(rename = "transactionTime")]
        pub transaction_time: i64,
    }
    impl From<&MarginAllOrderListResponseItem> for MarginAllOrderListResponseItem {
        fn from(value: &MarginAllOrderListResponseItem) -> Self {
            value.clone()
        }
    }
    ///MarginAllOrderListResponseItemOrdersItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    [
    ///      {
    ///        "clientOrderId": "oD7aesZqjEGlZrbtRpy5zB",
    ///        "orderId": 4,
    ///        "symbol": "LTCBTC"
    ///      },
    ///      {
    ///        "clientOrderId": "Jr1h6xirOxgeJOUuYQS7V3",
    ///        "orderId": 5,
    ///        "symbol": "LTCBTC"
    ///      }
    ///    ]
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "clientOrderId",
    ///    "orderId",
    ///    "symbol"
    ///  ],
    ///  "properties": {
    ///    "clientOrderId": {
    ///      "type": "string"
    ///    },
    ///    "orderId": {
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "symbol": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MarginAllOrderListResponseItemOrdersItem {
        #[serde(rename = "clientOrderId")]
        pub client_order_id: String,
        #[serde(rename = "orderId")]
        pub order_id: i64,
        pub symbol: String,
    }
    impl From<&MarginAllOrderListResponseItemOrdersItem>
    for MarginAllOrderListResponseItemOrdersItem {
        fn from(value: &MarginAllOrderListResponseItemOrdersItem) -> Self {
            value.clone()
        }
    }
    ///MarginAllPairsResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "base",
    ///    "id",
    ///    "isBuyAllowed",
    ///    "isMarginTrade",
    ///    "isSellAllowed",
    ///    "quote",
    ///    "symbol"
    ///  ],
    ///  "properties": {
    ///    "base": {
    ///      "examples": [
    ///        "BNB"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "examples": [
    ///        351637150141315861
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "isBuyAllowed": {
    ///      "type": "boolean"
    ///    },
    ///    "isMarginTrade": {
    ///      "type": "boolean"
    ///    },
    ///    "isSellAllowed": {
    ///      "type": "boolean"
    ///    },
    ///    "quote": {
    ///      "examples": [
    ///        "BTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "symbol": {
    ///      "examples": [
    ///        "BNBBTC"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MarginAllPairsResponseItem {
        pub base: String,
        pub id: i64,
        #[serde(rename = "isBuyAllowed")]
        pub is_buy_allowed: bool,
        #[serde(rename = "isMarginTrade")]
        pub is_margin_trade: bool,
        #[serde(rename = "isSellAllowed")]
        pub is_sell_allowed: bool,
        pub quote: String,
        pub symbol: String,
    }
    impl From<&MarginAllPairsResponseItem> for MarginAllPairsResponseItem {
        fn from(value: &MarginAllPairsResponseItem) -> Self {
            value.clone()
        }
    }
    ///MarginAssetResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "assetFullName",
    ///    "assetName",
    ///    "isBorrowable",
    ///    "isMortgageable",
    ///    "userMinBorrow",
    ///    "userMinRepay"
    ///  ],
    ///  "properties": {
    ///    "assetFullName": {
    ///      "examples": [
    ///        "Binance Coin"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "assetName": {
    ///      "examples": [
    ///        "BNB"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "isBorrowable": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "isMortgageable": {
    ///      "type": "boolean"
    ///    },
    ///    "userMinBorrow": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "userMinRepay": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MarginAssetResponse {
        #[serde(rename = "assetFullName")]
        pub asset_full_name: String,
        #[serde(rename = "assetName")]
        pub asset_name: String,
        #[serde(rename = "isBorrowable")]
        pub is_borrowable: bool,
        #[serde(rename = "isMortgageable")]
        pub is_mortgageable: bool,
        #[serde(rename = "userMinBorrow")]
        pub user_min_borrow: String,
        #[serde(rename = "userMinRepay")]
        pub user_min_repay: String,
    }
    impl From<&MarginAssetResponse> for MarginAssetResponse {
        fn from(value: &MarginAssetResponse) -> Self {
            value.clone()
        }
    }
    ///MarginAvailableInventoryResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "assets",
    ///    "updateTime"
    ///  ],
    ///  "properties": {
    ///    "assets": {
    ///      "type": "object",
    ///      "required": [
    ///        "MATIC",
    ///        "SHIB",
    ///        "STPT",
    ///        "TVK"
    ///      ],
    ///      "properties": {
    ///        "MATIC": {
    ///          "examples": [
    ///            "100000000"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "SHIB": {
    ///          "examples": [
    ///            "97409653"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "STPT": {
    ///          "examples": [
    ///            "100000000"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "TVK": {
    ///          "examples": [
    ///            "100000000"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "updateTime": {
    ///      "examples": [
    ///        1699272487
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MarginAvailableInventoryResponse {
        pub assets: MarginAvailableInventoryResponseAssets,
        #[serde(rename = "updateTime")]
        pub update_time: i64,
    }
    impl From<&MarginAvailableInventoryResponse> for MarginAvailableInventoryResponse {
        fn from(value: &MarginAvailableInventoryResponse) -> Self {
            value.clone()
        }
    }
    ///MarginAvailableInventoryResponseAssets
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "MATIC",
    ///    "SHIB",
    ///    "STPT",
    ///    "TVK"
    ///  ],
    ///  "properties": {
    ///    "MATIC": {
    ///      "examples": [
    ///        "100000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "SHIB": {
    ///      "examples": [
    ///        "97409653"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "STPT": {
    ///      "examples": [
    ///        "100000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "TVK": {
    ///      "examples": [
    ///        "100000000"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MarginAvailableInventoryResponseAssets {
        #[serde(rename = "MATIC")]
        pub matic: String,
        #[serde(rename = "SHIB")]
        pub shib: String,
        #[serde(rename = "STPT")]
        pub stpt: String,
        #[serde(rename = "TVK")]
        pub tvk: String,
    }
    impl From<&MarginAvailableInventoryResponseAssets>
    for MarginAvailableInventoryResponseAssets {
        fn from(value: &MarginAvailableInventoryResponseAssets) -> Self {
            value.clone()
        }
    }
    ///MarginAvailableInventoryType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "MARGIN",
    ///    "ISOLATED"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum MarginAvailableInventoryType {
        #[serde(rename = "MARGIN")]
        Margin,
        #[serde(rename = "ISOLATED")]
        Isolated,
    }
    impl From<&MarginAvailableInventoryType> for MarginAvailableInventoryType {
        fn from(value: &MarginAvailableInventoryType) -> Self {
            value.clone()
        }
    }
    impl ToString for MarginAvailableInventoryType {
        fn to_string(&self) -> String {
            match *self {
                Self::Margin => "MARGIN".to_string(),
                Self::Isolated => "ISOLATED".to_string(),
            }
        }
    }
    impl std::str::FromStr for MarginAvailableInventoryType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "MARGIN" => Ok(Self::Margin),
                "ISOLATED" => Ok(Self::Isolated),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for MarginAvailableInventoryType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for MarginAvailableInventoryType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for MarginAvailableInventoryType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///MarginCancelOrdersIsIsolated
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "TRUE",
    ///    "FALSE"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum MarginCancelOrdersIsIsolated {
        #[serde(rename = "TRUE")]
        True,
        #[serde(rename = "FALSE")]
        False,
    }
    impl From<&MarginCancelOrdersIsIsolated> for MarginCancelOrdersIsIsolated {
        fn from(value: &MarginCancelOrdersIsIsolated) -> Self {
            value.clone()
        }
    }
    impl ToString for MarginCancelOrdersIsIsolated {
        fn to_string(&self) -> String {
            match *self {
                Self::True => "TRUE".to_string(),
                Self::False => "FALSE".to_string(),
            }
        }
    }
    impl std::str::FromStr for MarginCancelOrdersIsIsolated {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "TRUE" => Ok(Self::True),
                "FALSE" => Ok(Self::False),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for MarginCancelOrdersIsIsolated {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for MarginCancelOrdersIsIsolated {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for MarginCancelOrdersIsIsolated {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///MarginCancelOrdersResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "anyOf": [
    ///    {
    ///      "$ref": "#/components/schemas/canceledMarginOrderDetail"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/marginOcoOrder"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    #[serde(untagged)]
    pub enum MarginCancelOrdersResponseItem {
        CanceledMarginOrderDetail(CanceledMarginOrderDetail),
        MarginOcoOrder(MarginOcoOrder),
    }
    impl From<&MarginCancelOrdersResponseItem> for MarginCancelOrdersResponseItem {
        fn from(value: &MarginCancelOrdersResponseItem) -> Self {
            value.clone()
        }
    }
    impl From<CanceledMarginOrderDetail> for MarginCancelOrdersResponseItem {
        fn from(value: CanceledMarginOrderDetail) -> Self {
            Self::CanceledMarginOrderDetail(value)
        }
    }
    impl From<MarginOcoOrder> for MarginCancelOrdersResponseItem {
        fn from(value: MarginOcoOrder) -> Self {
            Self::MarginOcoOrder(value)
        }
    }
    ///MarginCapitalFlowResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "asset",
    ///    "id",
    ///    "symbol",
    ///    "timestamp",
    ///    "tranId",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "examples": [
    ///        "101"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "asset": {
    ///      "examples": [
    ///        "USDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "examples": [
    ///        123456
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "symbol": {
    ///      "examples": [
    ///        "BTCUSDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "timestamp": {
    ///      "examples": [
    ///        1691116657000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "tranId": {
    ///      "examples": [
    ///        123123
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "type": {
    ///      "examples": [
    ///        "BORROW"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MarginCapitalFlowResponseItem {
        pub amount: String,
        pub asset: String,
        pub id: i64,
        pub symbol: String,
        pub timestamp: i64,
        #[serde(rename = "tranId")]
        pub tran_id: i64,
        #[serde(rename = "type")]
        pub type_: String,
    }
    impl From<&MarginCapitalFlowResponseItem> for MarginCapitalFlowResponseItem {
        fn from(value: &MarginCapitalFlowResponseItem) -> Self {
            value.clone()
        }
    }
    ///MarginCapitalFlowType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "TRANSFER",
    ///    "BORROW",
    ///    "REPAY",
    ///    "BUY_INCOME",
    ///    "BUY_EXPENSE",
    ///    "SELL_INCOME",
    ///    "SELL_EXPENSE",
    ///    "TRADING_COMMISSION",
    ///    "BUY_LIQUIDATION",
    ///    "SELL_LIQUIDATION",
    ///    "REPAY_LIQUIDATION",
    ///    "OTHER_LIQUIDATION",
    ///    "LIQUIDATION_FEE",
    ///    "SMALL_BALANCE_CONVERT",
    ///    "COMMISSION_RETURN",
    ///    "SMALL_CONVERT"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum MarginCapitalFlowType {
        #[serde(rename = "TRANSFER")]
        Transfer,
        #[serde(rename = "BORROW")]
        Borrow,
        #[serde(rename = "REPAY")]
        Repay,
        #[serde(rename = "BUY_INCOME")]
        BuyIncome,
        #[serde(rename = "BUY_EXPENSE")]
        BuyExpense,
        #[serde(rename = "SELL_INCOME")]
        SellIncome,
        #[serde(rename = "SELL_EXPENSE")]
        SellExpense,
        #[serde(rename = "TRADING_COMMISSION")]
        TradingCommission,
        #[serde(rename = "BUY_LIQUIDATION")]
        BuyLiquidation,
        #[serde(rename = "SELL_LIQUIDATION")]
        SellLiquidation,
        #[serde(rename = "REPAY_LIQUIDATION")]
        RepayLiquidation,
        #[serde(rename = "OTHER_LIQUIDATION")]
        OtherLiquidation,
        #[serde(rename = "LIQUIDATION_FEE")]
        LiquidationFee,
        #[serde(rename = "SMALL_BALANCE_CONVERT")]
        SmallBalanceConvert,
        #[serde(rename = "COMMISSION_RETURN")]
        CommissionReturn,
        #[serde(rename = "SMALL_CONVERT")]
        SmallConvert,
    }
    impl From<&MarginCapitalFlowType> for MarginCapitalFlowType {
        fn from(value: &MarginCapitalFlowType) -> Self {
            value.clone()
        }
    }
    impl ToString for MarginCapitalFlowType {
        fn to_string(&self) -> String {
            match *self {
                Self::Transfer => "TRANSFER".to_string(),
                Self::Borrow => "BORROW".to_string(),
                Self::Repay => "REPAY".to_string(),
                Self::BuyIncome => "BUY_INCOME".to_string(),
                Self::BuyExpense => "BUY_EXPENSE".to_string(),
                Self::SellIncome => "SELL_INCOME".to_string(),
                Self::SellExpense => "SELL_EXPENSE".to_string(),
                Self::TradingCommission => "TRADING_COMMISSION".to_string(),
                Self::BuyLiquidation => "BUY_LIQUIDATION".to_string(),
                Self::SellLiquidation => "SELL_LIQUIDATION".to_string(),
                Self::RepayLiquidation => "REPAY_LIQUIDATION".to_string(),
                Self::OtherLiquidation => "OTHER_LIQUIDATION".to_string(),
                Self::LiquidationFee => "LIQUIDATION_FEE".to_string(),
                Self::SmallBalanceConvert => "SMALL_BALANCE_CONVERT".to_string(),
                Self::CommissionReturn => "COMMISSION_RETURN".to_string(),
                Self::SmallConvert => "SMALL_CONVERT".to_string(),
            }
        }
    }
    impl std::str::FromStr for MarginCapitalFlowType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "TRANSFER" => Ok(Self::Transfer),
                "BORROW" => Ok(Self::Borrow),
                "REPAY" => Ok(Self::Repay),
                "BUY_INCOME" => Ok(Self::BuyIncome),
                "BUY_EXPENSE" => Ok(Self::BuyExpense),
                "SELL_INCOME" => Ok(Self::SellIncome),
                "SELL_EXPENSE" => Ok(Self::SellExpense),
                "TRADING_COMMISSION" => Ok(Self::TradingCommission),
                "BUY_LIQUIDATION" => Ok(Self::BuyLiquidation),
                "SELL_LIQUIDATION" => Ok(Self::SellLiquidation),
                "REPAY_LIQUIDATION" => Ok(Self::RepayLiquidation),
                "OTHER_LIQUIDATION" => Ok(Self::OtherLiquidation),
                "LIQUIDATION_FEE" => Ok(Self::LiquidationFee),
                "SMALL_BALANCE_CONVERT" => Ok(Self::SmallBalanceConvert),
                "COMMISSION_RETURN" => Ok(Self::CommissionReturn),
                "SMALL_CONVERT" => Ok(Self::SmallConvert),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for MarginCapitalFlowType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for MarginCapitalFlowType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for MarginCapitalFlowType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///MarginCrossMarginCollateralRatioResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "assetNames",
    ///    "collaterals"
    ///  ],
    ///  "properties": {
    ///    "assetNames": {
    ///      "type": "array",
    ///      "items": {
    ///        "examples": [
    ///          "BNX"
    ///        ],
    ///        "type": "string"
    ///      }
    ///    },
    ///    "collaterals": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "discountRate",
    ///          "maxUsdValue",
    ///          "minUsdValue"
    ///        ],
    ///        "properties": {
    ///          "discountRate": {
    ///            "examples": [
    ///              "1"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "maxUsdValue": {
    ///            "examples": [
    ///              "13000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "minUsdValue": {
    ///            "examples": [
    ///              "0"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MarginCrossMarginCollateralRatioResponseItem {
        #[serde(rename = "assetNames")]
        pub asset_names: Vec<String>,
        pub collaterals: Vec<
            MarginCrossMarginCollateralRatioResponseItemCollateralsItem,
        >,
    }
    impl From<&MarginCrossMarginCollateralRatioResponseItem>
    for MarginCrossMarginCollateralRatioResponseItem {
        fn from(value: &MarginCrossMarginCollateralRatioResponseItem) -> Self {
            value.clone()
        }
    }
    ///MarginCrossMarginCollateralRatioResponseItemCollateralsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "discountRate",
    ///    "maxUsdValue",
    ///    "minUsdValue"
    ///  ],
    ///  "properties": {
    ///    "discountRate": {
    ///      "examples": [
    ///        "1"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "maxUsdValue": {
    ///      "examples": [
    ///        "13000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "minUsdValue": {
    ///      "examples": [
    ///        "0"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MarginCrossMarginCollateralRatioResponseItemCollateralsItem {
        #[serde(rename = "discountRate")]
        pub discount_rate: String,
        #[serde(rename = "maxUsdValue")]
        pub max_usd_value: String,
        #[serde(rename = "minUsdValue")]
        pub min_usd_value: String,
    }
    impl From<&MarginCrossMarginCollateralRatioResponseItemCollateralsItem>
    for MarginCrossMarginCollateralRatioResponseItemCollateralsItem {
        fn from(
            value: &MarginCrossMarginCollateralRatioResponseItemCollateralsItem,
        ) -> Self {
            value.clone()
        }
    }
    ///MarginCrossMarginDataResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "borrowLimit",
    ///    "borrowable",
    ///    "coin",
    ///    "dailyInterest",
    ///    "marginablePairs",
    ///    "transferIn",
    ///    "vipLevel",
    ///    "yearlyInterest"
    ///  ],
    ///  "properties": {
    ///    "borrowLimit": {
    ///      "examples": [
    ///        "180"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "borrowable": {
    ///      "type": "boolean"
    ///    },
    ///    "coin": {
    ///      "examples": [
    ///        "BTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "dailyInterest": {
    ///      "examples": [
    ///        "0.00026125"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "marginablePairs": {
    ///      "examples": [
    ///        [
    ///          "BNBBTC",
    ///          "TRXBTC",
    ///          "ETHBTC",
    ///          "BTCUSDT"
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string"
    ///      }
    ///    },
    ///    "transferIn": {
    ///      "type": "boolean"
    ///    },
    ///    "vipLevel": {
    ///      "examples": [
    ///        0
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    },
    ///    "yearlyInterest": {
    ///      "examples": [
    ///        "0.0953"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MarginCrossMarginDataResponseItem {
        #[serde(rename = "borrowLimit")]
        pub borrow_limit: String,
        pub borrowable: bool,
        pub coin: String,
        #[serde(rename = "dailyInterest")]
        pub daily_interest: String,
        #[serde(rename = "marginablePairs")]
        pub marginable_pairs: Vec<String>,
        #[serde(rename = "transferIn")]
        pub transfer_in: bool,
        #[serde(rename = "vipLevel")]
        pub vip_level: i32,
        #[serde(rename = "yearlyInterest")]
        pub yearly_interest: String,
    }
    impl From<&MarginCrossMarginDataResponseItem> for MarginCrossMarginDataResponseItem {
        fn from(value: &MarginCrossMarginDataResponseItem) -> Self {
            value.clone()
        }
    }
    ///MarginDelistScheduleResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "crossMarginAssets": {
    ///      "type": "array",
    ///      "items": {
    ///        "examples": [
    ///          "BTC"
    ///        ],
    ///        "type": "string"
    ///      }
    ///    },
    ///    "delistTime": {
    ///      "examples": [
    ///        1686161202000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "isolatedMarginSymbols": {
    ///      "type": "array",
    ///      "items": {
    ///        "examples": [
    ///          "BNBUSDT"
    ///        ],
    ///        "type": "string"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MarginDelistScheduleResponseItem {
        #[serde(
            rename = "crossMarginAssets",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub cross_margin_assets: Vec<String>,
        #[serde(rename = "delistTime", default, skip_serializing_if = "Option::is_none")]
        pub delist_time: Option<i64>,
        #[serde(
            rename = "isolatedMarginSymbols",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub isolated_margin_symbols: Vec<String>,
    }
    impl From<&MarginDelistScheduleResponseItem> for MarginDelistScheduleResponseItem {
        fn from(value: &MarginDelistScheduleResponseItem) -> Self {
            value.clone()
        }
    }
    ///MarginDribbletResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "total",
    ///    "userAssetDribblets"
    ///  ],
    ///  "properties": {
    ///    "total": {
    ///      "examples": [
    ///        8
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "userAssetDribblets": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "operateTime",
    ///          "totalServiceChargeAmount",
    ///          "totalTransferedAmount",
    ///          "transId",
    ///          "userAssetDribbletDetails"
    ///        ],
    ///        "properties": {
    ///          "operateTime": {
    ///            "examples": [
    ///              1615985535000
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "totalServiceChargeAmount": {
    ///            "examples": [
    ///              "0.00002699"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "totalTransferedAmount": {
    ///            "examples": [
    ///              "0.00132256"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "transId": {
    ///            "examples": [
    ///              45178372831
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "userAssetDribbletDetails": {
    ///            "type": "array",
    ///            "items": {
    ///              "type": "object",
    ///              "required": [
    ///                "amount",
    ///                "fromAsset",
    ///                "operateTime",
    ///                "serviceChargeAmount",
    ///                "transId",
    ///                "transferedAmount"
    ///              ],
    ///              "properties": {
    ///                "amount": {
    ///                  "examples": [
    ///                    "0.0009"
    ///                  ],
    ///                  "type": "string"
    ///                },
    ///                "fromAsset": {
    ///                  "examples": [
    ///                    "USDT"
    ///                  ],
    ///                  "type": "string"
    ///                },
    ///                "operateTime": {
    ///                  "examples": [
    ///                    1615985535000
    ///                  ],
    ///                  "type": "integer",
    ///                  "format": "int64"
    ///                },
    ///                "serviceChargeAmount": {
    ///                  "examples": [
    ///                    "0.000009"
    ///                  ],
    ///                  "type": "string"
    ///                },
    ///                "transId": {
    ///                  "examples": [
    ///                    4359321
    ///                  ],
    ///                  "type": "integer",
    ///                  "format": "int64"
    ///                },
    ///                "transferedAmount": {
    ///                  "examples": [
    ///                    "0.000441"
    ///                  ],
    ///                  "type": "string"
    ///                }
    ///              }
    ///            }
    ///          }
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MarginDribbletResponse {
        pub total: i64,
        #[serde(rename = "userAssetDribblets")]
        pub user_asset_dribblets: Vec<MarginDribbletResponseUserAssetDribbletsItem>,
    }
    impl From<&MarginDribbletResponse> for MarginDribbletResponse {
        fn from(value: &MarginDribbletResponse) -> Self {
            value.clone()
        }
    }
    ///MarginDribbletResponseUserAssetDribbletsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "operateTime",
    ///    "totalServiceChargeAmount",
    ///    "totalTransferedAmount",
    ///    "transId",
    ///    "userAssetDribbletDetails"
    ///  ],
    ///  "properties": {
    ///    "operateTime": {
    ///      "examples": [
    ///        1615985535000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "totalServiceChargeAmount": {
    ///      "examples": [
    ///        "0.00002699"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalTransferedAmount": {
    ///      "examples": [
    ///        "0.00132256"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "transId": {
    ///      "examples": [
    ///        45178372831
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "userAssetDribbletDetails": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "amount",
    ///          "fromAsset",
    ///          "operateTime",
    ///          "serviceChargeAmount",
    ///          "transId",
    ///          "transferedAmount"
    ///        ],
    ///        "properties": {
    ///          "amount": {
    ///            "examples": [
    ///              "0.0009"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "fromAsset": {
    ///            "examples": [
    ///              "USDT"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "operateTime": {
    ///            "examples": [
    ///              1615985535000
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "serviceChargeAmount": {
    ///            "examples": [
    ///              "0.000009"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "transId": {
    ///            "examples": [
    ///              4359321
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "transferedAmount": {
    ///            "examples": [
    ///              "0.000441"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MarginDribbletResponseUserAssetDribbletsItem {
        #[serde(rename = "operateTime")]
        pub operate_time: i64,
        #[serde(rename = "totalServiceChargeAmount")]
        pub total_service_charge_amount: String,
        #[serde(rename = "totalTransferedAmount")]
        pub total_transfered_amount: String,
        #[serde(rename = "transId")]
        pub trans_id: i64,
        #[serde(rename = "userAssetDribbletDetails")]
        pub user_asset_dribblet_details: Vec<
            MarginDribbletResponseUserAssetDribbletsItemUserAssetDribbletDetailsItem,
        >,
    }
    impl From<&MarginDribbletResponseUserAssetDribbletsItem>
    for MarginDribbletResponseUserAssetDribbletsItem {
        fn from(value: &MarginDribbletResponseUserAssetDribbletsItem) -> Self {
            value.clone()
        }
    }
    ///MarginDribbletResponseUserAssetDribbletsItemUserAssetDribbletDetailsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "fromAsset",
    ///    "operateTime",
    ///    "serviceChargeAmount",
    ///    "transId",
    ///    "transferedAmount"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "examples": [
    ///        "0.0009"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "fromAsset": {
    ///      "examples": [
    ///        "USDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "operateTime": {
    ///      "examples": [
    ///        1615985535000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "serviceChargeAmount": {
    ///      "examples": [
    ///        "0.000009"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "transId": {
    ///      "examples": [
    ///        4359321
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "transferedAmount": {
    ///      "examples": [
    ///        "0.000441"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MarginDribbletResponseUserAssetDribbletsItemUserAssetDribbletDetailsItem {
        pub amount: String,
        #[serde(rename = "fromAsset")]
        pub from_asset: String,
        #[serde(rename = "operateTime")]
        pub operate_time: i64,
        #[serde(rename = "serviceChargeAmount")]
        pub service_charge_amount: String,
        #[serde(rename = "transId")]
        pub trans_id: i64,
        #[serde(rename = "transferedAmount")]
        pub transfered_amount: String,
    }
    impl From<&MarginDribbletResponseUserAssetDribbletsItemUserAssetDribbletDetailsItem>
    for MarginDribbletResponseUserAssetDribbletsItemUserAssetDribbletDetailsItem {
        fn from(
            value: &MarginDribbletResponseUserAssetDribbletsItemUserAssetDribbletDetailsItem,
        ) -> Self {
            value.clone()
        }
    }
    ///MarginDustResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "details",
    ///    "dribbletPercentage",
    ///    "totalTransferBNB",
    ///    "totalTransferBtc"
    ///  ],
    ///  "properties": {
    ///    "details": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "amountFree",
    ///          "asset",
    ///          "assetFullName",
    ///          "exchange",
    ///          "toBNB",
    ///          "toBNBOffExchange",
    ///          "toBTC"
    ///        ],
    ///        "properties": {
    ///          "amountFree": {
    ///            "examples": [
    ///              "6.21"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "asset": {
    ///            "examples": [
    ///              "BTC"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "assetFullName": {
    ///            "examples": [
    ///              "ADA"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "exchange": {
    ///            "examples": [
    ///              "0.00035546"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "toBNB": {
    ///            "examples": [
    ///              "0.01777302"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "toBNBOffExchange": {
    ///            "examples": [
    ///              "0.01741756"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "toBTC": {
    ///            "examples": [
    ///              "0.00016848"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "dribbletPercentage": {
    ///      "examples": [
    ///        "0.02"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalTransferBNB": {
    ///      "examples": [
    ///        "0.01777302"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalTransferBtc": {
    ///      "examples": [
    ///        "0.00016848"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MarginDustResponse {
        pub details: Vec<MarginDustResponseDetailsItem>,
        #[serde(rename = "dribbletPercentage")]
        pub dribblet_percentage: String,
        #[serde(rename = "totalTransferBNB")]
        pub total_transfer_bnb: String,
        #[serde(rename = "totalTransferBtc")]
        pub total_transfer_btc: String,
    }
    impl From<&MarginDustResponse> for MarginDustResponse {
        fn from(value: &MarginDustResponse) -> Self {
            value.clone()
        }
    }
    ///MarginDustResponseDetailsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "amountFree",
    ///    "asset",
    ///    "assetFullName",
    ///    "exchange",
    ///    "toBNB",
    ///    "toBNBOffExchange",
    ///    "toBTC"
    ///  ],
    ///  "properties": {
    ///    "amountFree": {
    ///      "examples": [
    ///        "6.21"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "asset": {
    ///      "examples": [
    ///        "BTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "assetFullName": {
    ///      "examples": [
    ///        "ADA"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "exchange": {
    ///      "examples": [
    ///        "0.00035546"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "toBNB": {
    ///      "examples": [
    ///        "0.01777302"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "toBNBOffExchange": {
    ///      "examples": [
    ///        "0.01741756"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "toBTC": {
    ///      "examples": [
    ///        "0.00016848"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MarginDustResponseDetailsItem {
        #[serde(rename = "amountFree")]
        pub amount_free: String,
        pub asset: String,
        #[serde(rename = "assetFullName")]
        pub asset_full_name: String,
        pub exchange: String,
        #[serde(rename = "toBNB")]
        pub to_bnb: String,
        #[serde(rename = "toBNBOffExchange")]
        pub to_bnb_off_exchange: String,
        #[serde(rename = "toBTC")]
        pub to_btc: String,
    }
    impl From<&MarginDustResponseDetailsItem> for MarginDustResponseDetailsItem {
        fn from(value: &MarginDustResponseDetailsItem) -> Self {
            value.clone()
        }
    }
    ///MarginExchangeSmallLiabilityHistoryResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "rows",
    ///    "total"
    ///  ],
    ///  "properties": {
    ///    "rows": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "amount",
    ///          "asset",
    ///          "bizType",
    ///          "targetAmount",
    ///          "targetAsset",
    ///          "timestamp"
    ///        ],
    ///        "properties": {
    ///          "amount": {
    ///            "examples": [
    ///              "0.00083434"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "asset": {
    ///            "examples": [
    ///              "ETH"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "bizType": {
    ///            "examples": [
    ///              "EXCHANGE_SMALL_LIABILITY"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "targetAmount": {
    ///            "examples": [
    ///              "1.37576819"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "targetAsset": {
    ///            "examples": [
    ///              "BUSD"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "timestamp": {
    ///            "examples": [
    ///              1672801339253
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "total": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MarginExchangeSmallLiabilityHistoryResponse {
        pub rows: Vec<MarginExchangeSmallLiabilityHistoryResponseRowsItem>,
        pub total: i64,
    }
    impl From<&MarginExchangeSmallLiabilityHistoryResponse>
    for MarginExchangeSmallLiabilityHistoryResponse {
        fn from(value: &MarginExchangeSmallLiabilityHistoryResponse) -> Self {
            value.clone()
        }
    }
    ///MarginExchangeSmallLiabilityHistoryResponseRowsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "asset",
    ///    "bizType",
    ///    "targetAmount",
    ///    "targetAsset",
    ///    "timestamp"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "examples": [
    ///        "0.00083434"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "asset": {
    ///      "examples": [
    ///        "ETH"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "bizType": {
    ///      "examples": [
    ///        "EXCHANGE_SMALL_LIABILITY"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "targetAmount": {
    ///      "examples": [
    ///        "1.37576819"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "targetAsset": {
    ///      "examples": [
    ///        "BUSD"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "timestamp": {
    ///      "examples": [
    ///        1672801339253
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MarginExchangeSmallLiabilityHistoryResponseRowsItem {
        pub amount: String,
        pub asset: String,
        #[serde(rename = "bizType")]
        pub biz_type: String,
        #[serde(rename = "targetAmount")]
        pub target_amount: String,
        #[serde(rename = "targetAsset")]
        pub target_asset: String,
        pub timestamp: i64,
    }
    impl From<&MarginExchangeSmallLiabilityHistoryResponseRowsItem>
    for MarginExchangeSmallLiabilityHistoryResponseRowsItem {
        fn from(value: &MarginExchangeSmallLiabilityHistoryResponseRowsItem) -> Self {
            value.clone()
        }
    }
    ///MarginExchangeSmallLiabilityResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "asset",
    ///    "interest",
    ///    "liabilityAsset",
    ///    "liabilityQty",
    ///    "principal"
    ///  ],
    ///  "properties": {
    ///    "asset": {
    ///      "examples": [
    ///        "ETH"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "interest": {
    ///      "examples": [
    ///        "0.00083334"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "liabilityAsset": {
    ///      "examples": [
    ///        "USDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "liabilityQty": {
    ///      "examples": [
    ///        0.3552
    ///      ],
    ///      "type": "number",
    ///      "format": "float"
    ///    },
    ///    "principal": {
    ///      "examples": [
    ///        "0.001"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MarginExchangeSmallLiabilityResponseItem {
        pub asset: String,
        pub interest: String,
        #[serde(rename = "liabilityAsset")]
        pub liability_asset: String,
        #[serde(rename = "liabilityQty")]
        pub liability_qty: f32,
        pub principal: String,
    }
    impl From<&MarginExchangeSmallLiabilityResponseItem>
    for MarginExchangeSmallLiabilityResponseItem {
        fn from(value: &MarginExchangeSmallLiabilityResponseItem) -> Self {
            value.clone()
        }
    }
    ///MarginForceLiquidationRecResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    {
    ///      "rows": [
    ///        {
    ///          "avgPrice": "0.00388359",
    ///          "executedQty": "31.39000000",
    ///          "isIsolated": true,
    ///          "orderId": 180015097,
    ///          "price": "0.00388110",
    ///          "qty": "31.39000000",
    ///          "side": "SELL",
    ///          "symbol": "BNBBTC",
    ///          "timeInForce": "GTC",
    ///          "updatedTime": 1558941374745
    ///        }
    ///      ],
    ///      "total": 1
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "rows",
    ///    "total"
    ///  ],
    ///  "properties": {
    ///    "rows": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "avgPrice",
    ///          "executedQty",
    ///          "isIsolated",
    ///          "orderId",
    ///          "price",
    ///          "qty",
    ///          "side",
    ///          "symbol",
    ///          "timeInForce",
    ///          "updatedTime"
    ///        ],
    ///        "properties": {
    ///          "avgPrice": {
    ///            "type": "string"
    ///          },
    ///          "executedQty": {
    ///            "type": "string"
    ///          },
    ///          "isIsolated": {
    ///            "type": "boolean"
    ///          },
    ///          "orderId": {
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "price": {
    ///            "type": "string"
    ///          },
    ///          "qty": {
    ///            "type": "string"
    ///          },
    ///          "side": {
    ///            "type": "string"
    ///          },
    ///          "symbol": {
    ///            "type": "string"
    ///          },
    ///          "timeInForce": {
    ///            "type": "string"
    ///          },
    ///          "updatedTime": {
    ///            "type": "integer",
    ///            "format": "int64"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "total": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MarginForceLiquidationRecResponse {
        pub rows: Vec<MarginForceLiquidationRecResponseRowsItem>,
        pub total: i32,
    }
    impl From<&MarginForceLiquidationRecResponse> for MarginForceLiquidationRecResponse {
        fn from(value: &MarginForceLiquidationRecResponse) -> Self {
            value.clone()
        }
    }
    ///MarginForceLiquidationRecResponseRowsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "avgPrice",
    ///    "executedQty",
    ///    "isIsolated",
    ///    "orderId",
    ///    "price",
    ///    "qty",
    ///    "side",
    ///    "symbol",
    ///    "timeInForce",
    ///    "updatedTime"
    ///  ],
    ///  "properties": {
    ///    "avgPrice": {
    ///      "type": "string"
    ///    },
    ///    "executedQty": {
    ///      "type": "string"
    ///    },
    ///    "isIsolated": {
    ///      "type": "boolean"
    ///    },
    ///    "orderId": {
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "price": {
    ///      "type": "string"
    ///    },
    ///    "qty": {
    ///      "type": "string"
    ///    },
    ///    "side": {
    ///      "type": "string"
    ///    },
    ///    "symbol": {
    ///      "type": "string"
    ///    },
    ///    "timeInForce": {
    ///      "type": "string"
    ///    },
    ///    "updatedTime": {
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MarginForceLiquidationRecResponseRowsItem {
        #[serde(rename = "avgPrice")]
        pub avg_price: String,
        #[serde(rename = "executedQty")]
        pub executed_qty: String,
        #[serde(rename = "isIsolated")]
        pub is_isolated: bool,
        #[serde(rename = "orderId")]
        pub order_id: i64,
        pub price: String,
        pub qty: String,
        pub side: String,
        pub symbol: String,
        #[serde(rename = "timeInForce")]
        pub time_in_force: String,
        #[serde(rename = "updatedTime")]
        pub updated_time: i64,
    }
    impl From<&MarginForceLiquidationRecResponseRowsItem>
    for MarginForceLiquidationRecResponseRowsItem {
        fn from(value: &MarginForceLiquidationRecResponseRowsItem) -> Self {
            value.clone()
        }
    }
    ///MarginInterestHistoryResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "rows",
    ///    "total"
    ///  ],
    ///  "properties": {
    ///    "rows": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "asset",
    ///          "interest",
    ///          "interestAccuredTime",
    ///          "interestRate",
    ///          "isolatedSymbol",
    ///          "principal",
    ///          "type"
    ///        ],
    ///        "properties": {
    ///          "asset": {
    ///            "examples": [
    ///              "BNB"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "interest": {
    ///            "examples": [
    ///              "0.01866667"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "interestAccuredTime": {
    ///            "examples": [
    ///              1566813600
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "interestRate": {
    ///            "examples": [
    ///              "0.01600000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "isolatedSymbol": {
    ///            "examples": [
    ///              "BNBUSDT"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "principal": {
    ///            "examples": [
    ///              "36.22000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "type": {
    ///            "examples": [
    ///              "ON_BORROW"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "total": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MarginInterestHistoryResponse {
        pub rows: Vec<MarginInterestHistoryResponseRowsItem>,
        pub total: i32,
    }
    impl From<&MarginInterestHistoryResponse> for MarginInterestHistoryResponse {
        fn from(value: &MarginInterestHistoryResponse) -> Self {
            value.clone()
        }
    }
    ///MarginInterestHistoryResponseRowsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "asset",
    ///    "interest",
    ///    "interestAccuredTime",
    ///    "interestRate",
    ///    "isolatedSymbol",
    ///    "principal",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "asset": {
    ///      "examples": [
    ///        "BNB"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "interest": {
    ///      "examples": [
    ///        "0.01866667"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "interestAccuredTime": {
    ///      "examples": [
    ///        1566813600
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "interestRate": {
    ///      "examples": [
    ///        "0.01600000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "isolatedSymbol": {
    ///      "examples": [
    ///        "BNBUSDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "principal": {
    ///      "examples": [
    ///        "36.22000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "examples": [
    ///        "ON_BORROW"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MarginInterestHistoryResponseRowsItem {
        pub asset: String,
        pub interest: String,
        #[serde(rename = "interestAccuredTime")]
        pub interest_accured_time: i64,
        #[serde(rename = "interestRate")]
        pub interest_rate: String,
        #[serde(rename = "isolatedSymbol")]
        pub isolated_symbol: String,
        pub principal: String,
        #[serde(rename = "type")]
        pub type_: String,
    }
    impl From<&MarginInterestHistoryResponseRowsItem>
    for MarginInterestHistoryResponseRowsItem {
        fn from(value: &MarginInterestHistoryResponseRowsItem) -> Self {
            value.clone()
        }
    }
    ///MarginInterestRateHistoryResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "asset",
    ///    "dailyInterestRate",
    ///    "timestamp",
    ///    "vipLevel"
    ///  ],
    ///  "properties": {
    ///    "asset": {
    ///      "examples": [
    ///        "BTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "dailyInterestRate": {
    ///      "examples": [
    ///        "0.00025000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "timestamp": {
    ///      "examples": [
    ///        1611544731000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "vipLevel": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MarginInterestRateHistoryResponseItem {
        pub asset: String,
        #[serde(rename = "dailyInterestRate")]
        pub daily_interest_rate: String,
        pub timestamp: i64,
        #[serde(rename = "vipLevel")]
        pub vip_level: i32,
    }
    impl From<&MarginInterestRateHistoryResponseItem>
    for MarginInterestRateHistoryResponseItem {
        fn from(value: &MarginInterestRateHistoryResponseItem) -> Self {
            value.clone()
        }
    }
    ///MarginIsolatedAccountLimitResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "enabledAccount",
    ///    "maxAccount"
    ///  ],
    ///  "properties": {
    ///    "enabledAccount": {
    ///      "examples": [
    ///        5
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "maxAccount": {
    ///      "examples": [
    ///        20
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MarginIsolatedAccountLimitResponse {
        #[serde(rename = "enabledAccount")]
        pub enabled_account: i64,
        #[serde(rename = "maxAccount")]
        pub max_account: i64,
    }
    impl From<&MarginIsolatedAccountLimitResponse>
    for MarginIsolatedAccountLimitResponse {
        fn from(value: &MarginIsolatedAccountLimitResponse) -> Self {
            value.clone()
        }
    }
    ///MarginIsolatedAllPairsResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "base",
    ///    "isBuyAllowed",
    ///    "isMarginTrade",
    ///    "isSellAllowed",
    ///    "quote",
    ///    "symbol"
    ///  ],
    ///  "properties": {
    ///    "base": {
    ///      "examples": [
    ///        "BTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "isBuyAllowed": {
    ///      "type": "boolean"
    ///    },
    ///    "isMarginTrade": {
    ///      "type": "boolean"
    ///    },
    ///    "isSellAllowed": {
    ///      "type": "boolean"
    ///    },
    ///    "quote": {
    ///      "examples": [
    ///        "USDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "symbol": {
    ///      "examples": [
    ///        "BTCUSDT"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MarginIsolatedAllPairsResponseItem {
        pub base: String,
        #[serde(rename = "isBuyAllowed")]
        pub is_buy_allowed: bool,
        #[serde(rename = "isMarginTrade")]
        pub is_margin_trade: bool,
        #[serde(rename = "isSellAllowed")]
        pub is_sell_allowed: bool,
        pub quote: String,
        pub symbol: String,
    }
    impl From<&MarginIsolatedAllPairsResponseItem>
    for MarginIsolatedAllPairsResponseItem {
        fn from(value: &MarginIsolatedAllPairsResponseItem) -> Self {
            value.clone()
        }
    }
    ///MarginIsolatedMarginDataResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "data": {
    ///      "examples": [
    ///        [
    ///          {
    ///            "borrowLimit": "270",
    ///            "coin": "BTC",
    ///            "dailyInterest": "0.00026125"
    ///          },
    ///          {
    ///            "borrowLimit": "2100000",
    ///            "coin": "USDT",
    ///            "dailyInterest": "0.000475"
    ///          }
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "properties": {
    ///          "borrowLimit": {
    ///            "type": "string"
    ///          },
    ///          "coin": {
    ///            "type": "string"
    ///          },
    ///          "dailyInterest": {
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "leverage": {
    ///      "examples": [
    ///        "10"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "symbol": {
    ///      "examples": [
    ///        "BTCUSDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "vipLevel": {
    ///      "examples": [
    ///        0
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MarginIsolatedMarginDataResponseItem {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub data: Vec<MarginIsolatedMarginDataResponseItemDataItem>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub leverage: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub symbol: Option<String>,
        #[serde(rename = "vipLevel", default, skip_serializing_if = "Option::is_none")]
        pub vip_level: Option<i32>,
    }
    impl From<&MarginIsolatedMarginDataResponseItem>
    for MarginIsolatedMarginDataResponseItem {
        fn from(value: &MarginIsolatedMarginDataResponseItem) -> Self {
            value.clone()
        }
    }
    ///MarginIsolatedMarginDataResponseItemDataItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "borrowLimit": {
    ///      "type": "string"
    ///    },
    ///    "coin": {
    ///      "type": "string"
    ///    },
    ///    "dailyInterest": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MarginIsolatedMarginDataResponseItemDataItem {
        #[serde(
            rename = "borrowLimit",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub borrow_limit: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub coin: Option<String>,
        #[serde(
            rename = "dailyInterest",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub daily_interest: Option<String>,
    }
    impl From<&MarginIsolatedMarginDataResponseItemDataItem>
    for MarginIsolatedMarginDataResponseItemDataItem {
        fn from(value: &MarginIsolatedMarginDataResponseItemDataItem) -> Self {
            value.clone()
        }
    }
    ///MarginIsolatedMarginTierResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "baseAssetMaxBorrowable": {
    ///      "examples": [
    ///        "9"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "effectiveMultiple": {
    ///      "examples": [
    ///        "10"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "initialRiskRatio": {
    ///      "examples": [
    ///        "1.111"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "liquidationRiskRatio": {
    ///      "examples": [
    ///        "1.05"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "quoteAssetMaxBorrowable": {
    ///      "examples": [
    ///        "70000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "symbol": {
    ///      "examples": [
    ///        "BTCUSDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "tier": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MarginIsolatedMarginTierResponseItem {
        #[serde(
            rename = "baseAssetMaxBorrowable",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub base_asset_max_borrowable: Option<String>,
        #[serde(
            rename = "effectiveMultiple",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub effective_multiple: Option<String>,
        #[serde(
            rename = "initialRiskRatio",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub initial_risk_ratio: Option<String>,
        #[serde(
            rename = "liquidationRiskRatio",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub liquidation_risk_ratio: Option<String>,
        #[serde(
            rename = "quoteAssetMaxBorrowable",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub quote_asset_max_borrowable: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub symbol: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub tier: Option<i32>,
    }
    impl From<&MarginIsolatedMarginTierResponseItem>
    for MarginIsolatedMarginTierResponseItem {
        fn from(value: &MarginIsolatedMarginTierResponseItem) -> Self {
            value.clone()
        }
    }
    ///MarginIsolatedPairResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "base",
    ///    "isBuyAllowed",
    ///    "isMarginTrade",
    ///    "isSellAllowed",
    ///    "quote",
    ///    "symbol"
    ///  ],
    ///  "properties": {
    ///    "base": {
    ///      "examples": [
    ///        "BTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "isBuyAllowed": {
    ///      "type": "boolean"
    ///    },
    ///    "isMarginTrade": {
    ///      "type": "boolean"
    ///    },
    ///    "isSellAllowed": {
    ///      "type": "boolean"
    ///    },
    ///    "quote": {
    ///      "examples": [
    ///        "USDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "symbol": {
    ///      "examples": [
    ///        "BTCUSDT"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MarginIsolatedPairResponse {
        pub base: String,
        #[serde(rename = "isBuyAllowed")]
        pub is_buy_allowed: bool,
        #[serde(rename = "isMarginTrade")]
        pub is_margin_trade: bool,
        #[serde(rename = "isSellAllowed")]
        pub is_sell_allowed: bool,
        pub quote: String,
        pub symbol: String,
    }
    impl From<&MarginIsolatedPairResponse> for MarginIsolatedPairResponse {
        fn from(value: &MarginIsolatedPairResponse) -> Self {
            value.clone()
        }
    }
    ///MarginLeverageBracketResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "assetNames",
    ///    "brackets",
    ///    "rank"
    ///  ],
    ///  "properties": {
    ///    "assetNames": {
    ///      "type": "array",
    ///      "items": {
    ///        "examples": [
    ///          "BTC"
    ///        ],
    ///        "type": "string"
    ///      }
    ///    },
    ///    "brackets": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "properties": {
    ///          "fastNum": {
    ///            "examples": [
    ///              60000.0
    ///            ],
    ///            "type": "number",
    ///            "format": "double"
    ///          },
    ///          "initialMarginRate": {
    ///            "examples": [
    ///              0.1112
    ///            ],
    ///            "type": "number",
    ///            "format": "double"
    ///          },
    ///          "leverage": {
    ///            "examples": [
    ///              10
    ///            ],
    ///            "type": "integer"
    ///          },
    ///          "maintenanceMarginRate": {
    ///            "examples": [
    ///              0.02
    ///            ],
    ///            "type": "number",
    ///            "format": "double"
    ///          },
    ///          "maxDebt": {
    ///            "examples": [
    ///              1000000.0
    ///            ],
    ///            "type": "number",
    ///            "format": "double"
    ///          }
    ///        }
    ///      },
    ///      "required": [
    ///        "fastNum",
    ///        "initialMarginRate",
    ///        "leverage",
    ///        "maintenanceMarginRate",
    ///        "maxDebt"
    ///      ]
    ///    },
    ///    "rank": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MarginLeverageBracketResponseItem {
        #[serde(rename = "assetNames")]
        pub asset_names: Vec<String>,
        pub brackets: Vec<MarginLeverageBracketResponseItemBracketsItem>,
        pub rank: i64,
    }
    impl From<&MarginLeverageBracketResponseItem> for MarginLeverageBracketResponseItem {
        fn from(value: &MarginLeverageBracketResponseItem) -> Self {
            value.clone()
        }
    }
    ///MarginLeverageBracketResponseItemBracketsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "fastNum": {
    ///      "examples": [
    ///        60000.0
    ///      ],
    ///      "type": "number",
    ///      "format": "double"
    ///    },
    ///    "initialMarginRate": {
    ///      "examples": [
    ///        0.1112
    ///      ],
    ///      "type": "number",
    ///      "format": "double"
    ///    },
    ///    "leverage": {
    ///      "examples": [
    ///        10
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "maintenanceMarginRate": {
    ///      "examples": [
    ///        0.02
    ///      ],
    ///      "type": "number",
    ///      "format": "double"
    ///    },
    ///    "maxDebt": {
    ///      "examples": [
    ///        1000000.0
    ///      ],
    ///      "type": "number",
    ///      "format": "double"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MarginLeverageBracketResponseItemBracketsItem {
        #[serde(rename = "fastNum", default, skip_serializing_if = "Option::is_none")]
        pub fast_num: Option<f64>,
        #[serde(
            rename = "initialMarginRate",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub initial_margin_rate: Option<f64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub leverage: Option<i64>,
        #[serde(
            rename = "maintenanceMarginRate",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub maintenance_margin_rate: Option<f64>,
        #[serde(rename = "maxDebt", default, skip_serializing_if = "Option::is_none")]
        pub max_debt: Option<f64>,
    }
    impl From<&MarginLeverageBracketResponseItemBracketsItem>
    for MarginLeverageBracketResponseItemBracketsItem {
        fn from(value: &MarginLeverageBracketResponseItemBracketsItem) -> Self {
            value.clone()
        }
    }
    ///MarginManualLiquidationResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "asset",
    ///    "interest",
    ///    "liabilityAsset",
    ///    "liabilityQty",
    ///    "principal"
    ///  ],
    ///  "properties": {
    ///    "asset": {
    ///      "examples": [
    ///        "ETH"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "interest": {
    ///      "examples": [
    ///        "0.00083334"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "liabilityAsset": {
    ///      "examples": [
    ///        "USDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "liabilityQty": {
    ///      "examples": [
    ///        0.3552
    ///      ],
    ///      "type": "number",
    ///      "format": "float"
    ///    },
    ///    "principal": {
    ///      "examples": [
    ///        "0.001"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MarginManualLiquidationResponseItem {
        pub asset: String,
        pub interest: String,
        #[serde(rename = "liabilityAsset")]
        pub liability_asset: String,
        #[serde(rename = "liabilityQty")]
        pub liability_qty: f32,
        pub principal: String,
    }
    impl From<&MarginManualLiquidationResponseItem>
    for MarginManualLiquidationResponseItem {
        fn from(value: &MarginManualLiquidationResponseItem) -> Self {
            value.clone()
        }
    }
    ///MarginManualLiquidationType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "MARGIN",
    ///    "ISOLATED"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum MarginManualLiquidationType {
        #[serde(rename = "MARGIN")]
        Margin,
        #[serde(rename = "ISOLATED")]
        Isolated,
    }
    impl From<&MarginManualLiquidationType> for MarginManualLiquidationType {
        fn from(value: &MarginManualLiquidationType) -> Self {
            value.clone()
        }
    }
    impl ToString for MarginManualLiquidationType {
        fn to_string(&self) -> String {
            match *self {
                Self::Margin => "MARGIN".to_string(),
                Self::Isolated => "ISOLATED".to_string(),
            }
        }
    }
    impl std::str::FromStr for MarginManualLiquidationType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "MARGIN" => Ok(Self::Margin),
                "ISOLATED" => Ok(Self::Isolated),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for MarginManualLiquidationType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for MarginManualLiquidationType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for MarginManualLiquidationType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///MarginMaxBorrowableResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "borrowLimit"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "description": "account's currently max borrowable amount with sufficient system availability",
    ///      "examples": [
    ///        "1.69248805"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "borrowLimit": {
    ///      "description": "max borrowable amount limited by the account level",
    ///      "examples": [
    ///        "60"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MarginMaxBorrowableResponse {
        ///account's currently max borrowable amount with sufficient system availability
        pub amount: String,
        ///max borrowable amount limited by the account level
        #[serde(rename = "borrowLimit")]
        pub borrow_limit: String,
    }
    impl From<&MarginMaxBorrowableResponse> for MarginMaxBorrowableResponse {
        fn from(value: &MarginMaxBorrowableResponse) -> Self {
            value.clone()
        }
    }
    ///MarginMaxLeverageResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "success"
    ///  ],
    ///  "properties": {
    ///    "success": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MarginMaxLeverageResponse {
        pub success: bool,
    }
    impl From<&MarginMaxLeverageResponse> for MarginMaxLeverageResponse {
        fn from(value: &MarginMaxLeverageResponse) -> Self {
            value.clone()
        }
    }
    ///MarginMaxTransferableResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    {
    ///      "amount": "1.69248805",
    ///      "borrowLimit": "60"
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "borrowLimit"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "description": "Account's currently max borrowable amount with sufficient system availability",
    ///      "type": "string"
    ///    },
    ///    "borrowLimit": {
    ///      "description": "Max borrowable amount limited by the account level",
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MarginMaxTransferableResponse {
        ///Account's currently max borrowable amount with sufficient system availability
        pub amount: String,
        ///Max borrowable amount limited by the account level
        #[serde(rename = "borrowLimit")]
        pub borrow_limit: String,
    }
    impl From<&MarginMaxTransferableResponse> for MarginMaxTransferableResponse {
        fn from(value: &MarginMaxTransferableResponse) -> Self {
            value.clone()
        }
    }
    ///MarginMyTradesIsIsolated
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "TRUE",
    ///    "FALSE"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum MarginMyTradesIsIsolated {
        #[serde(rename = "TRUE")]
        True,
        #[serde(rename = "FALSE")]
        False,
    }
    impl From<&MarginMyTradesIsIsolated> for MarginMyTradesIsIsolated {
        fn from(value: &MarginMyTradesIsIsolated) -> Self {
            value.clone()
        }
    }
    impl ToString for MarginMyTradesIsIsolated {
        fn to_string(&self) -> String {
            match *self {
                Self::True => "TRUE".to_string(),
                Self::False => "FALSE".to_string(),
            }
        }
    }
    impl std::str::FromStr for MarginMyTradesIsIsolated {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "TRUE" => Ok(Self::True),
                "FALSE" => Ok(Self::False),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for MarginMyTradesIsIsolated {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for MarginMyTradesIsIsolated {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for MarginMyTradesIsIsolated {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///MarginNextHourlyInterestRateIsIsolated
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "TRUE"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "TRUE",
    ///    "FALSE"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum MarginNextHourlyInterestRateIsIsolated {
        #[serde(rename = "TRUE")]
        True,
        #[serde(rename = "FALSE")]
        False,
    }
    impl From<&MarginNextHourlyInterestRateIsIsolated>
    for MarginNextHourlyInterestRateIsIsolated {
        fn from(value: &MarginNextHourlyInterestRateIsIsolated) -> Self {
            value.clone()
        }
    }
    impl ToString for MarginNextHourlyInterestRateIsIsolated {
        fn to_string(&self) -> String {
            match *self {
                Self::True => "TRUE".to_string(),
                Self::False => "FALSE".to_string(),
            }
        }
    }
    impl std::str::FromStr for MarginNextHourlyInterestRateIsIsolated {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "TRUE" => Ok(Self::True),
                "FALSE" => Ok(Self::False),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for MarginNextHourlyInterestRateIsIsolated {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for MarginNextHourlyInterestRateIsIsolated {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for MarginNextHourlyInterestRateIsIsolated {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///MarginNextHourlyInterestRateResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "asset",
    ///    "nextHourlyInterestRate"
    ///  ],
    ///  "properties": {
    ///    "asset": {
    ///      "examples": [
    ///        "BTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "nextHourlyInterestRate": {
    ///      "examples": [
    ///        "0.00000571"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MarginNextHourlyInterestRateResponseItem {
        pub asset: String,
        #[serde(rename = "nextHourlyInterestRate")]
        pub next_hourly_interest_rate: String,
    }
    impl From<&MarginNextHourlyInterestRateResponseItem>
    for MarginNextHourlyInterestRateResponseItem {
        fn from(value: &MarginNextHourlyInterestRateResponseItem) -> Self {
            value.clone()
        }
    }
    ///MarginOcoOrder
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "contingencyType",
    ///    "isIsolated",
    ///    "listClientOrderId",
    ///    "listOrderStatus",
    ///    "listStatusType",
    ///    "orderListId",
    ///    "orderReports",
    ///    "orders",
    ///    "symbol",
    ///    "transactionTime"
    ///  ],
    ///  "properties": {
    ///    "contingencyType": {
    ///      "examples": [
    ///        "OCO"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "isIsolated": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "listClientOrderId": {
    ///      "examples": [
    ///        "C3wyj4WVEktd7u9aVBRXcN"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "listOrderStatus": {
    ///      "examples": [
    ///        "ALL_DONE"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "listStatusType": {
    ///      "examples": [
    ///        "ALL_DONE"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "orderListId": {
    ///      "examples": [
    ///        0
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "orderReports": {
    ///      "type": "array",
    ///      "items": {
    ///        "examples": [
    ///          [
    ///            {
    ///              "clientOrderId": "unfWT8ig8i0uj6lPuYLez6",
    ///              "cummulativeQuoteQty": "0.00000000",
    ///              "executedQty": "0.00000000",
    ///              "orderId": 2,
    ///              "orderListId": 0,
    ///              "origClientOrderId": "pO9ufTiFGg3nw2fOdgeOXa",
    ///              "origQty": "10.00000000",
    ///              "price": "1.00000000",
    ///              "side": "SELL",
    ///              "status": "CANCELED",
    ///              "stopPrice": "1.00000000",
    ///              "symbol": "BNBUSDT",
    ///              "timeInForce": "GTC",
    ///              "type": "STOP_LOSS_LIMIT"
    ///            },
    ///            {
    ///              "clientOrderId": "unfWT8ig8i0uj6lPuYLez6",
    ///              "cummulativeQuoteQty": "0.00000000",
    ///              "executedQty": "0.00000000",
    ///              "orderId": 3,
    ///              "orderListId": 0,
    ///              "origClientOrderId": "TXOvglzXuaubXAaENpaRCB",
    ///              "origQty": "10.00000000",
    ///              "price": "3.00000000",
    ///              "side": "SELL",
    ///              "status": "CANCELED",
    ///              "symbol": "BNBUSDT",
    ///              "timeInForce": "GTC",
    ///              "type": "LIMIT_MAKER"
    ///            }
    ///          ]
    ///        ],
    ///        "type": "object",
    ///        "required": [
    ///          "clientOrderId",
    ///          "cummulativeQuoteQty",
    ///          "executedQty",
    ///          "orderId",
    ///          "orderListId",
    ///          "origClientOrderId",
    ///          "origQty",
    ///          "price",
    ///          "side",
    ///          "status",
    ///          "stopPrice",
    ///          "symbol",
    ///          "timeInForce",
    ///          "type"
    ///        ],
    ///        "properties": {
    ///          "clientOrderId": {
    ///            "type": "string"
    ///          },
    ///          "cummulativeQuoteQty": {
    ///            "type": "string"
    ///          },
    ///          "executedQty": {
    ///            "type": "string"
    ///          },
    ///          "orderId": {
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "orderListId": {
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "origClientOrderId": {
    ///            "type": "string"
    ///          },
    ///          "origQty": {
    ///            "type": "string"
    ///          },
    ///          "price": {
    ///            "type": "string"
    ///          },
    ///          "side": {
    ///            "type": "string"
    ///          },
    ///          "status": {
    ///            "type": "string"
    ///          },
    ///          "stopPrice": {
    ///            "type": "string"
    ///          },
    ///          "symbol": {
    ///            "type": "string"
    ///          },
    ///          "timeInForce": {
    ///            "type": "string"
    ///          },
    ///          "type": {
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "orders": {
    ///      "type": "array",
    ///      "items": {
    ///        "examples": [
    ///          [
    ///            {
    ///              "clientOrderId": "pO9ufTiFGg3nw2fOdgeOXa",
    ///              "orderId": 2,
    ///              "symbol": "BNBUSDT"
    ///            },
    ///            {
    ///              "clientOrderId": "TXOvglzXuaubXAaENpaRCB",
    ///              "orderId": 3,
    ///              "symbol": "BNBUSDT"
    ///            }
    ///          ]
    ///        ],
    ///        "type": "object",
    ///        "required": [
    ///          "clientOrderId",
    ///          "orderId",
    ///          "symbol"
    ///        ],
    ///        "properties": {
    ///          "clientOrderId": {
    ///            "type": "string"
    ///          },
    ///          "orderId": {
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "symbol": {
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "symbol": {
    ///      "examples": [
    ///        "BNBUSDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "transactionTime": {
    ///      "examples": [
    ///        1574040868128
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MarginOcoOrder {
        #[serde(rename = "contingencyType")]
        pub contingency_type: String,
        #[serde(rename = "isIsolated")]
        pub is_isolated: bool,
        #[serde(rename = "listClientOrderId")]
        pub list_client_order_id: String,
        #[serde(rename = "listOrderStatus")]
        pub list_order_status: String,
        #[serde(rename = "listStatusType")]
        pub list_status_type: String,
        #[serde(rename = "orderListId")]
        pub order_list_id: i64,
        #[serde(rename = "orderReports")]
        pub order_reports: Vec<MarginOcoOrderOrderReportsItem>,
        pub orders: Vec<MarginOcoOrderOrdersItem>,
        pub symbol: String,
        #[serde(rename = "transactionTime")]
        pub transaction_time: i64,
    }
    impl From<&MarginOcoOrder> for MarginOcoOrder {
        fn from(value: &MarginOcoOrder) -> Self {
            value.clone()
        }
    }
    ///MarginOcoOrderOrderReportsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    [
    ///      {
    ///        "clientOrderId": "unfWT8ig8i0uj6lPuYLez6",
    ///        "cummulativeQuoteQty": "0.00000000",
    ///        "executedQty": "0.00000000",
    ///        "orderId": 2,
    ///        "orderListId": 0,
    ///        "origClientOrderId": "pO9ufTiFGg3nw2fOdgeOXa",
    ///        "origQty": "10.00000000",
    ///        "price": "1.00000000",
    ///        "side": "SELL",
    ///        "status": "CANCELED",
    ///        "stopPrice": "1.00000000",
    ///        "symbol": "BNBUSDT",
    ///        "timeInForce": "GTC",
    ///        "type": "STOP_LOSS_LIMIT"
    ///      },
    ///      {
    ///        "clientOrderId": "unfWT8ig8i0uj6lPuYLez6",
    ///        "cummulativeQuoteQty": "0.00000000",
    ///        "executedQty": "0.00000000",
    ///        "orderId": 3,
    ///        "orderListId": 0,
    ///        "origClientOrderId": "TXOvglzXuaubXAaENpaRCB",
    ///        "origQty": "10.00000000",
    ///        "price": "3.00000000",
    ///        "side": "SELL",
    ///        "status": "CANCELED",
    ///        "symbol": "BNBUSDT",
    ///        "timeInForce": "GTC",
    ///        "type": "LIMIT_MAKER"
    ///      }
    ///    ]
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "clientOrderId",
    ///    "cummulativeQuoteQty",
    ///    "executedQty",
    ///    "orderId",
    ///    "orderListId",
    ///    "origClientOrderId",
    ///    "origQty",
    ///    "price",
    ///    "side",
    ///    "status",
    ///    "stopPrice",
    ///    "symbol",
    ///    "timeInForce",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "clientOrderId": {
    ///      "type": "string"
    ///    },
    ///    "cummulativeQuoteQty": {
    ///      "type": "string"
    ///    },
    ///    "executedQty": {
    ///      "type": "string"
    ///    },
    ///    "orderId": {
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "orderListId": {
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "origClientOrderId": {
    ///      "type": "string"
    ///    },
    ///    "origQty": {
    ///      "type": "string"
    ///    },
    ///    "price": {
    ///      "type": "string"
    ///    },
    ///    "side": {
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "type": "string"
    ///    },
    ///    "stopPrice": {
    ///      "type": "string"
    ///    },
    ///    "symbol": {
    ///      "type": "string"
    ///    },
    ///    "timeInForce": {
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MarginOcoOrderOrderReportsItem {
        #[serde(rename = "clientOrderId")]
        pub client_order_id: String,
        #[serde(rename = "cummulativeQuoteQty")]
        pub cummulative_quote_qty: String,
        #[serde(rename = "executedQty")]
        pub executed_qty: String,
        #[serde(rename = "orderId")]
        pub order_id: i64,
        #[serde(rename = "orderListId")]
        pub order_list_id: i64,
        #[serde(rename = "origClientOrderId")]
        pub orig_client_order_id: String,
        #[serde(rename = "origQty")]
        pub orig_qty: String,
        pub price: String,
        pub side: String,
        pub status: String,
        #[serde(rename = "stopPrice")]
        pub stop_price: String,
        pub symbol: String,
        #[serde(rename = "timeInForce")]
        pub time_in_force: String,
        #[serde(rename = "type")]
        pub type_: String,
    }
    impl From<&MarginOcoOrderOrderReportsItem> for MarginOcoOrderOrderReportsItem {
        fn from(value: &MarginOcoOrderOrderReportsItem) -> Self {
            value.clone()
        }
    }
    ///MarginOcoOrderOrdersItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    [
    ///      {
    ///        "clientOrderId": "pO9ufTiFGg3nw2fOdgeOXa",
    ///        "orderId": 2,
    ///        "symbol": "BNBUSDT"
    ///      },
    ///      {
    ///        "clientOrderId": "TXOvglzXuaubXAaENpaRCB",
    ///        "orderId": 3,
    ///        "symbol": "BNBUSDT"
    ///      }
    ///    ]
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "clientOrderId",
    ///    "orderId",
    ///    "symbol"
    ///  ],
    ///  "properties": {
    ///    "clientOrderId": {
    ///      "type": "string"
    ///    },
    ///    "orderId": {
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "symbol": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MarginOcoOrderOrdersItem {
        #[serde(rename = "clientOrderId")]
        pub client_order_id: String,
        #[serde(rename = "orderId")]
        pub order_id: i64,
        pub symbol: String,
    }
    impl From<&MarginOcoOrderOrdersItem> for MarginOcoOrderOrdersItem {
        fn from(value: &MarginOcoOrderOrdersItem) -> Self {
            value.clone()
        }
    }
    ///MarginOpenOrderListIsIsolated
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "TRUE",
    ///    "FALSE"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum MarginOpenOrderListIsIsolated {
        #[serde(rename = "TRUE")]
        True,
        #[serde(rename = "FALSE")]
        False,
    }
    impl From<&MarginOpenOrderListIsIsolated> for MarginOpenOrderListIsIsolated {
        fn from(value: &MarginOpenOrderListIsIsolated) -> Self {
            value.clone()
        }
    }
    impl ToString for MarginOpenOrderListIsIsolated {
        fn to_string(&self) -> String {
            match *self {
                Self::True => "TRUE".to_string(),
                Self::False => "FALSE".to_string(),
            }
        }
    }
    impl std::str::FromStr for MarginOpenOrderListIsIsolated {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "TRUE" => Ok(Self::True),
                "FALSE" => Ok(Self::False),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for MarginOpenOrderListIsIsolated {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for MarginOpenOrderListIsIsolated {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for MarginOpenOrderListIsIsolated {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///MarginOpenOrderListResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "contingencyType",
    ///    "isIsolated",
    ///    "listClientOrderId",
    ///    "listOrderStatus",
    ///    "listStatusType",
    ///    "orderListId",
    ///    "orders",
    ///    "symbol",
    ///    "transactionTime"
    ///  ],
    ///  "properties": {
    ///    "contingencyType": {
    ///      "examples": [
    ///        "OCO"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "isIsolated": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "listClientOrderId": {
    ///      "examples": [
    ///        "wuB13fmulKj3YjdqWEcsnp"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "listOrderStatus": {
    ///      "examples": [
    ///        "EXECUTING"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "listStatusType": {
    ///      "examples": [
    ///        "EXEC_STARTED"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "orderListId": {
    ///      "examples": [
    ///        31
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "orders": {
    ///      "type": "array",
    ///      "items": {
    ///        "examples": [
    ///          [
    ///            {
    ///              "clientOrderId": "r3EH2N76dHfLoSZWIUw1bT",
    ///              "orderId": 4,
    ///              "symbol": "LTCBTC"
    ///            },
    ///            {
    ///              "clientOrderId": "Cv1SnyPD3qhqpbjpYEHbd2",
    ///              "orderId": 5,
    ///              "symbol": "LTCBTC"
    ///            }
    ///          ]
    ///        ],
    ///        "type": "object",
    ///        "required": [
    ///          "clientOrderId",
    ///          "orderId",
    ///          "symbol"
    ///        ],
    ///        "properties": {
    ///          "clientOrderId": {
    ///            "type": "string"
    ///          },
    ///          "orderId": {
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "symbol": {
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "symbol": {
    ///      "examples": [
    ///        "LTCBTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "transactionTime": {
    ///      "examples": [
    ///        1565246080644
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MarginOpenOrderListResponseItem {
        #[serde(rename = "contingencyType")]
        pub contingency_type: String,
        #[serde(rename = "isIsolated")]
        pub is_isolated: bool,
        #[serde(rename = "listClientOrderId")]
        pub list_client_order_id: String,
        #[serde(rename = "listOrderStatus")]
        pub list_order_status: String,
        #[serde(rename = "listStatusType")]
        pub list_status_type: String,
        #[serde(rename = "orderListId")]
        pub order_list_id: i64,
        pub orders: Vec<MarginOpenOrderListResponseItemOrdersItem>,
        pub symbol: String,
        #[serde(rename = "transactionTime")]
        pub transaction_time: i64,
    }
    impl From<&MarginOpenOrderListResponseItem> for MarginOpenOrderListResponseItem {
        fn from(value: &MarginOpenOrderListResponseItem) -> Self {
            value.clone()
        }
    }
    ///MarginOpenOrderListResponseItemOrdersItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    [
    ///      {
    ///        "clientOrderId": "r3EH2N76dHfLoSZWIUw1bT",
    ///        "orderId": 4,
    ///        "symbol": "LTCBTC"
    ///      },
    ///      {
    ///        "clientOrderId": "Cv1SnyPD3qhqpbjpYEHbd2",
    ///        "orderId": 5,
    ///        "symbol": "LTCBTC"
    ///      }
    ///    ]
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "clientOrderId",
    ///    "orderId",
    ///    "symbol"
    ///  ],
    ///  "properties": {
    ///    "clientOrderId": {
    ///      "type": "string"
    ///    },
    ///    "orderId": {
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "symbol": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MarginOpenOrderListResponseItemOrdersItem {
        #[serde(rename = "clientOrderId")]
        pub client_order_id: String,
        #[serde(rename = "orderId")]
        pub order_id: i64,
        pub symbol: String,
    }
    impl From<&MarginOpenOrderListResponseItemOrdersItem>
    for MarginOpenOrderListResponseItemOrdersItem {
        fn from(value: &MarginOpenOrderListResponseItemOrdersItem) -> Self {
            value.clone()
        }
    }
    ///MarginOpenOrdersIsIsolated
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "TRUE",
    ///    "FALSE"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum MarginOpenOrdersIsIsolated {
        #[serde(rename = "TRUE")]
        True,
        #[serde(rename = "FALSE")]
        False,
    }
    impl From<&MarginOpenOrdersIsIsolated> for MarginOpenOrdersIsIsolated {
        fn from(value: &MarginOpenOrdersIsIsolated) -> Self {
            value.clone()
        }
    }
    impl ToString for MarginOpenOrdersIsIsolated {
        fn to_string(&self) -> String {
            match *self {
                Self::True => "TRUE".to_string(),
                Self::False => "FALSE".to_string(),
            }
        }
    }
    impl std::str::FromStr for MarginOpenOrdersIsIsolated {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "TRUE" => Ok(Self::True),
                "FALSE" => Ok(Self::False),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for MarginOpenOrdersIsIsolated {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for MarginOpenOrdersIsIsolated {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for MarginOpenOrdersIsIsolated {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///MarginOrder
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "clientOrderId",
    ///    "cummulativeQuoteQty",
    ///    "executedQty",
    ///    "orderId",
    ///    "origClientOrderId",
    ///    "origQty",
    ///    "price",
    ///    "side",
    ///    "status",
    ///    "symbol",
    ///    "timeInForce",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "clientOrderId": {
    ///      "examples": [
    ///        "6gCrw2kRUAF9CvJDGP16IP"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "cummulativeQuoteQty": {
    ///      "examples": [
    ///        "8.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "executedQty": {
    ///      "examples": [
    ///        "8.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "orderId": {
    ///      "examples": [
    ///        28
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "origClientOrderId": {
    ///      "examples": [
    ///        "msXkySR3u5uYwpvRMFsi3u"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "origQty": {
    ///      "examples": [
    ///        "10.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "price": {
    ///      "examples": [
    ///        "1.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "side": {
    ///      "examples": [
    ///        "SELL"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "examples": [
    ///        "CANCELED"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "symbol": {
    ///      "examples": [
    ///        "LTCBTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "timeInForce": {
    ///      "examples": [
    ///        "GTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "examples": [
    ///        "LIMIT"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MarginOrder {
        #[serde(rename = "clientOrderId")]
        pub client_order_id: String,
        #[serde(rename = "cummulativeQuoteQty")]
        pub cummulative_quote_qty: String,
        #[serde(rename = "executedQty")]
        pub executed_qty: String,
        #[serde(rename = "orderId")]
        pub order_id: i64,
        #[serde(rename = "origClientOrderId")]
        pub orig_client_order_id: String,
        #[serde(rename = "origQty")]
        pub orig_qty: String,
        pub price: String,
        pub side: String,
        pub status: String,
        pub symbol: String,
        #[serde(rename = "timeInForce")]
        pub time_in_force: String,
        #[serde(rename = "type")]
        pub type_: String,
    }
    impl From<&MarginOrder> for MarginOrder {
        fn from(value: &MarginOrder) -> Self {
            value.clone()
        }
    }
    ///MarginOrderDetail
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "clientOrderId",
    ///    "cummulativeQuoteQty",
    ///    "executedQty",
    ///    "icebergQty",
    ///    "isIsolated",
    ///    "isWorking",
    ///    "orderId",
    ///    "origQty",
    ///    "price",
    ///    "selfTradePreventionMode",
    ///    "side",
    ///    "status",
    ///    "stopPrice",
    ///    "symbol",
    ///    "time",
    ///    "timeInForce",
    ///    "type",
    ///    "updateTime"
    ///  ],
    ///  "properties": {
    ///    "clientOrderId": {
    ///      "examples": [
    ///        "ZwfQzuDIGpceVhKW5DvCmO"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "cummulativeQuoteQty": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "executedQty": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "icebergQty": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "isIsolated": {
    ///      "type": "boolean"
    ///    },
    ///    "isWorking": {
    ///      "type": "boolean"
    ///    },
    ///    "orderId": {
    ///      "examples": [
    ///        213205622
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "origQty": {
    ///      "examples": [
    ///        "0.30000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "price": {
    ///      "examples": [
    ///        "0.00493630"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "selfTradePreventionMode": {
    ///      "examples": [
    ///        "NONE"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "side": {
    ///      "examples": [
    ///        "SELL"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "examples": [
    ///        "NEW"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "stopPrice": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "symbol": {
    ///      "examples": [
    ///        "BNBBTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "time": {
    ///      "examples": [
    ///        1562133008725
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "timeInForce": {
    ///      "examples": [
    ///        "GTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "examples": [
    ///        "LIMIT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "updateTime": {
    ///      "examples": [
    ///        1562133008725
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MarginOrderDetail {
        #[serde(rename = "clientOrderId")]
        pub client_order_id: String,
        #[serde(rename = "cummulativeQuoteQty")]
        pub cummulative_quote_qty: String,
        #[serde(rename = "executedQty")]
        pub executed_qty: String,
        #[serde(rename = "icebergQty")]
        pub iceberg_qty: String,
        #[serde(rename = "isIsolated")]
        pub is_isolated: bool,
        #[serde(rename = "isWorking")]
        pub is_working: bool,
        #[serde(rename = "orderId")]
        pub order_id: i64,
        #[serde(rename = "origQty")]
        pub orig_qty: String,
        pub price: String,
        #[serde(rename = "selfTradePreventionMode")]
        pub self_trade_prevention_mode: String,
        pub side: String,
        pub status: String,
        #[serde(rename = "stopPrice")]
        pub stop_price: String,
        pub symbol: String,
        pub time: i64,
        #[serde(rename = "timeInForce")]
        pub time_in_force: String,
        #[serde(rename = "type")]
        pub type_: String,
        #[serde(rename = "updateTime")]
        pub update_time: i64,
    }
    impl From<&MarginOrderDetail> for MarginOrderDetail {
        fn from(value: &MarginOrderDetail) -> Self {
            value.clone()
        }
    }
    ///MarginOrderIsIsolated
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "TRUE",
    ///    "FALSE"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum MarginOrderIsIsolated {
        #[serde(rename = "TRUE")]
        True,
        #[serde(rename = "FALSE")]
        False,
    }
    impl From<&MarginOrderIsIsolated> for MarginOrderIsIsolated {
        fn from(value: &MarginOrderIsIsolated) -> Self {
            value.clone()
        }
    }
    impl ToString for MarginOrderIsIsolated {
        fn to_string(&self) -> String {
            match *self {
                Self::True => "TRUE".to_string(),
                Self::False => "FALSE".to_string(),
            }
        }
    }
    impl std::str::FromStr for MarginOrderIsIsolated {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "TRUE" => Ok(Self::True),
                "FALSE" => Ok(Self::False),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for MarginOrderIsIsolated {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for MarginOrderIsIsolated {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for MarginOrderIsIsolated {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///MarginOrderListIsIsolated
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "TRUE",
    ///    "FALSE"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum MarginOrderListIsIsolated {
        #[serde(rename = "TRUE")]
        True,
        #[serde(rename = "FALSE")]
        False,
    }
    impl From<&MarginOrderListIsIsolated> for MarginOrderListIsIsolated {
        fn from(value: &MarginOrderListIsIsolated) -> Self {
            value.clone()
        }
    }
    impl ToString for MarginOrderListIsIsolated {
        fn to_string(&self) -> String {
            match *self {
                Self::True => "TRUE".to_string(),
                Self::False => "FALSE".to_string(),
            }
        }
    }
    impl std::str::FromStr for MarginOrderListIsIsolated {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "TRUE" => Ok(Self::True),
                "FALSE" => Ok(Self::False),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for MarginOrderListIsIsolated {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for MarginOrderListIsIsolated {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for MarginOrderListIsIsolated {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///MarginOrderListResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "contingencyType",
    ///    "isIsolated",
    ///    "listClientOrderId",
    ///    "listOrderStatus",
    ///    "listStatusType",
    ///    "orderListId",
    ///    "orders",
    ///    "symbol",
    ///    "transactionTime"
    ///  ],
    ///  "properties": {
    ///    "contingencyType": {
    ///      "examples": [
    ///        "OCO"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "isIsolated": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "listClientOrderId": {
    ///      "examples": [
    ///        "h2USkA5YQpaXHPIrkd96xE"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "listOrderStatus": {
    ///      "examples": [
    ///        "EXECUTING"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "listStatusType": {
    ///      "examples": [
    ///        "EXEC_STARTED"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "orderListId": {
    ///      "examples": [
    ///        27
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "orders": {
    ///      "type": "array",
    ///      "items": {
    ///        "examples": [
    ///          [
    ///            {
    ///              "clientOrderId": "qD1gy3kc3Gx0rihm9Y3xwS",
    ///              "orderId": 4,
    ///              "symbol": "LTCBTC"
    ///            },
    ///            {
    ///              "clientOrderId": "ARzZ9I00CPM8i3NhmU9Ega",
    ///              "orderId": 5,
    ///              "symbol": "LTCBTC"
    ///            }
    ///          ]
    ///        ],
    ///        "type": "object",
    ///        "required": [
    ///          "clientOrderId",
    ///          "orderId",
    ///          "symbol"
    ///        ],
    ///        "properties": {
    ///          "clientOrderId": {
    ///            "type": "string"
    ///          },
    ///          "orderId": {
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "symbol": {
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "symbol": {
    ///      "examples": [
    ///        "LTCBTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "transactionTime": {
    ///      "examples": [
    ///        1565245656253
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MarginOrderListResponse {
        #[serde(rename = "contingencyType")]
        pub contingency_type: String,
        #[serde(rename = "isIsolated")]
        pub is_isolated: bool,
        #[serde(rename = "listClientOrderId")]
        pub list_client_order_id: String,
        #[serde(rename = "listOrderStatus")]
        pub list_order_status: String,
        #[serde(rename = "listStatusType")]
        pub list_status_type: String,
        #[serde(rename = "orderListId")]
        pub order_list_id: i64,
        pub orders: Vec<MarginOrderListResponseOrdersItem>,
        pub symbol: String,
        #[serde(rename = "transactionTime")]
        pub transaction_time: i64,
    }
    impl From<&MarginOrderListResponse> for MarginOrderListResponse {
        fn from(value: &MarginOrderListResponse) -> Self {
            value.clone()
        }
    }
    ///MarginOrderListResponseOrdersItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    [
    ///      {
    ///        "clientOrderId": "qD1gy3kc3Gx0rihm9Y3xwS",
    ///        "orderId": 4,
    ///        "symbol": "LTCBTC"
    ///      },
    ///      {
    ///        "clientOrderId": "ARzZ9I00CPM8i3NhmU9Ega",
    ///        "orderId": 5,
    ///        "symbol": "LTCBTC"
    ///      }
    ///    ]
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "clientOrderId",
    ///    "orderId",
    ///    "symbol"
    ///  ],
    ///  "properties": {
    ///    "clientOrderId": {
    ///      "type": "string"
    ///    },
    ///    "orderId": {
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "symbol": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MarginOrderListResponseOrdersItem {
        #[serde(rename = "clientOrderId")]
        pub client_order_id: String,
        #[serde(rename = "orderId")]
        pub order_id: i64,
        pub symbol: String,
    }
    impl From<&MarginOrderListResponseOrdersItem> for MarginOrderListResponseOrdersItem {
        fn from(value: &MarginOrderListResponseOrdersItem) -> Self {
            value.clone()
        }
    }
    ///MarginOrderResponseAck
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "clientOrderId",
    ///    "isIsolated",
    ///    "orderId",
    ///    "symbol",
    ///    "transactTime"
    ///  ],
    ///  "properties": {
    ///    "clientOrderId": {
    ///      "examples": [
    ///        "6gCrw2kRUAF9CvJDGP16IP"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "isIsolated": {
    ///      "type": "boolean"
    ///    },
    ///    "orderId": {
    ///      "examples": [
    ///        28
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "symbol": {
    ///      "examples": [
    ///        "BTCUSDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "transactTime": {
    ///      "examples": [
    ///        1507725176595
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MarginOrderResponseAck {
        #[serde(rename = "clientOrderId")]
        pub client_order_id: String,
        #[serde(rename = "isIsolated")]
        pub is_isolated: bool,
        #[serde(rename = "orderId")]
        pub order_id: i64,
        pub symbol: String,
        #[serde(rename = "transactTime")]
        pub transact_time: i64,
    }
    impl From<&MarginOrderResponseAck> for MarginOrderResponseAck {
        fn from(value: &MarginOrderResponseAck) -> Self {
            value.clone()
        }
    }
    ///MarginOrderResponseFull
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "clientOrderId",
    ///    "cummulativeQuoteQty",
    ///    "executedQty",
    ///    "fills",
    ///    "isIsolated",
    ///    "marginBuyBorrowAmount",
    ///    "marginBuyBorrowAsset",
    ///    "orderId",
    ///    "origQty",
    ///    "price",
    ///    "side",
    ///    "status",
    ///    "symbol",
    ///    "timeInForce",
    ///    "transactTime",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "clientOrderId": {
    ///      "examples": [
    ///        "6gCrw2kRUAF9CvJDGP16IP"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "cummulativeQuoteQty": {
    ///      "examples": [
    ///        "10.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "executedQty": {
    ///      "examples": [
    ///        "10.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "fills": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "commission",
    ///          "commissionAsset",
    ///          "price",
    ///          "qty"
    ///        ],
    ///        "properties": {
    ///          "commission": {
    ///            "examples": [
    ///              "4.00000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "commissionAsset": {
    ///            "examples": [
    ///              "USDT"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "price": {
    ///            "examples": [
    ///              "4000.00000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "qty": {
    ///            "examples": [
    ///              "1.00000000"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "isIsolated": {
    ///      "type": "boolean"
    ///    },
    ///    "marginBuyBorrowAmount": {
    ///      "description": "will not return if no margin trade happens",
    ///      "examples": [
    ///        5
    ///      ],
    ///      "type": "number",
    ///      "format": "double"
    ///    },
    ///    "marginBuyBorrowAsset": {
    ///      "description": "will not return if no margin trade happens",
    ///      "examples": [
    ///        "BTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "orderId": {
    ///      "examples": [
    ///        28
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "origQty": {
    ///      "examples": [
    ///        "10.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "price": {
    ///      "examples": [
    ///        "1.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "side": {
    ///      "examples": [
    ///        "SELL"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "examples": [
    ///        "FILLED"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "symbol": {
    ///      "examples": [
    ///        "BTCUSDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "timeInForce": {
    ///      "examples": [
    ///        "GTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "transactTime": {
    ///      "examples": [
    ///        1507725176595
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "type": {
    ///      "examples": [
    ///        "MARKET"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MarginOrderResponseFull {
        #[serde(rename = "clientOrderId")]
        pub client_order_id: String,
        #[serde(rename = "cummulativeQuoteQty")]
        pub cummulative_quote_qty: String,
        #[serde(rename = "executedQty")]
        pub executed_qty: String,
        pub fills: Vec<MarginOrderResponseFullFillsItem>,
        #[serde(rename = "isIsolated")]
        pub is_isolated: bool,
        #[serde(rename = "marginBuyBorrowAmount")]
        pub margin_buy_borrow_amount: f64,
        ///will not return if no margin trade happens
        #[serde(rename = "marginBuyBorrowAsset")]
        pub margin_buy_borrow_asset: String,
        #[serde(rename = "orderId")]
        pub order_id: i64,
        #[serde(rename = "origQty")]
        pub orig_qty: String,
        pub price: String,
        pub side: String,
        pub status: String,
        pub symbol: String,
        #[serde(rename = "timeInForce")]
        pub time_in_force: String,
        #[serde(rename = "transactTime")]
        pub transact_time: i64,
        #[serde(rename = "type")]
        pub type_: String,
    }
    impl From<&MarginOrderResponseFull> for MarginOrderResponseFull {
        fn from(value: &MarginOrderResponseFull) -> Self {
            value.clone()
        }
    }
    ///MarginOrderResponseFullFillsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "commission",
    ///    "commissionAsset",
    ///    "price",
    ///    "qty"
    ///  ],
    ///  "properties": {
    ///    "commission": {
    ///      "examples": [
    ///        "4.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "commissionAsset": {
    ///      "examples": [
    ///        "USDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "price": {
    ///      "examples": [
    ///        "4000.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "qty": {
    ///      "examples": [
    ///        "1.00000000"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MarginOrderResponseFullFillsItem {
        pub commission: String,
        #[serde(rename = "commissionAsset")]
        pub commission_asset: String,
        pub price: String,
        pub qty: String,
    }
    impl From<&MarginOrderResponseFullFillsItem> for MarginOrderResponseFullFillsItem {
        fn from(value: &MarginOrderResponseFullFillsItem) -> Self {
            value.clone()
        }
    }
    ///MarginOrderResponseResult
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "clientOrderId",
    ///    "cummulativeQuoteQty",
    ///    "executedQty",
    ///    "isIsolated",
    ///    "orderId",
    ///    "origQty",
    ///    "price",
    ///    "side",
    ///    "status",
    ///    "symbol",
    ///    "timeInForce",
    ///    "transactTime",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "clientOrderId": {
    ///      "examples": [
    ///        "6gCrw2kRUAF9CvJDGP16IP"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "cummulativeQuoteQty": {
    ///      "examples": [
    ///        "10.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "executedQty": {
    ///      "examples": [
    ///        "10.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "isIsolated": {
    ///      "type": "boolean"
    ///    },
    ///    "orderId": {
    ///      "examples": [
    ///        28
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "origQty": {
    ///      "examples": [
    ///        "10.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "price": {
    ///      "examples": [
    ///        "1.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "side": {
    ///      "examples": [
    ///        "SELL"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "examples": [
    ///        "FILLED"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "symbol": {
    ///      "examples": [
    ///        "BTCUSDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "timeInForce": {
    ///      "examples": [
    ///        "GTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "transactTime": {
    ///      "examples": [
    ///        1507725176595
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "type": {
    ///      "examples": [
    ///        "MARKET"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MarginOrderResponseResult {
        #[serde(rename = "clientOrderId")]
        pub client_order_id: String,
        #[serde(rename = "cummulativeQuoteQty")]
        pub cummulative_quote_qty: String,
        #[serde(rename = "executedQty")]
        pub executed_qty: String,
        #[serde(rename = "isIsolated")]
        pub is_isolated: bool,
        #[serde(rename = "orderId")]
        pub order_id: i64,
        #[serde(rename = "origQty")]
        pub orig_qty: String,
        pub price: String,
        pub side: String,
        pub status: String,
        pub symbol: String,
        #[serde(rename = "timeInForce")]
        pub time_in_force: String,
        #[serde(rename = "transactTime")]
        pub transact_time: i64,
        #[serde(rename = "type")]
        pub type_: String,
    }
    impl From<&MarginOrderResponseResult> for MarginOrderResponseResult {
        fn from(value: &MarginOrderResponseResult) -> Self {
            value.clone()
        }
    }
    ///MarginPairResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "base",
    ///    "id",
    ///    "isBuyAllowed",
    ///    "isMarginTrade",
    ///    "isSellAllowed",
    ///    "quote",
    ///    "symbol"
    ///  ],
    ///  "properties": {
    ///    "base": {
    ///      "examples": [
    ///        "BTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "examples": [
    ///        323355778339572400
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "isBuyAllowed": {
    ///      "type": "boolean"
    ///    },
    ///    "isMarginTrade": {
    ///      "type": "boolean"
    ///    },
    ///    "isSellAllowed": {
    ///      "type": "boolean"
    ///    },
    ///    "quote": {
    ///      "examples": [
    ///        "USDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "symbol": {
    ///      "examples": [
    ///        "BNBUSDT"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MarginPairResponse {
        pub base: String,
        pub id: i64,
        #[serde(rename = "isBuyAllowed")]
        pub is_buy_allowed: bool,
        #[serde(rename = "isMarginTrade")]
        pub is_margin_trade: bool,
        #[serde(rename = "isSellAllowed")]
        pub is_sell_allowed: bool,
        pub quote: String,
        pub symbol: String,
    }
    impl From<&MarginPairResponse> for MarginPairResponse {
        fn from(value: &MarginPairResponse) -> Self {
            value.clone()
        }
    }
    ///MarginPriceIndexResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "calcTime",
    ///    "price",
    ///    "symbol"
    ///  ],
    ///  "properties": {
    ///    "calcTime": {
    ///      "examples": [
    ///        1562046418000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "price": {
    ///      "examples": [
    ///        "0.00333930"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "symbol": {
    ///      "examples": [
    ///        "BNBBTC"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MarginPriceIndexResponse {
        #[serde(rename = "calcTime")]
        pub calc_time: i64,
        pub price: String,
        pub symbol: String,
    }
    impl From<&MarginPriceIndexResponse> for MarginPriceIndexResponse {
        fn from(value: &MarginPriceIndexResponse) -> Self {
            value.clone()
        }
    }
    ///MarginQueryAllOrdersIsIsolated
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "TRUE",
    ///    "FALSE"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum MarginQueryAllOrdersIsIsolated {
        #[serde(rename = "TRUE")]
        True,
        #[serde(rename = "FALSE")]
        False,
    }
    impl From<&MarginQueryAllOrdersIsIsolated> for MarginQueryAllOrdersIsIsolated {
        fn from(value: &MarginQueryAllOrdersIsIsolated) -> Self {
            value.clone()
        }
    }
    impl ToString for MarginQueryAllOrdersIsIsolated {
        fn to_string(&self) -> String {
            match *self {
                Self::True => "TRUE".to_string(),
                Self::False => "FALSE".to_string(),
            }
        }
    }
    impl std::str::FromStr for MarginQueryAllOrdersIsIsolated {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "TRUE" => Ok(Self::True),
                "FALSE" => Ok(Self::False),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for MarginQueryAllOrdersIsIsolated {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for MarginQueryAllOrdersIsIsolated {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for MarginQueryAllOrdersIsIsolated {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///MarginRateLimitOrderResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "count",
    ///    "interval",
    ///    "intervalNum",
    ///    "limit",
    ///    "rateLimitType"
    ///  ],
    ///  "properties": {
    ///    "count": {
    ///      "examples": [
    ///        0
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "interval": {
    ///      "examples": [
    ///        "SECOND"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "intervalNum": {
    ///      "examples": [
    ///        10
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "limit": {
    ///      "examples": [
    ///        10000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "rateLimitType": {
    ///      "examples": [
    ///        "ORDERS"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MarginRateLimitOrderResponseItem {
        pub count: i64,
        pub interval: String,
        #[serde(rename = "intervalNum")]
        pub interval_num: i64,
        pub limit: i64,
        #[serde(rename = "rateLimitType")]
        pub rate_limit_type: String,
    }
    impl From<&MarginRateLimitOrderResponseItem> for MarginRateLimitOrderResponseItem {
        fn from(value: &MarginRateLimitOrderResponseItem) -> Self {
            value.clone()
        }
    }
    ///MarginRepayIsIsolated
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "TRUE",
    ///    "FALSE"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum MarginRepayIsIsolated {
        #[serde(rename = "TRUE")]
        True,
        #[serde(rename = "FALSE")]
        False,
    }
    impl From<&MarginRepayIsIsolated> for MarginRepayIsIsolated {
        fn from(value: &MarginRepayIsIsolated) -> Self {
            value.clone()
        }
    }
    impl ToString for MarginRepayIsIsolated {
        fn to_string(&self) -> String {
            match *self {
                Self::True => "TRUE".to_string(),
                Self::False => "FALSE".to_string(),
            }
        }
    }
    impl std::str::FromStr for MarginRepayIsIsolated {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "TRUE" => Ok(Self::True),
                "FALSE" => Ok(Self::False),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for MarginRepayIsIsolated {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for MarginRepayIsIsolated {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for MarginRepayIsIsolated {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///MarginTrade
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "commission",
    ///    "commissionAsset",
    ///    "id",
    ///    "isBestMatch",
    ///    "isBuyer",
    ///    "isIsolated",
    ///    "isMaker",
    ///    "orderId",
    ///    "price",
    ///    "qty",
    ///    "symbol",
    ///    "time"
    ///  ],
    ///  "properties": {
    ///    "commission": {
    ///      "examples": [
    ///        "0.00006000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "commissionAsset": {
    ///      "examples": [
    ///        "BTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "examples": [
    ///        28
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "isBestMatch": {
    ///      "type": "boolean"
    ///    },
    ///    "isBuyer": {
    ///      "type": "boolean"
    ///    },
    ///    "isIsolated": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "isMaker": {
    ///      "type": "boolean"
    ///    },
    ///    "orderId": {
    ///      "examples": [
    ///        28
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "price": {
    ///      "examples": [
    ///        "0.02000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "qty": {
    ///      "examples": [
    ///        "1.02000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "symbol": {
    ///      "examples": [
    ///        "BNBBTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "time": {
    ///      "examples": [
    ///        1507725176595
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MarginTrade {
        pub commission: String,
        #[serde(rename = "commissionAsset")]
        pub commission_asset: String,
        pub id: i64,
        #[serde(rename = "isBestMatch")]
        pub is_best_match: bool,
        #[serde(rename = "isBuyer")]
        pub is_buyer: bool,
        #[serde(rename = "isIsolated")]
        pub is_isolated: bool,
        #[serde(rename = "isMaker")]
        pub is_maker: bool,
        #[serde(rename = "orderId")]
        pub order_id: i64,
        pub price: String,
        pub qty: String,
        pub symbol: String,
        pub time: i64,
    }
    impl From<&MarginTrade> for MarginTrade {
        fn from(value: &MarginTrade) -> Self {
            value.clone()
        }
    }
    ///MarginTradeCoeffResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "borrowLimit"
    ///  ],
    ///  "properties": {
    ///    "forceLiquidationBar": {
    ///      "description": "Liquidation Margin Ratio",
    ///      "examples": [
    ///        "1.1"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "marginCallBar": {
    ///      "description": "Max borrowable amount limited by the account level",
    ///      "examples": [
    ///        "1.3"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "normalBar": {
    ///      "description": "Account's currently max borrowable amount with sufficient system availability",
    ///      "examples": [
    ///        "1.5"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MarginTradeCoeffResponse {
        pub amount: serde_json::Value,
        #[serde(rename = "borrowLimit")]
        pub borrow_limit: serde_json::Value,
        ///Liquidation Margin Ratio
        #[serde(
            rename = "forceLiquidationBar",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub force_liquidation_bar: Option<String>,
        ///Max borrowable amount limited by the account level
        #[serde(
            rename = "marginCallBar",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub margin_call_bar: Option<String>,
        ///Account's currently max borrowable amount with sufficient system availability
        #[serde(rename = "normalBar", default, skip_serializing_if = "Option::is_none")]
        pub normal_bar: Option<String>,
    }
    impl From<&MarginTradeCoeffResponse> for MarginTradeCoeffResponse {
        fn from(value: &MarginTradeCoeffResponse) -> Self {
            value.clone()
        }
    }
    ///MarginTransferDetails
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "rows",
    ///    "total"
    ///  ],
    ///  "properties": {
    ///    "rows": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "amount",
    ///          "asset",
    ///          "status",
    ///          "timestamp",
    ///          "transFrom",
    ///          "transTo",
    ///          "txId"
    ///        ],
    ///        "properties": {
    ///          "amount": {
    ///            "examples": [
    ///              "0.10000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "asset": {
    ///            "examples": [
    ///              "BNB"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "status": {
    ///            "examples": [
    ///              "CONFIRMED"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "timestamp": {
    ///            "examples": [
    ///              1566898617000
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "transFrom": {
    ///            "examples": [
    ///              "SPOT"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "transTo": {
    ///            "examples": [
    ///              "ISOLATED_MARGIN"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "txId": {
    ///            "examples": [
    ///              5240372201
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "type": {
    ///            "examples": [
    ///              "ROLL_IN"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "total": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MarginTransferDetails {
        pub rows: Vec<MarginTransferDetailsRowsItem>,
        pub total: i32,
    }
    impl From<&MarginTransferDetails> for MarginTransferDetails {
        fn from(value: &MarginTransferDetails) -> Self {
            value.clone()
        }
    }
    ///MarginTransferDetailsRowsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "asset",
    ///    "status",
    ///    "timestamp",
    ///    "transFrom",
    ///    "transTo",
    ///    "txId"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "examples": [
    ///        "0.10000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "asset": {
    ///      "examples": [
    ///        "BNB"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "examples": [
    ///        "CONFIRMED"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "timestamp": {
    ///      "examples": [
    ///        1566898617000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "transFrom": {
    ///      "examples": [
    ///        "SPOT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "transTo": {
    ///      "examples": [
    ///        "ISOLATED_MARGIN"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "txId": {
    ///      "examples": [
    ///        5240372201
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "type": {
    ///      "examples": [
    ///        "ROLL_IN"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MarginTransferDetailsRowsItem {
        pub amount: String,
        pub asset: String,
        pub status: String,
        pub timestamp: i64,
        #[serde(rename = "transFrom")]
        pub trans_from: String,
        #[serde(rename = "transTo")]
        pub trans_to: String,
        #[serde(rename = "txId")]
        pub tx_id: i64,
        #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
        pub type_: Option<String>,
    }
    impl From<&MarginTransferDetailsRowsItem> for MarginTransferDetailsRowsItem {
        fn from(value: &MarginTransferDetailsRowsItem) -> Self {
            value.clone()
        }
    }
    ///MiningHashTransferConfigCancelResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "code",
    ///    "data",
    ///    "msg"
    ///  ],
    ///  "properties": {
    ///    "code": {
    ///      "examples": [
    ///        0
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "data": {
    ///      "type": "boolean"
    ///    },
    ///    "msg": {
    ///      "examples": [
    ///        ""
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MiningHashTransferConfigCancelResponse {
        pub code: i64,
        pub data: bool,
        pub msg: String,
    }
    impl From<&MiningHashTransferConfigCancelResponse>
    for MiningHashTransferConfigCancelResponse {
        fn from(value: &MiningHashTransferConfigCancelResponse) -> Self {
            value.clone()
        }
    }
    ///MiningHashTransferConfigDetailsListResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "code",
    ///    "data",
    ///    "msg"
    ///  ],
    ///  "properties": {
    ///    "code": {
    ///      "examples": [
    ///        0
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "data": {
    ///      "type": "object",
    ///      "required": [
    ///        "configDetails",
    ///        "pageSize",
    ///        "totalNum"
    ///      ],
    ///      "properties": {
    ///        "configDetails": {
    ///          "type": "array",
    ///          "items": {
    ///            "type": "object",
    ///            "required": [
    ///              "algoName",
    ///              "configId",
    ///              "endDay",
    ///              "hashRate",
    ///              "poolUsername",
    ///              "startDay",
    ///              "status",
    ///              "toPoolUsername"
    ///            ],
    ///            "properties": {
    ///              "algoName": {
    ///                "description": "Transfer algorithm",
    ///                "examples": [
    ///                  "Ethash"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "configId": {
    ///                "description": "Mining ID",
    ///                "examples": [
    ///                  168
    ///                ],
    ///                "type": "integer",
    ///                "format": "int64"
    ///              },
    ///              "endDay": {
    ///                "description": "End date",
    ///                "examples": [
    ///                  20210405
    ///                ],
    ///                "type": "integer",
    ///                "format": "int64"
    ///              },
    ///              "hashRate": {
    ///                "description": "Transferred Hashrate quantity",
    ///                "examples": [
    ///                  5000000
    ///                ],
    ///                "type": "integer",
    ///                "format": "int64"
    ///              },
    ///              "poolUsername": {
    ///                "description": "Transfer out of subaccount",
    ///                "examples": [
    ///                  "123"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "startDay": {
    ///                "description": "Start date",
    ///                "examples": [
    ///                  20201210
    ///                ],
    ///                "type": "integer",
    ///                "format": "int64"
    ///              },
    ///              "status": {
    ///                "description": "0 Processing, 1Cancelled, 2Terminated ",
    ///                "examples": [
    ///                  1
    ///                ],
    ///                "type": "integer",
    ///                "format": "int32"
    ///              },
    ///              "toPoolUsername": {
    ///                "description": "Transfer into subaccount",
    ///                "examples": [
    ///                  "user1"
    ///                ],
    ///                "type": "string"
    ///              }
    ///            }
    ///          }
    ///        },
    ///        "pageSize": {
    ///          "examples": [
    ///            200
    ///          ],
    ///          "type": "integer",
    ///          "format": "int64"
    ///        },
    ///        "totalNum": {
    ///          "examples": [
    ///            21
    ///          ],
    ///          "type": "integer",
    ///          "format": "int64"
    ///        }
    ///      }
    ///    },
    ///    "msg": {
    ///      "examples": [
    ///        ""
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MiningHashTransferConfigDetailsListResponse {
        pub code: i64,
        pub data: MiningHashTransferConfigDetailsListResponseData,
        pub msg: String,
    }
    impl From<&MiningHashTransferConfigDetailsListResponse>
    for MiningHashTransferConfigDetailsListResponse {
        fn from(value: &MiningHashTransferConfigDetailsListResponse) -> Self {
            value.clone()
        }
    }
    ///MiningHashTransferConfigDetailsListResponseData
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "configDetails",
    ///    "pageSize",
    ///    "totalNum"
    ///  ],
    ///  "properties": {
    ///    "configDetails": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "algoName",
    ///          "configId",
    ///          "endDay",
    ///          "hashRate",
    ///          "poolUsername",
    ///          "startDay",
    ///          "status",
    ///          "toPoolUsername"
    ///        ],
    ///        "properties": {
    ///          "algoName": {
    ///            "description": "Transfer algorithm",
    ///            "examples": [
    ///              "Ethash"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "configId": {
    ///            "description": "Mining ID",
    ///            "examples": [
    ///              168
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "endDay": {
    ///            "description": "End date",
    ///            "examples": [
    ///              20210405
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "hashRate": {
    ///            "description": "Transferred Hashrate quantity",
    ///            "examples": [
    ///              5000000
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "poolUsername": {
    ///            "description": "Transfer out of subaccount",
    ///            "examples": [
    ///              "123"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "startDay": {
    ///            "description": "Start date",
    ///            "examples": [
    ///              20201210
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "status": {
    ///            "description": "0 Processing, 1Cancelled, 2Terminated ",
    ///            "examples": [
    ///              1
    ///            ],
    ///            "type": "integer",
    ///            "format": "int32"
    ///          },
    ///          "toPoolUsername": {
    ///            "description": "Transfer into subaccount",
    ///            "examples": [
    ///              "user1"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "pageSize": {
    ///      "examples": [
    ///        200
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "totalNum": {
    ///      "examples": [
    ///        21
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MiningHashTransferConfigDetailsListResponseData {
        #[serde(rename = "configDetails")]
        pub config_details: Vec<
            MiningHashTransferConfigDetailsListResponseDataConfigDetailsItem,
        >,
        #[serde(rename = "pageSize")]
        pub page_size: i64,
        #[serde(rename = "totalNum")]
        pub total_num: i64,
    }
    impl From<&MiningHashTransferConfigDetailsListResponseData>
    for MiningHashTransferConfigDetailsListResponseData {
        fn from(value: &MiningHashTransferConfigDetailsListResponseData) -> Self {
            value.clone()
        }
    }
    ///MiningHashTransferConfigDetailsListResponseDataConfigDetailsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "algoName",
    ///    "configId",
    ///    "endDay",
    ///    "hashRate",
    ///    "poolUsername",
    ///    "startDay",
    ///    "status",
    ///    "toPoolUsername"
    ///  ],
    ///  "properties": {
    ///    "algoName": {
    ///      "description": "Transfer algorithm",
    ///      "examples": [
    ///        "Ethash"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "configId": {
    ///      "description": "Mining ID",
    ///      "examples": [
    ///        168
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "endDay": {
    ///      "description": "End date",
    ///      "examples": [
    ///        20210405
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "hashRate": {
    ///      "description": "Transferred Hashrate quantity",
    ///      "examples": [
    ///        5000000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "poolUsername": {
    ///      "description": "Transfer out of subaccount",
    ///      "examples": [
    ///        "123"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "startDay": {
    ///      "description": "Start date",
    ///      "examples": [
    ///        20201210
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "status": {
    ///      "description": "0 Processing, 1Cancelled, 2Terminated ",
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    },
    ///    "toPoolUsername": {
    ///      "description": "Transfer into subaccount",
    ///      "examples": [
    ///        "user1"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MiningHashTransferConfigDetailsListResponseDataConfigDetailsItem {
        ///Transfer algorithm
        #[serde(rename = "algoName")]
        pub algo_name: String,
        ///Mining ID
        #[serde(rename = "configId")]
        pub config_id: i64,
        ///End date
        #[serde(rename = "endDay")]
        pub end_day: i64,
        ///Transferred Hashrate quantity
        #[serde(rename = "hashRate")]
        pub hash_rate: i64,
        ///Transfer out of subaccount
        #[serde(rename = "poolUsername")]
        pub pool_username: String,
        ///Start date
        #[serde(rename = "startDay")]
        pub start_day: i64,
        ///0 Processing, 1Cancelled, 2Terminated
        pub status: i32,
        ///Transfer into subaccount
        #[serde(rename = "toPoolUsername")]
        pub to_pool_username: String,
    }
    impl From<&MiningHashTransferConfigDetailsListResponseDataConfigDetailsItem>
    for MiningHashTransferConfigDetailsListResponseDataConfigDetailsItem {
        fn from(
            value: &MiningHashTransferConfigDetailsListResponseDataConfigDetailsItem,
        ) -> Self {
            value.clone()
        }
    }
    ///MiningHashTransferConfigResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "code",
    ///    "data",
    ///    "msg"
    ///  ],
    ///  "properties": {
    ///    "code": {
    ///      "examples": [
    ///        0
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "data": {
    ///      "description": "Mining Account",
    ///      "examples": [
    ///        171
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "msg": {
    ///      "examples": [
    ///        ""
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MiningHashTransferConfigResponse {
        pub code: i64,
        ///Mining Account
        pub data: i64,
        pub msg: String,
    }
    impl From<&MiningHashTransferConfigResponse> for MiningHashTransferConfigResponse {
        fn from(value: &MiningHashTransferConfigResponse) -> Self {
            value.clone()
        }
    }
    ///MiningHashTransferProfitDetailsResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "code",
    ///    "data",
    ///    "msg"
    ///  ],
    ///  "properties": {
    ///    "code": {
    ///      "examples": [
    ///        0
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "data": {
    ///      "type": "object",
    ///      "required": [
    ///        "pageSize",
    ///        "profitTransferDetails",
    ///        "totalNum"
    ///      ],
    ///      "properties": {
    ///        "pageSize": {
    ///          "examples": [
    ///            200
    ///          ],
    ///          "type": "integer",
    ///          "format": "int64"
    ///        },
    ///        "profitTransferDetails": {
    ///          "type": "array",
    ///          "items": {
    ///            "type": "object",
    ///            "required": [
    ///              "algoName",
    ///              "amount",
    ///              "coinName",
    ///              "day",
    ///              "hashRate",
    ///              "poolUsername",
    ///              "toPoolUsername"
    ///            ],
    ///            "properties": {
    ///              "algoName": {
    ///                "description": "Transfer algorithm",
    ///                "examples": [
    ///                  "sha256"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "amount": {
    ///                "description": "Transfer income",
    ///                "examples": [
    ///                  0.2256872
    ///                ],
    ///                "type": "number",
    ///                "format": "double"
    ///              },
    ///              "coinName": {
    ///                "examples": [
    ///                  "BTC"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "day": {
    ///                "description": "Transfer date",
    ///                "examples": [
    ///                  20201213
    ///                ],
    ///                "type": "integer",
    ///                "format": "int64"
    ///              },
    ///              "hashRate": {
    ///                "description": "Transferred Hashrate quantity",
    ///                "examples": [
    ///                  200000000000
    ///                ],
    ///                "type": "integer",
    ///                "format": "int64"
    ///              },
    ///              "poolUsername": {
    ///                "description": "Transfer out of sub-account",
    ///                "examples": [
    ///                  "test4001"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "toPoolUsername": {
    ///                "description": "Transfer into subaccount",
    ///                "examples": [
    ///                  "pop"
    ///                ],
    ///                "type": "string"
    ///              }
    ///            }
    ///          }
    ///        },
    ///        "totalNum": {
    ///          "examples": [
    ///            8
    ///          ],
    ///          "type": "integer",
    ///          "format": "int64"
    ///        }
    ///      }
    ///    },
    ///    "msg": {
    ///      "examples": [
    ///        ""
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MiningHashTransferProfitDetailsResponse {
        pub code: i64,
        pub data: MiningHashTransferProfitDetailsResponseData,
        pub msg: String,
    }
    impl From<&MiningHashTransferProfitDetailsResponse>
    for MiningHashTransferProfitDetailsResponse {
        fn from(value: &MiningHashTransferProfitDetailsResponse) -> Self {
            value.clone()
        }
    }
    ///MiningHashTransferProfitDetailsResponseData
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "pageSize",
    ///    "profitTransferDetails",
    ///    "totalNum"
    ///  ],
    ///  "properties": {
    ///    "pageSize": {
    ///      "examples": [
    ///        200
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "profitTransferDetails": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "algoName",
    ///          "amount",
    ///          "coinName",
    ///          "day",
    ///          "hashRate",
    ///          "poolUsername",
    ///          "toPoolUsername"
    ///        ],
    ///        "properties": {
    ///          "algoName": {
    ///            "description": "Transfer algorithm",
    ///            "examples": [
    ///              "sha256"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "amount": {
    ///            "description": "Transfer income",
    ///            "examples": [
    ///              0.2256872
    ///            ],
    ///            "type": "number",
    ///            "format": "double"
    ///          },
    ///          "coinName": {
    ///            "examples": [
    ///              "BTC"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "day": {
    ///            "description": "Transfer date",
    ///            "examples": [
    ///              20201213
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "hashRate": {
    ///            "description": "Transferred Hashrate quantity",
    ///            "examples": [
    ///              200000000000
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "poolUsername": {
    ///            "description": "Transfer out of sub-account",
    ///            "examples": [
    ///              "test4001"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "toPoolUsername": {
    ///            "description": "Transfer into subaccount",
    ///            "examples": [
    ///              "pop"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "totalNum": {
    ///      "examples": [
    ///        8
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MiningHashTransferProfitDetailsResponseData {
        #[serde(rename = "pageSize")]
        pub page_size: i64,
        #[serde(rename = "profitTransferDetails")]
        pub profit_transfer_details: Vec<
            MiningHashTransferProfitDetailsResponseDataProfitTransferDetailsItem,
        >,
        #[serde(rename = "totalNum")]
        pub total_num: i64,
    }
    impl From<&MiningHashTransferProfitDetailsResponseData>
    for MiningHashTransferProfitDetailsResponseData {
        fn from(value: &MiningHashTransferProfitDetailsResponseData) -> Self {
            value.clone()
        }
    }
    ///MiningHashTransferProfitDetailsResponseDataProfitTransferDetailsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "algoName",
    ///    "amount",
    ///    "coinName",
    ///    "day",
    ///    "hashRate",
    ///    "poolUsername",
    ///    "toPoolUsername"
    ///  ],
    ///  "properties": {
    ///    "algoName": {
    ///      "description": "Transfer algorithm",
    ///      "examples": [
    ///        "sha256"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "amount": {
    ///      "description": "Transfer income",
    ///      "examples": [
    ///        0.2256872
    ///      ],
    ///      "type": "number",
    ///      "format": "double"
    ///    },
    ///    "coinName": {
    ///      "examples": [
    ///        "BTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "day": {
    ///      "description": "Transfer date",
    ///      "examples": [
    ///        20201213
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "hashRate": {
    ///      "description": "Transferred Hashrate quantity",
    ///      "examples": [
    ///        200000000000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "poolUsername": {
    ///      "description": "Transfer out of sub-account",
    ///      "examples": [
    ///        "test4001"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "toPoolUsername": {
    ///      "description": "Transfer into subaccount",
    ///      "examples": [
    ///        "pop"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MiningHashTransferProfitDetailsResponseDataProfitTransferDetailsItem {
        ///Transfer algorithm
        #[serde(rename = "algoName")]
        pub algo_name: String,
        pub amount: f64,
        #[serde(rename = "coinName")]
        pub coin_name: String,
        ///Transfer date
        pub day: i64,
        ///Transferred Hashrate quantity
        #[serde(rename = "hashRate")]
        pub hash_rate: i64,
        ///Transfer out of sub-account
        #[serde(rename = "poolUsername")]
        pub pool_username: String,
        ///Transfer into subaccount
        #[serde(rename = "toPoolUsername")]
        pub to_pool_username: String,
    }
    impl From<&MiningHashTransferProfitDetailsResponseDataProfitTransferDetailsItem>
    for MiningHashTransferProfitDetailsResponseDataProfitTransferDetailsItem {
        fn from(
            value: &MiningHashTransferProfitDetailsResponseDataProfitTransferDetailsItem,
        ) -> Self {
            value.clone()
        }
    }
    ///MiningPaymentListResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "code",
    ///    "data",
    ///    "msg"
    ///  ],
    ///  "properties": {
    ///    "code": {
    ///      "examples": [
    ///        0
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "data": {
    ///      "type": "object",
    ///      "required": [
    ///        "accountProfits",
    ///        "pageSize",
    ///        "totalNum"
    ///      ],
    ///      "properties": {
    ///        "accountProfits": {
    ///          "type": "array",
    ///          "items": {
    ///            "type": "object",
    ///            "required": [
    ///              "coinName",
    ///              "dayHashRate",
    ///              "hashTransfer",
    ///              "profitAmount",
    ///              "status",
    ///              "time",
    ///              "transferAmount",
    ///              "type"
    ///            ],
    ///            "properties": {
    ///              "coinName": {
    ///                "description": "Coin Type",
    ///                "examples": [
    ///                  "BTC"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "dayHashRate": {
    ///                "description": "Daily Hashrate",
    ///                "examples": [
    ///                  129129903378244
    ///                ],
    ///                "type": "integer",
    ///                "format": "int64"
    ///              },
    ///              "hashTransfer": {
    ///                "description": "Transferred Hashrate",
    ///                "type": "integer",
    ///                "format": "nullable"
    ///              },
    ///              "profitAmount": {
    ///                "description": "Earnings Amount",
    ///                "examples": [
    ///                  8.6083060304
    ///                ],
    ///                "type": "number",
    ///                "format": "double"
    ///              },
    ///              "status": {
    ///                "description": "Status0:Unpaid, 1:Paying  2Paid",
    ///                "examples": [
    ///                  2
    ///                ],
    ///                "type": "integer",
    ///                "format": "int32"
    ///              },
    ///              "time": {
    ///                "description": "Mining date",
    ///                "examples": [
    ///                  1586188800000
    ///                ],
    ///                "type": "integer",
    ///                "format": "int64"
    ///              },
    ///              "transferAmount": {
    ///                "description": "Transferred Income",
    ///                "type": "number",
    ///                "format": "nullable"
    ///              },
    ///              "type": {
    ///                "description": "0:Mining Wallet,5:Mining Address,7:Pool Savings,8:Transferred,31:Income Transfer ,32:Hashrate Resale-Mining Wallet 33:Hashrate Resale-Pool Savings",
    ///                "examples": [
    ///                  31
    ///                ],
    ///                "type": "integer",
    ///                "format": "int64"
    ///              }
    ///            }
    ///          }
    ///        },
    ///        "pageSize": {
    ///          "description": "Rows per page",
    ///          "examples": [
    ///            20
    ///          ],
    ///          "type": "integer",
    ///          "format": "int64"
    ///        },
    ///        "totalNum": {
    ///          "description": "Total Rows",
    ///          "examples": [
    ///            3
    ///          ],
    ///          "type": "integer",
    ///          "format": "int64"
    ///        }
    ///      }
    ///    },
    ///    "msg": {
    ///      "examples": [
    ///        ""
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MiningPaymentListResponse {
        pub code: i64,
        pub data: MiningPaymentListResponseData,
        pub msg: String,
    }
    impl From<&MiningPaymentListResponse> for MiningPaymentListResponse {
        fn from(value: &MiningPaymentListResponse) -> Self {
            value.clone()
        }
    }
    ///MiningPaymentListResponseData
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "accountProfits",
    ///    "pageSize",
    ///    "totalNum"
    ///  ],
    ///  "properties": {
    ///    "accountProfits": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "coinName",
    ///          "dayHashRate",
    ///          "hashTransfer",
    ///          "profitAmount",
    ///          "status",
    ///          "time",
    ///          "transferAmount",
    ///          "type"
    ///        ],
    ///        "properties": {
    ///          "coinName": {
    ///            "description": "Coin Type",
    ///            "examples": [
    ///              "BTC"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "dayHashRate": {
    ///            "description": "Daily Hashrate",
    ///            "examples": [
    ///              129129903378244
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "hashTransfer": {
    ///            "description": "Transferred Hashrate",
    ///            "type": "integer",
    ///            "format": "nullable"
    ///          },
    ///          "profitAmount": {
    ///            "description": "Earnings Amount",
    ///            "examples": [
    ///              8.6083060304
    ///            ],
    ///            "type": "number",
    ///            "format": "double"
    ///          },
    ///          "status": {
    ///            "description": "Status0:Unpaid, 1:Paying  2Paid",
    ///            "examples": [
    ///              2
    ///            ],
    ///            "type": "integer",
    ///            "format": "int32"
    ///          },
    ///          "time": {
    ///            "description": "Mining date",
    ///            "examples": [
    ///              1586188800000
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "transferAmount": {
    ///            "description": "Transferred Income",
    ///            "type": "number",
    ///            "format": "nullable"
    ///          },
    ///          "type": {
    ///            "description": "0:Mining Wallet,5:Mining Address,7:Pool Savings,8:Transferred,31:Income Transfer ,32:Hashrate Resale-Mining Wallet 33:Hashrate Resale-Pool Savings",
    ///            "examples": [
    ///              31
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "pageSize": {
    ///      "description": "Rows per page",
    ///      "examples": [
    ///        20
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "totalNum": {
    ///      "description": "Total Rows",
    ///      "examples": [
    ///        3
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MiningPaymentListResponseData {
        #[serde(rename = "accountProfits")]
        pub account_profits: Vec<MiningPaymentListResponseDataAccountProfitsItem>,
        ///Rows per page
        #[serde(rename = "pageSize")]
        pub page_size: i64,
        ///Total Rows
        #[serde(rename = "totalNum")]
        pub total_num: i64,
    }
    impl From<&MiningPaymentListResponseData> for MiningPaymentListResponseData {
        fn from(value: &MiningPaymentListResponseData) -> Self {
            value.clone()
        }
    }
    ///MiningPaymentListResponseDataAccountProfitsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "coinName",
    ///    "dayHashRate",
    ///    "hashTransfer",
    ///    "profitAmount",
    ///    "status",
    ///    "time",
    ///    "transferAmount",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "coinName": {
    ///      "description": "Coin Type",
    ///      "examples": [
    ///        "BTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "dayHashRate": {
    ///      "description": "Daily Hashrate",
    ///      "examples": [
    ///        129129903378244
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "hashTransfer": {
    ///      "description": "Transferred Hashrate",
    ///      "type": "integer",
    ///      "format": "nullable"
    ///    },
    ///    "profitAmount": {
    ///      "description": "Earnings Amount",
    ///      "examples": [
    ///        8.6083060304
    ///      ],
    ///      "type": "number",
    ///      "format": "double"
    ///    },
    ///    "status": {
    ///      "description": "Status0:Unpaid, 1:Paying  2Paid",
    ///      "examples": [
    ///        2
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    },
    ///    "time": {
    ///      "description": "Mining date",
    ///      "examples": [
    ///        1586188800000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "transferAmount": {
    ///      "description": "Transferred Income",
    ///      "type": "number",
    ///      "format": "nullable"
    ///    },
    ///    "type": {
    ///      "description": "0:Mining Wallet,5:Mining Address,7:Pool Savings,8:Transferred,31:Income Transfer ,32:Hashrate Resale-Mining Wallet 33:Hashrate Resale-Pool Savings",
    ///      "examples": [
    ///        31
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MiningPaymentListResponseDataAccountProfitsItem {
        ///Coin Type
        #[serde(rename = "coinName")]
        pub coin_name: String,
        ///Daily Hashrate
        #[serde(rename = "dayHashRate")]
        pub day_hash_rate: i64,
        ///Transferred Hashrate
        #[serde(rename = "hashTransfer")]
        pub hash_transfer: i64,
        #[serde(rename = "profitAmount")]
        pub profit_amount: f64,
        ///Status0:Unpaid, 1:Paying  2Paid
        pub status: i32,
        ///Mining date
        pub time: i64,
        #[serde(rename = "transferAmount")]
        pub transfer_amount: f64,
        ///0:Mining Wallet,5:Mining Address,7:Pool Savings,8:Transferred,31:Income Transfer ,32:Hashrate Resale-Mining Wallet 33:Hashrate Resale-Pool Savings
        #[serde(rename = "type")]
        pub type_: i64,
    }
    impl From<&MiningPaymentListResponseDataAccountProfitsItem>
    for MiningPaymentListResponseDataAccountProfitsItem {
        fn from(value: &MiningPaymentListResponseDataAccountProfitsItem) -> Self {
            value.clone()
        }
    }
    ///MiningPaymentOtherResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "code",
    ///    "data",
    ///    "msg"
    ///  ],
    ///  "properties": {
    ///    "code": {
    ///      "examples": [
    ///        0
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "data": {
    ///      "type": "object",
    ///      "required": [
    ///        "otherProfits",
    ///        "pageSize",
    ///        "totalNum"
    ///      ],
    ///      "properties": {
    ///        "otherProfits": {
    ///          "type": "array",
    ///          "items": {
    ///            "type": "object",
    ///            "required": [
    ///              "coinName",
    ///              "profitAmount",
    ///              "status",
    ///              "time",
    ///              "type"
    ///            ],
    ///            "properties": {
    ///              "coinName": {
    ///                "description": "Coin Name",
    ///                "examples": [
    ///                  "BTC"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "profitAmount": {
    ///                "examples": [
    ///                  0.0011859
    ///                ],
    ///                "type": "number",
    ///                "format": "double"
    ///              },
    ///              "status": {
    ///                "description": "0:Unpaid, 1:Paying  2Paid",
    ///                "examples": [
    ///                  2
    ///                ],
    ///                "type": "integer",
    ///                "format": "int32"
    ///              },
    ///              "time": {
    ///                "description": "Mining date",
    ///                "examples": [
    ///                  1607443200000
    ///                ],
    ///                "type": "integer",
    ///                "format": "int64"
    ///              },
    ///              "type": {
    ///                "description": "1: Merged Mining, 2: Activity Bonus, 3:Rebate 4:Smart Pool 6:Income Transfer 7:Pool Savings",
    ///                "examples": [
    ///                  4
    ///                ],
    ///                "type": "integer",
    ///                "format": "int32"
    ///              }
    ///            }
    ///          }
    ///        },
    ///        "pageSize": {
    ///          "description": "Rows per page",
    ///          "examples": [
    ///            20
    ///          ],
    ///          "type": "integer",
    ///          "format": "int64"
    ///        },
    ///        "totalNum": {
    ///          "description": "Total Rows",
    ///          "examples": [
    ///            3
    ///          ],
    ///          "type": "integer",
    ///          "format": "int64"
    ///        }
    ///      }
    ///    },
    ///    "msg": {
    ///      "examples": [
    ///        ""
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MiningPaymentOtherResponse {
        pub code: i64,
        pub data: MiningPaymentOtherResponseData,
        pub msg: String,
    }
    impl From<&MiningPaymentOtherResponse> for MiningPaymentOtherResponse {
        fn from(value: &MiningPaymentOtherResponse) -> Self {
            value.clone()
        }
    }
    ///MiningPaymentOtherResponseData
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "otherProfits",
    ///    "pageSize",
    ///    "totalNum"
    ///  ],
    ///  "properties": {
    ///    "otherProfits": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "coinName",
    ///          "profitAmount",
    ///          "status",
    ///          "time",
    ///          "type"
    ///        ],
    ///        "properties": {
    ///          "coinName": {
    ///            "description": "Coin Name",
    ///            "examples": [
    ///              "BTC"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "profitAmount": {
    ///            "examples": [
    ///              0.0011859
    ///            ],
    ///            "type": "number",
    ///            "format": "double"
    ///          },
    ///          "status": {
    ///            "description": "0:Unpaid, 1:Paying  2Paid",
    ///            "examples": [
    ///              2
    ///            ],
    ///            "type": "integer",
    ///            "format": "int32"
    ///          },
    ///          "time": {
    ///            "description": "Mining date",
    ///            "examples": [
    ///              1607443200000
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "type": {
    ///            "description": "1: Merged Mining, 2: Activity Bonus, 3:Rebate 4:Smart Pool 6:Income Transfer 7:Pool Savings",
    ///            "examples": [
    ///              4
    ///            ],
    ///            "type": "integer",
    ///            "format": "int32"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "pageSize": {
    ///      "description": "Rows per page",
    ///      "examples": [
    ///        20
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "totalNum": {
    ///      "description": "Total Rows",
    ///      "examples": [
    ///        3
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MiningPaymentOtherResponseData {
        #[serde(rename = "otherProfits")]
        pub other_profits: Vec<MiningPaymentOtherResponseDataOtherProfitsItem>,
        ///Rows per page
        #[serde(rename = "pageSize")]
        pub page_size: i64,
        ///Total Rows
        #[serde(rename = "totalNum")]
        pub total_num: i64,
    }
    impl From<&MiningPaymentOtherResponseData> for MiningPaymentOtherResponseData {
        fn from(value: &MiningPaymentOtherResponseData) -> Self {
            value.clone()
        }
    }
    ///MiningPaymentOtherResponseDataOtherProfitsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "coinName",
    ///    "profitAmount",
    ///    "status",
    ///    "time",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "coinName": {
    ///      "description": "Coin Name",
    ///      "examples": [
    ///        "BTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "profitAmount": {
    ///      "examples": [
    ///        0.0011859
    ///      ],
    ///      "type": "number",
    ///      "format": "double"
    ///    },
    ///    "status": {
    ///      "description": "0:Unpaid, 1:Paying  2Paid",
    ///      "examples": [
    ///        2
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    },
    ///    "time": {
    ///      "description": "Mining date",
    ///      "examples": [
    ///        1607443200000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "type": {
    ///      "description": "1: Merged Mining, 2: Activity Bonus, 3:Rebate 4:Smart Pool 6:Income Transfer 7:Pool Savings",
    ///      "examples": [
    ///        4
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MiningPaymentOtherResponseDataOtherProfitsItem {
        ///Coin Name
        #[serde(rename = "coinName")]
        pub coin_name: String,
        #[serde(rename = "profitAmount")]
        pub profit_amount: f64,
        ///0:Unpaid, 1:Paying  2Paid
        pub status: i32,
        ///Mining date
        pub time: i64,
        ///1: Merged Mining, 2: Activity Bonus, 3:Rebate 4:Smart Pool 6:Income Transfer 7:Pool Savings
        #[serde(rename = "type")]
        pub type_: i32,
    }
    impl From<&MiningPaymentOtherResponseDataOtherProfitsItem>
    for MiningPaymentOtherResponseDataOtherProfitsItem {
        fn from(value: &MiningPaymentOtherResponseDataOtherProfitsItem) -> Self {
            value.clone()
        }
    }
    ///MiningPaymentUidResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "code",
    ///    "data",
    ///    "msg"
    ///  ],
    ///  "properties": {
    ///    "code": {
    ///      "examples": [
    ///        0
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    },
    ///    "data": {
    ///      "type": "object",
    ///      "required": [
    ///        "accountProfits",
    ///        "pageSize",
    ///        "totalNum"
    ///      ],
    ///      "properties": {
    ///        "accountProfits": {
    ///          "type": "array",
    ///          "items": {
    ///            "type": "object",
    ///            "required": [
    ///              "amount",
    ///              "coinName",
    ///              "puid",
    ///              "subName",
    ///              "time",
    ///              "type"
    ///            ],
    ///            "properties": {
    ///              "amount": {
    ///                "examples": [
    ///                  0.09186957
    ///                ],
    ///                "type": "number"
    ///              },
    ///              "coinName": {
    ///                "examples": [
    ///                  "BTC"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "puid": {
    ///                "description": "puid",
    ///                "examples": [
    ///                  59985472
    ///                ],
    ///                "type": "integer",
    ///                "format": "int32"
    ///              },
    ///              "subName": {
    ///                "description": "Mining account",
    ///                "examples": [
    ///                  "vdvaghani"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "time": {
    ///                "examples": [
    ///                  1607443200000
    ///                ],
    ///                "type": "integer",
    ///                "format": "int64"
    ///              },
    ///              "type": {
    ///                "description": "0:Referral 1:Refund 2:Rebate",
    ///                "examples": [
    ///                  2
    ///                ],
    ///                "type": "integer",
    ///                "format": "int32"
    ///              }
    ///            }
    ///          }
    ///        },
    ///        "pageSize": {
    ///          "examples": [
    ///            20
    ///          ],
    ///          "type": "integer",
    ///          "format": "int32"
    ///        },
    ///        "totalNum": {
    ///          "examples": [
    ///            3
    ///          ],
    ///          "type": "integer",
    ///          "format": "int32"
    ///        }
    ///      }
    ///    },
    ///    "msg": {
    ///      "examples": [
    ///        ""
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MiningPaymentUidResponse {
        pub code: i32,
        pub data: MiningPaymentUidResponseData,
        pub msg: String,
    }
    impl From<&MiningPaymentUidResponse> for MiningPaymentUidResponse {
        fn from(value: &MiningPaymentUidResponse) -> Self {
            value.clone()
        }
    }
    ///MiningPaymentUidResponseData
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "accountProfits",
    ///    "pageSize",
    ///    "totalNum"
    ///  ],
    ///  "properties": {
    ///    "accountProfits": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "amount",
    ///          "coinName",
    ///          "puid",
    ///          "subName",
    ///          "time",
    ///          "type"
    ///        ],
    ///        "properties": {
    ///          "amount": {
    ///            "examples": [
    ///              0.09186957
    ///            ],
    ///            "type": "number"
    ///          },
    ///          "coinName": {
    ///            "examples": [
    ///              "BTC"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "puid": {
    ///            "description": "puid",
    ///            "examples": [
    ///              59985472
    ///            ],
    ///            "type": "integer",
    ///            "format": "int32"
    ///          },
    ///          "subName": {
    ///            "description": "Mining account",
    ///            "examples": [
    ///              "vdvaghani"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "time": {
    ///            "examples": [
    ///              1607443200000
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "type": {
    ///            "description": "0:Referral 1:Refund 2:Rebate",
    ///            "examples": [
    ///              2
    ///            ],
    ///            "type": "integer",
    ///            "format": "int32"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "pageSize": {
    ///      "examples": [
    ///        20
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    },
    ///    "totalNum": {
    ///      "examples": [
    ///        3
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MiningPaymentUidResponseData {
        #[serde(rename = "accountProfits")]
        pub account_profits: Vec<MiningPaymentUidResponseDataAccountProfitsItem>,
        #[serde(rename = "pageSize")]
        pub page_size: i32,
        #[serde(rename = "totalNum")]
        pub total_num: i32,
    }
    impl From<&MiningPaymentUidResponseData> for MiningPaymentUidResponseData {
        fn from(value: &MiningPaymentUidResponseData) -> Self {
            value.clone()
        }
    }
    ///MiningPaymentUidResponseDataAccountProfitsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "coinName",
    ///    "puid",
    ///    "subName",
    ///    "time",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "examples": [
    ///        0.09186957
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "coinName": {
    ///      "examples": [
    ///        "BTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "puid": {
    ///      "description": "puid",
    ///      "examples": [
    ///        59985472
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    },
    ///    "subName": {
    ///      "description": "Mining account",
    ///      "examples": [
    ///        "vdvaghani"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "time": {
    ///      "examples": [
    ///        1607443200000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "type": {
    ///      "description": "0:Referral 1:Refund 2:Rebate",
    ///      "examples": [
    ///        2
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MiningPaymentUidResponseDataAccountProfitsItem {
        pub amount: f64,
        #[serde(rename = "coinName")]
        pub coin_name: String,
        ///puid
        pub puid: i32,
        ///Mining account
        #[serde(rename = "subName")]
        pub sub_name: String,
        pub time: i64,
        ///0:Referral 1:Refund 2:Rebate
        #[serde(rename = "type")]
        pub type_: i32,
    }
    impl From<&MiningPaymentUidResponseDataAccountProfitsItem>
    for MiningPaymentUidResponseDataAccountProfitsItem {
        fn from(value: &MiningPaymentUidResponseDataAccountProfitsItem) -> Self {
            value.clone()
        }
    }
    ///MiningPubAlgoListResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "code",
    ///    "data",
    ///    "msg"
    ///  ],
    ///  "properties": {
    ///    "code": {
    ///      "examples": [
    ///        0
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "data": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "algoId",
    ///          "algoName",
    ///          "poolIndex",
    ///          "unit"
    ///        ],
    ///        "properties": {
    ///          "algoId": {
    ///            "examples": [
    ///              1
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "algoName": {
    ///            "examples": [
    ///              "sha256"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "poolIndex": {
    ///            "examples": [
    ///              0
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "unit": {
    ///            "examples": [
    ///              "h/s"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "msg": {
    ///      "examples": [
    ///        ""
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MiningPubAlgoListResponse {
        pub code: i64,
        pub data: Vec<MiningPubAlgoListResponseDataItem>,
        pub msg: String,
    }
    impl From<&MiningPubAlgoListResponse> for MiningPubAlgoListResponse {
        fn from(value: &MiningPubAlgoListResponse) -> Self {
            value.clone()
        }
    }
    ///MiningPubAlgoListResponseDataItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "algoId",
    ///    "algoName",
    ///    "poolIndex",
    ///    "unit"
    ///  ],
    ///  "properties": {
    ///    "algoId": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "algoName": {
    ///      "examples": [
    ///        "sha256"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "poolIndex": {
    ///      "examples": [
    ///        0
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "unit": {
    ///      "examples": [
    ///        "h/s"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MiningPubAlgoListResponseDataItem {
        #[serde(rename = "algoId")]
        pub algo_id: i64,
        #[serde(rename = "algoName")]
        pub algo_name: String,
        #[serde(rename = "poolIndex")]
        pub pool_index: i64,
        pub unit: String,
    }
    impl From<&MiningPubAlgoListResponseDataItem> for MiningPubAlgoListResponseDataItem {
        fn from(value: &MiningPubAlgoListResponseDataItem) -> Self {
            value.clone()
        }
    }
    ///MiningPubCoinListResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "code",
    ///    "data",
    ///    "msg"
    ///  ],
    ///  "properties": {
    ///    "code": {
    ///      "examples": [
    ///        0
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "data": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "algoId",
    ///          "algoName",
    ///          "coinId",
    ///          "coinName",
    ///          "poolIndex"
    ///        ],
    ///        "properties": {
    ///          "algoId": {
    ///            "examples": [
    ///              1
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "algoName": {
    ///            "examples": [
    ///              "sha256"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "coinId": {
    ///            "examples": [
    ///              1
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "coinName": {
    ///            "examples": [
    ///              "BTC"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "poolIndex": {
    ///            "examples": [
    ///              0
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "msg": {
    ///      "examples": [
    ///        ""
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MiningPubCoinListResponse {
        pub code: i64,
        pub data: Vec<MiningPubCoinListResponseDataItem>,
        pub msg: String,
    }
    impl From<&MiningPubCoinListResponse> for MiningPubCoinListResponse {
        fn from(value: &MiningPubCoinListResponse) -> Self {
            value.clone()
        }
    }
    ///MiningPubCoinListResponseDataItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "algoId",
    ///    "algoName",
    ///    "coinId",
    ///    "coinName",
    ///    "poolIndex"
    ///  ],
    ///  "properties": {
    ///    "algoId": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "algoName": {
    ///      "examples": [
    ///        "sha256"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "coinId": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "coinName": {
    ///      "examples": [
    ///        "BTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "poolIndex": {
    ///      "examples": [
    ///        0
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MiningPubCoinListResponseDataItem {
        #[serde(rename = "algoId")]
        pub algo_id: i64,
        #[serde(rename = "algoName")]
        pub algo_name: String,
        #[serde(rename = "coinId")]
        pub coin_id: i64,
        #[serde(rename = "coinName")]
        pub coin_name: String,
        #[serde(rename = "poolIndex")]
        pub pool_index: i64,
    }
    impl From<&MiningPubCoinListResponseDataItem> for MiningPubCoinListResponseDataItem {
        fn from(value: &MiningPubCoinListResponseDataItem) -> Self {
            value.clone()
        }
    }
    ///MiningStatisticsUserListResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "code",
    ///    "data",
    ///    "msg"
    ///  ],
    ///  "properties": {
    ///    "code": {
    ///      "examples": [
    ///        0
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "data": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "list",
    ///          "type",
    ///          "userName"
    ///        ],
    ///        "properties": {
    ///          "list": {
    ///            "type": "array",
    ///            "items": {
    ///              "type": "object",
    ///              "required": [
    ///                "hashrate",
    ///                "reject",
    ///                "time"
    ///              ],
    ///              "properties": {
    ///                "hashrate": {
    ///                  "examples": [
    ///                    "0.00000000"
    ///                  ],
    ///                  "type": "string"
    ///                },
    ///                "reject": {
    ///                  "examples": [
    ///                    "0.00000000"
    ///                  ],
    ///                  "type": "string"
    ///                },
    ///                "time": {
    ///                  "examples": [
    ///                    1585267200000
    ///                  ],
    ///                  "type": "integer",
    ///                  "format": "int64"
    ///                }
    ///              }
    ///            }
    ///          },
    ///          "type": {
    ///            "examples": [
    ///              "H_hashrate"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "userName": {
    ///            "examples": [
    ///              "test"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "msg": {
    ///      "examples": [
    ///        ""
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MiningStatisticsUserListResponse {
        pub code: i64,
        pub data: Vec<MiningStatisticsUserListResponseDataItem>,
        pub msg: String,
    }
    impl From<&MiningStatisticsUserListResponse> for MiningStatisticsUserListResponse {
        fn from(value: &MiningStatisticsUserListResponse) -> Self {
            value.clone()
        }
    }
    ///MiningStatisticsUserListResponseDataItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "list",
    ///    "type",
    ///    "userName"
    ///  ],
    ///  "properties": {
    ///    "list": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "hashrate",
    ///          "reject",
    ///          "time"
    ///        ],
    ///        "properties": {
    ///          "hashrate": {
    ///            "examples": [
    ///              "0.00000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "reject": {
    ///            "examples": [
    ///              "0.00000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "time": {
    ///            "examples": [
    ///              1585267200000
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "type": {
    ///      "examples": [
    ///        "H_hashrate"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "userName": {
    ///      "examples": [
    ///        "test"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MiningStatisticsUserListResponseDataItem {
        pub list: Vec<MiningStatisticsUserListResponseDataItemListItem>,
        #[serde(rename = "type")]
        pub type_: String,
        #[serde(rename = "userName")]
        pub user_name: String,
    }
    impl From<&MiningStatisticsUserListResponseDataItem>
    for MiningStatisticsUserListResponseDataItem {
        fn from(value: &MiningStatisticsUserListResponseDataItem) -> Self {
            value.clone()
        }
    }
    ///MiningStatisticsUserListResponseDataItemListItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "hashrate",
    ///    "reject",
    ///    "time"
    ///  ],
    ///  "properties": {
    ///    "hashrate": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "reject": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "time": {
    ///      "examples": [
    ///        1585267200000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MiningStatisticsUserListResponseDataItemListItem {
        pub hashrate: String,
        pub reject: String,
        pub time: i64,
    }
    impl From<&MiningStatisticsUserListResponseDataItemListItem>
    for MiningStatisticsUserListResponseDataItemListItem {
        fn from(value: &MiningStatisticsUserListResponseDataItemListItem) -> Self {
            value.clone()
        }
    }
    ///MiningStatisticsUserStatusResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "code",
    ///    "data",
    ///    "msg"
    ///  ],
    ///  "properties": {
    ///    "code": {
    ///      "examples": [
    ///        0
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "data": {
    ///      "type": "object",
    ///      "required": [
    ///        "algo",
    ///        "dayHashRate",
    ///        "fifteenMinHashRate",
    ///        "invalidNum",
    ///        "profitToday",
    ///        "profitYesterday",
    ///        "unit",
    ///        "userName",
    ///        "validNum"
    ///      ],
    ///      "properties": {
    ///        "algo": {
    ///          "examples": [
    ///            "sha256"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "dayHashRate": {
    ///          "examples": [
    ///            "214289268068874127.65000000"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "fifteenMinHashRate": {
    ///          "examples": [
    ///            "457835490067496409.00000000"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "invalidNum": {
    ///          "examples": [
    ///            17562
    ///          ],
    ///          "type": "integer",
    ///          "format": "int64"
    ///        },
    ///        "profitToday": {
    ///          "type": "object",
    ///          "required": [
    ///            "BCH",
    ///            "BSV",
    ///            "BTC"
    ///          ],
    ///          "properties": {
    ///            "BCH": {
    ///              "examples": [
    ///                "106.61586001"
    ///              ],
    ///              "type": "string"
    ///            },
    ///            "BSV": {
    ///              "examples": [
    ///                "56.17055953"
    ///              ],
    ///              "type": "string"
    ///            },
    ///            "BTC": {
    ///              "examples": [
    ///                "0.00314332"
    ///              ],
    ///              "type": "string"
    ///            }
    ///          }
    ///        },
    ///        "profitYesterday": {
    ///          "type": "object",
    ///          "required": [
    ///            "BCH",
    ///            "BSV",
    ///            "BTC"
    ///          ],
    ///          "properties": {
    ///            "BCH": {
    ///              "examples": [
    ///                "106.61586001"
    ///              ],
    ///              "type": "string"
    ///            },
    ///            "BSV": {
    ///              "examples": [
    ///                "56.17055953"
    ///              ],
    ///              "type": "string"
    ///            },
    ///            "BTC": {
    ///              "examples": [
    ///                "0.00314332"
    ///              ],
    ///              "type": "string"
    ///            }
    ///          }
    ///        },
    ///        "unit": {
    ///          "examples": [
    ///            "h/s"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "userName": {
    ///          "examples": [
    ///            "test"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "validNum": {
    ///          "examples": [
    ///            0
    ///          ],
    ///          "type": "integer",
    ///          "format": "int64"
    ///        }
    ///      }
    ///    },
    ///    "msg": {
    ///      "examples": [
    ///        ""
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MiningStatisticsUserStatusResponse {
        pub code: i64,
        pub data: MiningStatisticsUserStatusResponseData,
        pub msg: String,
    }
    impl From<&MiningStatisticsUserStatusResponse>
    for MiningStatisticsUserStatusResponse {
        fn from(value: &MiningStatisticsUserStatusResponse) -> Self {
            value.clone()
        }
    }
    ///MiningStatisticsUserStatusResponseData
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "algo",
    ///    "dayHashRate",
    ///    "fifteenMinHashRate",
    ///    "invalidNum",
    ///    "profitToday",
    ///    "profitYesterday",
    ///    "unit",
    ///    "userName",
    ///    "validNum"
    ///  ],
    ///  "properties": {
    ///    "algo": {
    ///      "examples": [
    ///        "sha256"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "dayHashRate": {
    ///      "examples": [
    ///        "214289268068874127.65000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "fifteenMinHashRate": {
    ///      "examples": [
    ///        "457835490067496409.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "invalidNum": {
    ///      "examples": [
    ///        17562
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "profitToday": {
    ///      "type": "object",
    ///      "required": [
    ///        "BCH",
    ///        "BSV",
    ///        "BTC"
    ///      ],
    ///      "properties": {
    ///        "BCH": {
    ///          "examples": [
    ///            "106.61586001"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "BSV": {
    ///          "examples": [
    ///            "56.17055953"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "BTC": {
    ///          "examples": [
    ///            "0.00314332"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "profitYesterday": {
    ///      "type": "object",
    ///      "required": [
    ///        "BCH",
    ///        "BSV",
    ///        "BTC"
    ///      ],
    ///      "properties": {
    ///        "BCH": {
    ///          "examples": [
    ///            "106.61586001"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "BSV": {
    ///          "examples": [
    ///            "56.17055953"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "BTC": {
    ///          "examples": [
    ///            "0.00314332"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "unit": {
    ///      "examples": [
    ///        "h/s"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "userName": {
    ///      "examples": [
    ///        "test"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "validNum": {
    ///      "examples": [
    ///        0
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MiningStatisticsUserStatusResponseData {
        pub algo: String,
        #[serde(rename = "dayHashRate")]
        pub day_hash_rate: String,
        #[serde(rename = "fifteenMinHashRate")]
        pub fifteen_min_hash_rate: String,
        #[serde(rename = "invalidNum")]
        pub invalid_num: i64,
        #[serde(rename = "profitToday")]
        pub profit_today: MiningStatisticsUserStatusResponseDataProfitToday,
        #[serde(rename = "profitYesterday")]
        pub profit_yesterday: MiningStatisticsUserStatusResponseDataProfitYesterday,
        pub unit: String,
        #[serde(rename = "userName")]
        pub user_name: String,
        #[serde(rename = "validNum")]
        pub valid_num: i64,
    }
    impl From<&MiningStatisticsUserStatusResponseData>
    for MiningStatisticsUserStatusResponseData {
        fn from(value: &MiningStatisticsUserStatusResponseData) -> Self {
            value.clone()
        }
    }
    ///MiningStatisticsUserStatusResponseDataProfitToday
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "BCH",
    ///    "BSV",
    ///    "BTC"
    ///  ],
    ///  "properties": {
    ///    "BCH": {
    ///      "examples": [
    ///        "106.61586001"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "BSV": {
    ///      "examples": [
    ///        "56.17055953"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "BTC": {
    ///      "examples": [
    ///        "0.00314332"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MiningStatisticsUserStatusResponseDataProfitToday {
        #[serde(rename = "BCH")]
        pub bch: String,
        #[serde(rename = "BSV")]
        pub bsv: String,
        #[serde(rename = "BTC")]
        pub btc: String,
    }
    impl From<&MiningStatisticsUserStatusResponseDataProfitToday>
    for MiningStatisticsUserStatusResponseDataProfitToday {
        fn from(value: &MiningStatisticsUserStatusResponseDataProfitToday) -> Self {
            value.clone()
        }
    }
    ///MiningStatisticsUserStatusResponseDataProfitYesterday
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "BCH",
    ///    "BSV",
    ///    "BTC"
    ///  ],
    ///  "properties": {
    ///    "BCH": {
    ///      "examples": [
    ///        "106.61586001"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "BSV": {
    ///      "examples": [
    ///        "56.17055953"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "BTC": {
    ///      "examples": [
    ///        "0.00314332"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MiningStatisticsUserStatusResponseDataProfitYesterday {
        #[serde(rename = "BCH")]
        pub bch: String,
        #[serde(rename = "BSV")]
        pub bsv: String,
        #[serde(rename = "BTC")]
        pub btc: String,
    }
    impl From<&MiningStatisticsUserStatusResponseDataProfitYesterday>
    for MiningStatisticsUserStatusResponseDataProfitYesterday {
        fn from(value: &MiningStatisticsUserStatusResponseDataProfitYesterday) -> Self {
            value.clone()
        }
    }
    ///MiningWorkerDetailResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "code",
    ///    "data",
    ///    "msg"
    ///  ],
    ///  "properties": {
    ///    "code": {
    ///      "examples": [
    ///        0
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "data": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "hashrateDatas",
    ///          "type",
    ///          "workerName"
    ///        ],
    ///        "properties": {
    ///          "hashrateDatas": {
    ///            "type": "array",
    ///            "items": {
    ///              "type": "object",
    ///              "required": [
    ///                "hashrate",
    ///                "reject",
    ///                "time"
    ///              ],
    ///              "properties": {
    ///                "hashrate": {
    ///                  "examples": [
    ///                    "0"
    ///                  ],
    ///                  "type": "string"
    ///                },
    ///                "reject": {
    ///                  "description": "Rejection Rate",
    ///                  "examples": [
    ///                    0
    ///                  ],
    ///                  "type": "integer",
    ///                  "format": "int64"
    ///                },
    ///                "time": {
    ///                  "examples": [
    ///                    1587902400000
    ///                  ],
    ///                  "type": "integer",
    ///                  "format": "int64"
    ///                }
    ///              }
    ///            }
    ///          },
    ///          "type": {
    ///            "description": "Type of hourly hashrate",
    ///            "examples": [
    ///              "H_hashrate"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "workerName": {
    ///            "description": "Mining Account name",
    ///            "examples": [
    ///              "bhdc1.16A10404B"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "msg": {
    ///      "examples": [
    ///        ""
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MiningWorkerDetailResponse {
        pub code: i64,
        pub data: Vec<MiningWorkerDetailResponseDataItem>,
        pub msg: String,
    }
    impl From<&MiningWorkerDetailResponse> for MiningWorkerDetailResponse {
        fn from(value: &MiningWorkerDetailResponse) -> Self {
            value.clone()
        }
    }
    ///MiningWorkerDetailResponseDataItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "hashrateDatas",
    ///    "type",
    ///    "workerName"
    ///  ],
    ///  "properties": {
    ///    "hashrateDatas": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "hashrate",
    ///          "reject",
    ///          "time"
    ///        ],
    ///        "properties": {
    ///          "hashrate": {
    ///            "examples": [
    ///              "0"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "reject": {
    ///            "description": "Rejection Rate",
    ///            "examples": [
    ///              0
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "time": {
    ///            "examples": [
    ///              1587902400000
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "type": {
    ///      "description": "Type of hourly hashrate",
    ///      "examples": [
    ///        "H_hashrate"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "workerName": {
    ///      "description": "Mining Account name",
    ///      "examples": [
    ///        "bhdc1.16A10404B"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MiningWorkerDetailResponseDataItem {
        #[serde(rename = "hashrateDatas")]
        pub hashrate_datas: Vec<MiningWorkerDetailResponseDataItemHashrateDatasItem>,
        ///Type of hourly hashrate
        #[serde(rename = "type")]
        pub type_: String,
        ///Mining Account name
        #[serde(rename = "workerName")]
        pub worker_name: String,
    }
    impl From<&MiningWorkerDetailResponseDataItem>
    for MiningWorkerDetailResponseDataItem {
        fn from(value: &MiningWorkerDetailResponseDataItem) -> Self {
            value.clone()
        }
    }
    ///MiningWorkerDetailResponseDataItemHashrateDatasItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "hashrate",
    ///    "reject",
    ///    "time"
    ///  ],
    ///  "properties": {
    ///    "hashrate": {
    ///      "examples": [
    ///        "0"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "reject": {
    ///      "description": "Rejection Rate",
    ///      "examples": [
    ///        0
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "time": {
    ///      "examples": [
    ///        1587902400000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MiningWorkerDetailResponseDataItemHashrateDatasItem {
        pub hashrate: String,
        ///Rejection Rate
        pub reject: i64,
        pub time: i64,
    }
    impl From<&MiningWorkerDetailResponseDataItemHashrateDatasItem>
    for MiningWorkerDetailResponseDataItemHashrateDatasItem {
        fn from(value: &MiningWorkerDetailResponseDataItemHashrateDatasItem) -> Self {
            value.clone()
        }
    }
    ///MiningWorkerListResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "code",
    ///    "data",
    ///    "msg"
    ///  ],
    ///  "properties": {
    ///    "code": {
    ///      "examples": [
    ///        0
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "data": {
    ///      "type": "object",
    ///      "required": [
    ///        "pageSize",
    ///        "totalNum",
    ///        "workerDatas"
    ///      ],
    ///      "properties": {
    ///        "pageSize": {
    ///          "examples": [
    ///            20
    ///          ],
    ///          "type": "integer",
    ///          "format": "int64"
    ///        },
    ///        "totalNum": {
    ///          "examples": [
    ///            18530
    ///          ],
    ///          "type": "integer",
    ///          "format": "int64"
    ///        },
    ///        "workerDatas": {
    ///          "type": "array",
    ///          "items": {
    ///            "type": "object",
    ///            "required": [
    ///              "dayHashRate",
    ///              "hashRate",
    ///              "lastShareTime",
    ///              "rejectRate",
    ///              "status",
    ///              "workerId",
    ///              "workerName"
    ///            ],
    ///            "properties": {
    ///              "dayHashRate": {
    ///                "description": "24H Hashrate",
    ///                "examples": [
    ///                  0
    ///                ],
    ///                "type": "integer",
    ///                "format": "int64"
    ///              },
    ///              "hashRate": {
    ///                "description": "Real-time rate",
    ///                "examples": [
    ///                  0
    ///                ],
    ///                "type": "integer",
    ///                "format": "int64"
    ///              },
    ///              "lastShareTime": {
    ///                "description": "Last submission time",
    ///                "examples": [
    ///                  1587712919000
    ///                ],
    ///                "type": "integer",
    ///                "format": "int64"
    ///              },
    ///              "rejectRate": {
    ///                "description": "Real-time Rejection Rate",
    ///                "examples": [
    ///                  0
    ///                ],
    ///                "type": "integer",
    ///                "format": "int64"
    ///              },
    ///              "status": {
    ///                "description": "Status1 valid, 2 invalid, 3 no longer valid",
    ///                "examples": [
    ///                  3
    ///                ],
    ///                "type": "integer",
    ///                "format": "int64"
    ///              },
    ///              "workerId": {
    ///                "examples": [
    ///                  "1420554439452400131"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "workerName": {
    ///                "examples": [
    ///                  "2X73"
    ///                ],
    ///                "type": "string"
    ///              }
    ///            }
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "msg": {
    ///      "examples": [
    ///        ""
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MiningWorkerListResponse {
        pub code: i64,
        pub data: MiningWorkerListResponseData,
        pub msg: String,
    }
    impl From<&MiningWorkerListResponse> for MiningWorkerListResponse {
        fn from(value: &MiningWorkerListResponse) -> Self {
            value.clone()
        }
    }
    ///MiningWorkerListResponseData
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "pageSize",
    ///    "totalNum",
    ///    "workerDatas"
    ///  ],
    ///  "properties": {
    ///    "pageSize": {
    ///      "examples": [
    ///        20
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "totalNum": {
    ///      "examples": [
    ///        18530
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "workerDatas": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "dayHashRate",
    ///          "hashRate",
    ///          "lastShareTime",
    ///          "rejectRate",
    ///          "status",
    ///          "workerId",
    ///          "workerName"
    ///        ],
    ///        "properties": {
    ///          "dayHashRate": {
    ///            "description": "24H Hashrate",
    ///            "examples": [
    ///              0
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "hashRate": {
    ///            "description": "Real-time rate",
    ///            "examples": [
    ///              0
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "lastShareTime": {
    ///            "description": "Last submission time",
    ///            "examples": [
    ///              1587712919000
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "rejectRate": {
    ///            "description": "Real-time Rejection Rate",
    ///            "examples": [
    ///              0
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "status": {
    ///            "description": "Status1 valid, 2 invalid, 3 no longer valid",
    ///            "examples": [
    ///              3
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "workerId": {
    ///            "examples": [
    ///              "1420554439452400131"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "workerName": {
    ///            "examples": [
    ///              "2X73"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MiningWorkerListResponseData {
        #[serde(rename = "pageSize")]
        pub page_size: i64,
        #[serde(rename = "totalNum")]
        pub total_num: i64,
        #[serde(rename = "workerDatas")]
        pub worker_datas: Vec<MiningWorkerListResponseDataWorkerDatasItem>,
    }
    impl From<&MiningWorkerListResponseData> for MiningWorkerListResponseData {
        fn from(value: &MiningWorkerListResponseData) -> Self {
            value.clone()
        }
    }
    ///MiningWorkerListResponseDataWorkerDatasItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "dayHashRate",
    ///    "hashRate",
    ///    "lastShareTime",
    ///    "rejectRate",
    ///    "status",
    ///    "workerId",
    ///    "workerName"
    ///  ],
    ///  "properties": {
    ///    "dayHashRate": {
    ///      "description": "24H Hashrate",
    ///      "examples": [
    ///        0
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "hashRate": {
    ///      "description": "Real-time rate",
    ///      "examples": [
    ///        0
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "lastShareTime": {
    ///      "description": "Last submission time",
    ///      "examples": [
    ///        1587712919000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "rejectRate": {
    ///      "description": "Real-time Rejection Rate",
    ///      "examples": [
    ///        0
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "status": {
    ///      "description": "Status1 valid, 2 invalid, 3 no longer valid",
    ///      "examples": [
    ///        3
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "workerId": {
    ///      "examples": [
    ///        "1420554439452400131"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "workerName": {
    ///      "examples": [
    ///        "2X73"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MiningWorkerListResponseDataWorkerDatasItem {
        ///24H Hashrate
        #[serde(rename = "dayHashRate")]
        pub day_hash_rate: i64,
        ///Real-time rate
        #[serde(rename = "hashRate")]
        pub hash_rate: i64,
        ///Last submission time
        #[serde(rename = "lastShareTime")]
        pub last_share_time: i64,
        ///Real-time Rejection Rate
        #[serde(rename = "rejectRate")]
        pub reject_rate: i64,
        ///Status1 valid, 2 invalid, 3 no longer valid
        pub status: i64,
        #[serde(rename = "workerId")]
        pub worker_id: String,
        #[serde(rename = "workerName")]
        pub worker_name: String,
    }
    impl From<&MiningWorkerListResponseDataWorkerDatasItem>
    for MiningWorkerListResponseDataWorkerDatasItem {
        fn from(value: &MiningWorkerListResponseDataWorkerDatasItem) -> Self {
            value.clone()
        }
    }
    ///MyAllocationsResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "allocationId",
    ///    "allocationType",
    ///    "commission",
    ///    "commissionAsset",
    ///    "isAllocator",
    ///    "isBuyer",
    ///    "isMaker",
    ///    "orderId",
    ///    "orderListId",
    ///    "price",
    ///    "qty",
    ///    "quoteQty",
    ///    "symbol",
    ///    "time"
    ///  ],
    ///  "properties": {
    ///    "allocationId": {
    ///      "examples": [
    ///        0
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "allocationType": {
    ///      "examples": [
    ///        "SOR"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "commission": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "commissionAsset": {
    ///      "examples": [
    ///        "BTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "isAllocator": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "isBuyer": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "isMaker": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "orderId": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "orderListId": {
    ///      "examples": [
    ///        -1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "price": {
    ///      "examples": [
    ///        "1.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "qty": {
    ///      "examples": [
    ///        "5.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "quoteQty": {
    ///      "examples": [
    ///        "5.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "symbol": {
    ///      "examples": [
    ///        "BTCUSDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "time": {
    ///      "examples": [
    ///        1687506878118
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MyAllocationsResponseItem {
        #[serde(rename = "allocationId")]
        pub allocation_id: i64,
        #[serde(rename = "allocationType")]
        pub allocation_type: String,
        pub commission: String,
        #[serde(rename = "commissionAsset")]
        pub commission_asset: String,
        #[serde(rename = "isAllocator")]
        pub is_allocator: bool,
        #[serde(rename = "isBuyer")]
        pub is_buyer: bool,
        #[serde(rename = "isMaker")]
        pub is_maker: bool,
        #[serde(rename = "orderId")]
        pub order_id: i64,
        #[serde(rename = "orderListId")]
        pub order_list_id: i64,
        pub price: String,
        pub qty: String,
        #[serde(rename = "quoteQty")]
        pub quote_qty: String,
        pub symbol: String,
        pub time: i64,
    }
    impl From<&MyAllocationsResponseItem> for MyAllocationsResponseItem {
        fn from(value: &MyAllocationsResponseItem) -> Self {
            value.clone()
        }
    }
    ///MyPreventedMatchesResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "makerOrderId",
    ///    "makerPreventedQuantity",
    ///    "preventedMatchId",
    ///    "price",
    ///    "selfTradePreventionMode",
    ///    "symbol",
    ///    "takerOrderId",
    ///    "tradeGroupId",
    ///    "transactTime"
    ///  ],
    ///  "properties": {
    ///    "makerOrderId": {
    ///      "examples": [
    ///        3
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "makerPreventedQuantity": {
    ///      "examples": [
    ///        "1.300000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "preventedMatchId": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "price": {
    ///      "examples": [
    ///        "1.100000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "selfTradePreventionMode": {
    ///      "examples": [
    ///        "EXPIRE_MAKER"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "symbol": {
    ///      "examples": [
    ///        "BTCUSDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "takerOrderId": {
    ///      "examples": [
    ///        5
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "tradeGroupId": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "transactTime": {
    ///      "examples": [
    ///        1669101687094
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MyPreventedMatchesResponseItem {
        #[serde(rename = "makerOrderId")]
        pub maker_order_id: i64,
        #[serde(rename = "makerPreventedQuantity")]
        pub maker_prevented_quantity: String,
        #[serde(rename = "preventedMatchId")]
        pub prevented_match_id: i64,
        pub price: String,
        #[serde(rename = "selfTradePreventionMode")]
        pub self_trade_prevention_mode: String,
        pub symbol: String,
        #[serde(rename = "takerOrderId")]
        pub taker_order_id: i64,
        #[serde(rename = "tradeGroupId")]
        pub trade_group_id: i64,
        #[serde(rename = "transactTime")]
        pub transact_time: i64,
    }
    impl From<&MyPreventedMatchesResponseItem> for MyPreventedMatchesResponseItem {
        fn from(value: &MyPreventedMatchesResponseItem) -> Self {
            value.clone()
        }
    }
    ///MyTrade
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "commission",
    ///    "commissionAsset",
    ///    "id",
    ///    "isBestMatch",
    ///    "isBuyer",
    ///    "isMaker",
    ///    "orderId",
    ///    "orderListId",
    ///    "price",
    ///    "qty",
    ///    "quoteQty",
    ///    "symbol",
    ///    "time"
    ///  ],
    ///  "properties": {
    ///    "commission": {
    ///      "examples": [
    ///        "10.10000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "commissionAsset": {
    ///      "examples": [
    ///        "BNB"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "Trade id",
    ///      "examples": [
    ///        28457
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "isBestMatch": {
    ///      "type": "boolean"
    ///    },
    ///    "isBuyer": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "isMaker": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "orderId": {
    ///      "examples": [
    ///        100234
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "orderListId": {
    ///      "examples": [
    ///        -1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "price": {
    ///      "description": "Price",
    ///      "examples": [
    ///        "4.00000100"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "qty": {
    ///      "description": "Amount of base asset",
    ///      "examples": [
    ///        "12.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "quoteQty": {
    ///      "description": "Amount of quote asset",
    ///      "examples": [
    ///        "48.000012"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "symbol": {
    ///      "examples": [
    ///        "BNBBTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "time": {
    ///      "description": "Trade timestamp",
    ///      "examples": [
    ///        1499865549590
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MyTrade {
        pub commission: String,
        #[serde(rename = "commissionAsset")]
        pub commission_asset: String,
        ///Trade id
        pub id: i64,
        #[serde(rename = "isBestMatch")]
        pub is_best_match: bool,
        #[serde(rename = "isBuyer")]
        pub is_buyer: bool,
        #[serde(rename = "isMaker")]
        pub is_maker: bool,
        #[serde(rename = "orderId")]
        pub order_id: i64,
        #[serde(rename = "orderListId")]
        pub order_list_id: i64,
        ///Price
        pub price: String,
        ///Amount of base asset
        pub qty: String,
        ///Amount of quote asset
        #[serde(rename = "quoteQty")]
        pub quote_qty: String,
        pub symbol: String,
        ///Trade timestamp
        pub time: i64,
    }
    impl From<&MyTrade> for MyTrade {
        fn from(value: &MyTrade) -> Self {
            value.clone()
        }
    }
    ///NftHistoryDepositResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "list",
    ///    "total"
    ///  ],
    ///  "properties": {
    ///    "list": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "contractAdrress",
    ///          "network",
    ///          "timestamp",
    ///          "tokenId",
    ///          "txID"
    ///        ],
    ///        "properties": {
    ///          "contractAdrress": {
    ///            "examples": [
    ///              "0xe507c961ee127d4439977a61af39c34eafee0dc6"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "network": {
    ///            "examples": [
    ///              "ETH"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "timestamp": {
    ///            "examples": [
    ///              1629986047000
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "tokenId": {
    ///            "examples": [
    ///              "10014"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "txID": {
    ///            "type": [
    ///              "integer",
    ///              "null"
    ///            ]
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "total": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct NftHistoryDepositResponse {
        pub list: Vec<NftHistoryDepositResponseListItem>,
        pub total: i32,
    }
    impl From<&NftHistoryDepositResponse> for NftHistoryDepositResponse {
        fn from(value: &NftHistoryDepositResponse) -> Self {
            value.clone()
        }
    }
    ///NftHistoryDepositResponseListItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "contractAdrress",
    ///    "network",
    ///    "timestamp",
    ///    "tokenId",
    ///    "txID"
    ///  ],
    ///  "properties": {
    ///    "contractAdrress": {
    ///      "examples": [
    ///        "0xe507c961ee127d4439977a61af39c34eafee0dc6"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "network": {
    ///      "examples": [
    ///        "ETH"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "timestamp": {
    ///      "examples": [
    ///        1629986047000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "tokenId": {
    ///      "examples": [
    ///        "10014"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "txID": {
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct NftHistoryDepositResponseListItem {
        #[serde(rename = "contractAdrress")]
        pub contract_adrress: String,
        pub network: String,
        pub timestamp: i64,
        #[serde(rename = "tokenId")]
        pub token_id: String,
        #[serde(rename = "txID")]
        pub tx_id: Option<i64>,
    }
    impl From<&NftHistoryDepositResponseListItem> for NftHistoryDepositResponseListItem {
        fn from(value: &NftHistoryDepositResponseListItem) -> Self {
            value.clone()
        }
    }
    ///NftHistoryTransactionsResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "list",
    ///    "total"
    ///  ],
    ///  "properties": {
    ///    "list": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "orderNo",
    ///          "tokens",
    ///          "tradeAmount",
    ///          "tradeCurrency",
    ///          "tradeTime"
    ///        ],
    ///        "properties": {
    ///          "orderNo": {
    ///            "description": "0: purchase order, 1: sell order, 2: royalty income, 3: primary market order, 4: mint fee",
    ///            "examples": [
    ///              "1_470502070600699904"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "tokens": {
    ///            "type": "array",
    ///            "items": {
    ///              "type": "object",
    ///              "required": [
    ///                "contractAddress",
    ///                "network",
    ///                "tokenId"
    ///              ],
    ///              "properties": {
    ///                "contractAddress": {
    ///                  "examples": [
    ///                    "MYSTERY_BOX0000087"
    ///                  ],
    ///                  "type": "string"
    ///                },
    ///                "network": {
    ///                  "examples": [
    ///                    "BSC"
    ///                  ],
    ///                  "type": "string"
    ///                },
    ///                "tokenId": {
    ///                  "examples": [
    ///                    "216000000496"
    ///                  ],
    ///                  "type": "string"
    ///                }
    ///              }
    ///            }
    ///          },
    ///          "tradeAmount": {
    ///            "examples": [
    ///              "19.60000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "tradeCurrency": {
    ///            "examples": [
    ///              "BNB"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "tradeTime": {
    ///            "examples": [
    ///              1626941236000
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "total": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct NftHistoryTransactionsResponse {
        pub list: Vec<NftHistoryTransactionsResponseListItem>,
        pub total: i32,
    }
    impl From<&NftHistoryTransactionsResponse> for NftHistoryTransactionsResponse {
        fn from(value: &NftHistoryTransactionsResponse) -> Self {
            value.clone()
        }
    }
    ///NftHistoryTransactionsResponseListItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "orderNo",
    ///    "tokens",
    ///    "tradeAmount",
    ///    "tradeCurrency",
    ///    "tradeTime"
    ///  ],
    ///  "properties": {
    ///    "orderNo": {
    ///      "description": "0: purchase order, 1: sell order, 2: royalty income, 3: primary market order, 4: mint fee",
    ///      "examples": [
    ///        "1_470502070600699904"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "tokens": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "contractAddress",
    ///          "network",
    ///          "tokenId"
    ///        ],
    ///        "properties": {
    ///          "contractAddress": {
    ///            "examples": [
    ///              "MYSTERY_BOX0000087"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "network": {
    ///            "examples": [
    ///              "BSC"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "tokenId": {
    ///            "examples": [
    ///              "216000000496"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "tradeAmount": {
    ///      "examples": [
    ///        "19.60000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "tradeCurrency": {
    ///      "examples": [
    ///        "BNB"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "tradeTime": {
    ///      "examples": [
    ///        1626941236000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct NftHistoryTransactionsResponseListItem {
        ///0: purchase order, 1: sell order, 2: royalty income, 3: primary market order, 4: mint fee
        #[serde(rename = "orderNo")]
        pub order_no: String,
        pub tokens: Vec<NftHistoryTransactionsResponseListItemTokensItem>,
        #[serde(rename = "tradeAmount")]
        pub trade_amount: String,
        #[serde(rename = "tradeCurrency")]
        pub trade_currency: String,
        #[serde(rename = "tradeTime")]
        pub trade_time: i64,
    }
    impl From<&NftHistoryTransactionsResponseListItem>
    for NftHistoryTransactionsResponseListItem {
        fn from(value: &NftHistoryTransactionsResponseListItem) -> Self {
            value.clone()
        }
    }
    ///NftHistoryTransactionsResponseListItemTokensItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "contractAddress",
    ///    "network",
    ///    "tokenId"
    ///  ],
    ///  "properties": {
    ///    "contractAddress": {
    ///      "examples": [
    ///        "MYSTERY_BOX0000087"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "network": {
    ///      "examples": [
    ///        "BSC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "tokenId": {
    ///      "examples": [
    ///        "216000000496"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct NftHistoryTransactionsResponseListItemTokensItem {
        #[serde(rename = "contractAddress")]
        pub contract_address: String,
        pub network: String,
        #[serde(rename = "tokenId")]
        pub token_id: String,
    }
    impl From<&NftHistoryTransactionsResponseListItemTokensItem>
    for NftHistoryTransactionsResponseListItemTokensItem {
        fn from(value: &NftHistoryTransactionsResponseListItemTokensItem) -> Self {
            value.clone()
        }
    }
    ///NftHistoryWithdrawResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "list",
    ///    "total"
    ///  ],
    ///  "properties": {
    ///    "list": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "contractAdrress",
    ///          "fee",
    ///          "feeAsset",
    ///          "network",
    ///          "timestamp",
    ///          "tokenId",
    ///          "txID"
    ///        ],
    ///        "properties": {
    ///          "contractAdrress": {
    ///            "examples": [
    ///              "0xe507c961ee127d4439977a61af39c34eafee0dc6"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "fee": {
    ///            "examples": [
    ///              0.1
    ///            ],
    ///            "type": "number"
    ///          },
    ///          "feeAsset": {
    ///            "examples": [
    ///              "ETH"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "network": {
    ///            "examples": [
    ///              "ETH"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "timestamp": {
    ///            "examples": [
    ///              1633674433000
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "tokenId": {
    ///            "examples": [
    ///              "1000001247"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "txID": {
    ///            "examples": [
    ///              "0x2be5eed31d787fdb4880bc631c8e76bdfb6150e137f5cf1732e0416ea206f57f"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "total": {
    ///      "examples": [
    ///        178
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct NftHistoryWithdrawResponse {
        pub list: Vec<NftHistoryWithdrawResponseListItem>,
        pub total: i32,
    }
    impl From<&NftHistoryWithdrawResponse> for NftHistoryWithdrawResponse {
        fn from(value: &NftHistoryWithdrawResponse) -> Self {
            value.clone()
        }
    }
    ///NftHistoryWithdrawResponseListItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "contractAdrress",
    ///    "fee",
    ///    "feeAsset",
    ///    "network",
    ///    "timestamp",
    ///    "tokenId",
    ///    "txID"
    ///  ],
    ///  "properties": {
    ///    "contractAdrress": {
    ///      "examples": [
    ///        "0xe507c961ee127d4439977a61af39c34eafee0dc6"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "fee": {
    ///      "examples": [
    ///        0.1
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "feeAsset": {
    ///      "examples": [
    ///        "ETH"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "network": {
    ///      "examples": [
    ///        "ETH"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "timestamp": {
    ///      "examples": [
    ///        1633674433000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "tokenId": {
    ///      "examples": [
    ///        "1000001247"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "txID": {
    ///      "examples": [
    ///        "0x2be5eed31d787fdb4880bc631c8e76bdfb6150e137f5cf1732e0416ea206f57f"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct NftHistoryWithdrawResponseListItem {
        #[serde(rename = "contractAdrress")]
        pub contract_adrress: String,
        pub fee: f64,
        #[serde(rename = "feeAsset")]
        pub fee_asset: String,
        pub network: String,
        pub timestamp: i64,
        #[serde(rename = "tokenId")]
        pub token_id: String,
        #[serde(rename = "txID")]
        pub tx_id: String,
    }
    impl From<&NftHistoryWithdrawResponseListItem>
    for NftHistoryWithdrawResponseListItem {
        fn from(value: &NftHistoryWithdrawResponseListItem) -> Self {
            value.clone()
        }
    }
    ///NftUserGetAssetResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "list",
    ///    "total"
    ///  ],
    ///  "properties": {
    ///    "list": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "contractAddress",
    ///          "network",
    ///          "tokenId"
    ///        ],
    ///        "properties": {
    ///          "contractAddress": {
    ///            "examples": [
    ///              "REGULAR11234567891779"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "network": {
    ///            "examples": [
    ///              "BSC"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "tokenId": {
    ///            "examples": [
    ///              "100900000017"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "total": {
    ///      "examples": [
    ///        347
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct NftUserGetAssetResponse {
        pub list: Vec<NftUserGetAssetResponseListItem>,
        pub total: i32,
    }
    impl From<&NftUserGetAssetResponse> for NftUserGetAssetResponse {
        fn from(value: &NftUserGetAssetResponse) -> Self {
            value.clone()
        }
    }
    ///NftUserGetAssetResponseListItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "contractAddress",
    ///    "network",
    ///    "tokenId"
    ///  ],
    ///  "properties": {
    ///    "contractAddress": {
    ///      "examples": [
    ///        "REGULAR11234567891779"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "network": {
    ///      "examples": [
    ///        "BSC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "tokenId": {
    ///      "examples": [
    ///        "100900000017"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct NftUserGetAssetResponseListItem {
        #[serde(rename = "contractAddress")]
        pub contract_address: String,
        pub network: String,
        #[serde(rename = "tokenId")]
        pub token_id: String,
    }
    impl From<&NftUserGetAssetResponseListItem> for NftUserGetAssetResponseListItem {
        fn from(value: &NftUserGetAssetResponseListItem) -> Self {
            value.clone()
        }
    }
    ///OcoOrder
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "contingencyType",
    ///    "listClientOrderId",
    ///    "listOrderStatus",
    ///    "listStatusType",
    ///    "orderListId",
    ///    "orderReports",
    ///    "orders",
    ///    "symbol",
    ///    "transactionTime"
    ///  ],
    ///  "properties": {
    ///    "contingencyType": {
    ///      "examples": [
    ///        "OCO"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "listClientOrderId": {
    ///      "examples": [
    ///        "C3wyj4WVEktd7u9aVBRXcN"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "listOrderStatus": {
    ///      "examples": [
    ///        "ALL_DONE"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "listStatusType": {
    ///      "examples": [
    ///        "ALL_DONE"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "orderListId": {
    ///      "examples": [
    ///        1929
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "orderReports": {
    ///      "examples": [
    ///        [
    ///          {
    ///            "clientOrderId": "unfWT8ig8i0uj6lPuYLez6",
    ///            "cummulativeQuoteQty": "0.00000000",
    ///            "executedQty": "0.00000000",
    ///            "orderId": 2,
    ///            "orderListId": 0,
    ///            "origClientOrderId": "pO9ufTiFGg3nw2fOdgeOXa",
    ///            "origQty": "10.00000000",
    ///            "price": "1.00000000",
    ///            "side": "SELL",
    ///            "status": "CANCELED",
    ///            "stopPrice": "1.00000000",
    ///            "symbol": "BNBBTC",
    ///            "timeInForce": "GTC",
    ///            "transactTime": 1688005070874,
    ///            "type": "STOP_LOSS_LIMIT"
    ///          },
    ///          {
    ///            "clientOrderId": "unfWT8ig8i0uj6lPuYLez6",
    ///            "cummulativeQuoteQty": "0.00000000",
    ///            "executedQty": "0.00000000",
    ///            "orderId": 3,
    ///            "orderListId": 0,
    ///            "origClientOrderId": "TXOvglzXuaubXAaENpaRCB",
    ///            "origQty": "10.00000000",
    ///            "price": "3.00000000",
    ///            "selfTradePreventionMode": "NONE",
    ///            "side": "SELL",
    ///            "status": "CANCELED",
    ///            "symbol": "BNBBTC",
    ///            "timeInForce": "GTC",
    ///            "transactTime": 1688005070874,
    ///            "type": "LIMIT_MAKER"
    ///          }
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "clientOrderId",
    ///          "cummulativeQuoteQty",
    ///          "executedQty",
    ///          "orderId",
    ///          "orderListId",
    ///          "origClientOrderId",
    ///          "origQty",
    ///          "price",
    ///          "selfTradePreventionMode",
    ///          "side",
    ///          "status",
    ///          "stopPrice",
    ///          "symbol",
    ///          "timeInForce",
    ///          "transactTime",
    ///          "type"
    ///        ],
    ///        "properties": {
    ///          "clientOrderId": {
    ///            "type": "string"
    ///          },
    ///          "cummulativeQuoteQty": {
    ///            "type": "string"
    ///          },
    ///          "executedQty": {
    ///            "type": "string"
    ///          },
    ///          "orderId": {
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "orderListId": {
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "origClientOrderId": {
    ///            "type": "string"
    ///          },
    ///          "origQty": {
    ///            "type": "string"
    ///          },
    ///          "price": {
    ///            "type": "string"
    ///          },
    ///          "selfTradePreventionMode": {
    ///            "type": "string"
    ///          },
    ///          "side": {
    ///            "type": "string"
    ///          },
    ///          "status": {
    ///            "type": "string"
    ///          },
    ///          "stopPrice": {
    ///            "type": "string"
    ///          },
    ///          "symbol": {
    ///            "type": "string"
    ///          },
    ///          "timeInForce": {
    ///            "type": "string"
    ///          },
    ///          "transactTime": {
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "type": {
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "orders": {
    ///      "examples": [
    ///        [
    ///          {
    ///            "clientOrderId": "pO9ufTiFGg3nw2fOdgeOXa",
    ///            "orderId": 2,
    ///            "symbol": "BNBBTC"
    ///          },
    ///          {
    ///            "clientOrderId": "TXOvglzXuaubXAaENpaRCB",
    ///            "orderId": 3,
    ///            "symbol": "BNBBTC"
    ///          }
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "clientOrderId",
    ///          "orderId",
    ///          "symbol"
    ///        ],
    ///        "properties": {
    ///          "clientOrderId": {
    ///            "type": "string"
    ///          },
    ///          "orderId": {
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "symbol": {
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "symbol": {
    ///      "examples": [
    ///        "BNBBTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "transactionTime": {
    ///      "examples": [
    ///        1574040868128
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct OcoOrder {
        #[serde(rename = "contingencyType")]
        pub contingency_type: String,
        #[serde(rename = "listClientOrderId")]
        pub list_client_order_id: String,
        #[serde(rename = "listOrderStatus")]
        pub list_order_status: String,
        #[serde(rename = "listStatusType")]
        pub list_status_type: String,
        #[serde(rename = "orderListId")]
        pub order_list_id: i64,
        #[serde(rename = "orderReports")]
        pub order_reports: Vec<OcoOrderOrderReportsItem>,
        pub orders: Vec<OcoOrderOrdersItem>,
        pub symbol: String,
        #[serde(rename = "transactionTime")]
        pub transaction_time: i64,
    }
    impl From<&OcoOrder> for OcoOrder {
        fn from(value: &OcoOrder) -> Self {
            value.clone()
        }
    }
    ///OcoOrderOrderReportsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "clientOrderId",
    ///    "cummulativeQuoteQty",
    ///    "executedQty",
    ///    "orderId",
    ///    "orderListId",
    ///    "origClientOrderId",
    ///    "origQty",
    ///    "price",
    ///    "selfTradePreventionMode",
    ///    "side",
    ///    "status",
    ///    "stopPrice",
    ///    "symbol",
    ///    "timeInForce",
    ///    "transactTime",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "clientOrderId": {
    ///      "type": "string"
    ///    },
    ///    "cummulativeQuoteQty": {
    ///      "type": "string"
    ///    },
    ///    "executedQty": {
    ///      "type": "string"
    ///    },
    ///    "orderId": {
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "orderListId": {
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "origClientOrderId": {
    ///      "type": "string"
    ///    },
    ///    "origQty": {
    ///      "type": "string"
    ///    },
    ///    "price": {
    ///      "type": "string"
    ///    },
    ///    "selfTradePreventionMode": {
    ///      "type": "string"
    ///    },
    ///    "side": {
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "type": "string"
    ///    },
    ///    "stopPrice": {
    ///      "type": "string"
    ///    },
    ///    "symbol": {
    ///      "type": "string"
    ///    },
    ///    "timeInForce": {
    ///      "type": "string"
    ///    },
    ///    "transactTime": {
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "type": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct OcoOrderOrderReportsItem {
        #[serde(rename = "clientOrderId")]
        pub client_order_id: String,
        #[serde(rename = "cummulativeQuoteQty")]
        pub cummulative_quote_qty: String,
        #[serde(rename = "executedQty")]
        pub executed_qty: String,
        #[serde(rename = "orderId")]
        pub order_id: i64,
        #[serde(rename = "orderListId")]
        pub order_list_id: i64,
        #[serde(rename = "origClientOrderId")]
        pub orig_client_order_id: String,
        #[serde(rename = "origQty")]
        pub orig_qty: String,
        pub price: String,
        #[serde(rename = "selfTradePreventionMode")]
        pub self_trade_prevention_mode: String,
        pub side: String,
        pub status: String,
        #[serde(rename = "stopPrice")]
        pub stop_price: String,
        pub symbol: String,
        #[serde(rename = "timeInForce")]
        pub time_in_force: String,
        #[serde(rename = "transactTime")]
        pub transact_time: i64,
        #[serde(rename = "type")]
        pub type_: String,
    }
    impl From<&OcoOrderOrderReportsItem> for OcoOrderOrderReportsItem {
        fn from(value: &OcoOrderOrderReportsItem) -> Self {
            value.clone()
        }
    }
    ///OcoOrderOrdersItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "clientOrderId",
    ///    "orderId",
    ///    "symbol"
    ///  ],
    ///  "properties": {
    ///    "clientOrderId": {
    ///      "type": "string"
    ///    },
    ///    "orderId": {
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "symbol": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct OcoOrderOrdersItem {
        #[serde(rename = "clientOrderId")]
        pub client_order_id: String,
        #[serde(rename = "orderId")]
        pub order_id: i64,
        pub symbol: String,
    }
    impl From<&OcoOrderOrdersItem> for OcoOrderOrdersItem {
        fn from(value: &OcoOrderOrdersItem) -> Self {
            value.clone()
        }
    }
    ///OpenOrderListResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "contingencyType",
    ///    "listClientOrderId",
    ///    "listOrderStatus",
    ///    "listStatusType",
    ///    "orderListId",
    ///    "orders",
    ///    "symbol",
    ///    "transactionTime"
    ///  ],
    ///  "properties": {
    ///    "contingencyType": {
    ///      "examples": [
    ///        "OCO"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "listClientOrderId": {
    ///      "examples": [
    ///        "wuB13fmulKj3YjdqWEcsnp"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "listOrderStatus": {
    ///      "examples": [
    ///        "EXECUTING"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "listStatusType": {
    ///      "examples": [
    ///        "EXEC_STARTED"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "orderListId": {
    ///      "examples": [
    ///        31
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "orders": {
    ///      "type": "array",
    ///      "items": {
    ///        "examples": [
    ///          [
    ///            {
    ///              "clientOrderId": "r3EH2N76dHfLoSZWIUw1bT",
    ///              "orderId": 4,
    ///              "symbol": "LTCBTC"
    ///            },
    ///            {
    ///              "clientOrderId": "Cv1SnyPD3qhqpbjpYEHbd2",
    ///              "orderId": 5,
    ///              "symbol": "LTCBTC"
    ///            }
    ///          ]
    ///        ],
    ///        "type": "object",
    ///        "required": [
    ///          "clientOrderId",
    ///          "orderId",
    ///          "symbol"
    ///        ],
    ///        "properties": {
    ///          "clientOrderId": {
    ///            "type": "string"
    ///          },
    ///          "orderId": {
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "symbol": {
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "symbol": {
    ///      "examples": [
    ///        "LTCBTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "transactionTime": {
    ///      "examples": [
    ///        1565246080644
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct OpenOrderListResponseItem {
        #[serde(rename = "contingencyType")]
        pub contingency_type: String,
        #[serde(rename = "listClientOrderId")]
        pub list_client_order_id: String,
        #[serde(rename = "listOrderStatus")]
        pub list_order_status: String,
        #[serde(rename = "listStatusType")]
        pub list_status_type: String,
        #[serde(rename = "orderListId")]
        pub order_list_id: i64,
        pub orders: Vec<OpenOrderListResponseItemOrdersItem>,
        pub symbol: String,
        #[serde(rename = "transactionTime")]
        pub transaction_time: i64,
    }
    impl From<&OpenOrderListResponseItem> for OpenOrderListResponseItem {
        fn from(value: &OpenOrderListResponseItem) -> Self {
            value.clone()
        }
    }
    ///OpenOrderListResponseItemOrdersItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    [
    ///      {
    ///        "clientOrderId": "r3EH2N76dHfLoSZWIUw1bT",
    ///        "orderId": 4,
    ///        "symbol": "LTCBTC"
    ///      },
    ///      {
    ///        "clientOrderId": "Cv1SnyPD3qhqpbjpYEHbd2",
    ///        "orderId": 5,
    ///        "symbol": "LTCBTC"
    ///      }
    ///    ]
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "clientOrderId",
    ///    "orderId",
    ///    "symbol"
    ///  ],
    ///  "properties": {
    ///    "clientOrderId": {
    ///      "type": "string"
    ///    },
    ///    "orderId": {
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "symbol": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct OpenOrderListResponseItemOrdersItem {
        #[serde(rename = "clientOrderId")]
        pub client_order_id: String,
        #[serde(rename = "orderId")]
        pub order_id: i64,
        pub symbol: String,
    }
    impl From<&OpenOrderListResponseItemOrdersItem>
    for OpenOrderListResponseItemOrdersItem {
        fn from(value: &OpenOrderListResponseItemOrdersItem) -> Self {
            value.clone()
        }
    }
    ///Order
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "clientOrderId",
    ///    "cummulativeQuoteQty",
    ///    "executedQty",
    ///    "orderId",
    ///    "orderListId",
    ///    "origClientOrderId",
    ///    "origQty",
    ///    "price",
    ///    "selfTradePreventionMode",
    ///    "side",
    ///    "status",
    ///    "symbol",
    ///    "timeInForce",
    ///    "transactTime",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "clientOrderId": {
    ///      "examples": [
    ///        "6gCrw2kRUAF9CvJDGP16IP"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "cummulativeQuoteQty": {
    ///      "examples": [
    ///        "10.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "executedQty": {
    ///      "examples": [
    ///        "10.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "orderId": {
    ///      "examples": [
    ///        28
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "orderListId": {
    ///      "description": "Unless OCO, value will be -1",
    ///      "examples": [
    ///        -1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "origClientOrderId": {
    ///      "examples": [
    ///        "msXkySR3u5uYwpvRMFsi3u"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "origQty": {
    ///      "examples": [
    ///        "10.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "price": {
    ///      "examples": [
    ///        "1.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "selfTradePreventionMode": {
    ///      "examples": [
    ///        "NONE"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "side": {
    ///      "examples": [
    ///        "SELL"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "examples": [
    ///        "FILLED"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "symbol": {
    ///      "examples": [
    ///        "BNBBTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "timeInForce": {
    ///      "examples": [
    ///        "GTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "transactTime": {
    ///      "examples": [
    ///        1507725176595
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "type": {
    ///      "examples": [
    ///        "LIMIT"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct Order {
        #[serde(rename = "clientOrderId")]
        pub client_order_id: String,
        #[serde(rename = "cummulativeQuoteQty")]
        pub cummulative_quote_qty: String,
        #[serde(rename = "executedQty")]
        pub executed_qty: String,
        #[serde(rename = "orderId")]
        pub order_id: i64,
        ///Unless OCO, value will be -1
        #[serde(rename = "orderListId")]
        pub order_list_id: i64,
        #[serde(rename = "origClientOrderId")]
        pub orig_client_order_id: String,
        #[serde(rename = "origQty")]
        pub orig_qty: String,
        pub price: String,
        #[serde(rename = "selfTradePreventionMode")]
        pub self_trade_prevention_mode: String,
        pub side: String,
        pub status: String,
        pub symbol: String,
        #[serde(rename = "timeInForce")]
        pub time_in_force: String,
        #[serde(rename = "transactTime")]
        pub transact_time: i64,
        #[serde(rename = "type")]
        pub type_: String,
    }
    impl From<&Order> for Order {
        fn from(value: &Order) -> Self {
            value.clone()
        }
    }
    ///OrderDetails
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "clientOrderId",
    ///    "cummulativeQuoteQty",
    ///    "executedQty",
    ///    "icebergQty",
    ///    "isWorking",
    ///    "orderId",
    ///    "orderListId",
    ///    "origQty",
    ///    "origQuoteOrderQty",
    ///    "price",
    ///    "selfTradePreventionMode",
    ///    "side",
    ///    "status",
    ///    "stopPrice",
    ///    "symbol",
    ///    "time",
    ///    "timeInForce",
    ///    "type",
    ///    "updateTime",
    ///    "workingTime"
    ///  ],
    ///  "properties": {
    ///    "clientOrderId": {
    ///      "examples": [
    ///        "myOrder1"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "cummulativeQuoteQty": {
    ///      "examples": [
    ///        "0.0"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "executedQty": {
    ///      "examples": [
    ///        "0.0"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "icebergQty": {
    ///      "examples": [
    ///        "0.0"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "isWorking": {
    ///      "type": "boolean"
    ///    },
    ///    "orderId": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "orderListId": {
    ///      "description": "Unless OCO, value will be -1",
    ///      "examples": [
    ///        -1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "origQty": {
    ///      "examples": [
    ///        "1.0"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "origQuoteOrderQty": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "preventedMatchId": {
    ///      "examples": [
    ///        0
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "preventedQuantity": {
    ///      "examples": [
    ///        "1.200000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "price": {
    ///      "examples": [
    ///        "0.1"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "selfTradePreventionMode": {
    ///      "examples": [
    ///        "NONE"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "side": {
    ///      "examples": [
    ///        "BUY"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "examples": [
    ///        "NEW"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "stopPrice": {
    ///      "examples": [
    ///        "0.0"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "symbol": {
    ///      "examples": [
    ///        "LTCBTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "time": {
    ///      "examples": [
    ///        1499827319559
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "timeInForce": {
    ///      "examples": [
    ///        "GTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "examples": [
    ///        "LIMIT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "updateTime": {
    ///      "examples": [
    ///        1499827319559
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "workingTime": {
    ///      "examples": [
    ///        1499827319559
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct OrderDetails {
        #[serde(rename = "clientOrderId")]
        pub client_order_id: String,
        #[serde(rename = "cummulativeQuoteQty")]
        pub cummulative_quote_qty: String,
        #[serde(rename = "executedQty")]
        pub executed_qty: String,
        #[serde(rename = "icebergQty")]
        pub iceberg_qty: String,
        #[serde(rename = "isWorking")]
        pub is_working: bool,
        #[serde(rename = "orderId")]
        pub order_id: i64,
        ///Unless OCO, value will be -1
        #[serde(rename = "orderListId")]
        pub order_list_id: i64,
        #[serde(rename = "origQty")]
        pub orig_qty: String,
        #[serde(rename = "origQuoteOrderQty")]
        pub orig_quote_order_qty: String,
        #[serde(
            rename = "preventedMatchId",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub prevented_match_id: Option<i64>,
        #[serde(
            rename = "preventedQuantity",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub prevented_quantity: Option<String>,
        pub price: String,
        #[serde(rename = "selfTradePreventionMode")]
        pub self_trade_prevention_mode: String,
        pub side: String,
        pub status: String,
        #[serde(rename = "stopPrice")]
        pub stop_price: String,
        pub symbol: String,
        pub time: i64,
        #[serde(rename = "timeInForce")]
        pub time_in_force: String,
        #[serde(rename = "type")]
        pub type_: String,
        #[serde(rename = "updateTime")]
        pub update_time: i64,
        #[serde(rename = "workingTime")]
        pub working_time: i64,
    }
    impl From<&OrderDetails> for OrderDetails {
        fn from(value: &OrderDetails) -> Self {
            value.clone()
        }
    }
    ///OrderListResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "contingencyType",
    ///    "listClientOrderId",
    ///    "listOrderStatus",
    ///    "listStatusType",
    ///    "orderListId",
    ///    "orders",
    ///    "symbol",
    ///    "transactionTime"
    ///  ],
    ///  "properties": {
    ///    "contingencyType": {
    ///      "examples": [
    ///        "OCO"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "listClientOrderId": {
    ///      "examples": [
    ///        "h2USkA5YQpaXHPIrkd96xE"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "listOrderStatus": {
    ///      "examples": [
    ///        "EXECUTING"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "listStatusType": {
    ///      "examples": [
    ///        "EXEC_STARTED"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "orderListId": {
    ///      "examples": [
    ///        27
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "orders": {
    ///      "type": "array",
    ///      "items": {
    ///        "examples": [
    ///          [
    ///            {
    ///              "clientOrderId": "qD1gy3kc3Gx0rihm9Y3xwS",
    ///              "orderId": 4,
    ///              "symbol": "LTCBTC"
    ///            },
    ///            {
    ///              "clientOrderId": "ARzZ9I00CPM8i3NhmU9Ega",
    ///              "orderId": 5,
    ///              "symbol": "LTCBTC"
    ///            }
    ///          ]
    ///        ],
    ///        "type": "object",
    ///        "required": [
    ///          "clientOrderId",
    ///          "orderId",
    ///          "symbol"
    ///        ],
    ///        "properties": {
    ///          "clientOrderId": {
    ///            "type": "string"
    ///          },
    ///          "orderId": {
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "symbol": {
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "symbol": {
    ///      "examples": [
    ///        "LTCBTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "transactionTime": {
    ///      "examples": [
    ///        1565245656253
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct OrderListResponse {
        #[serde(rename = "contingencyType")]
        pub contingency_type: String,
        #[serde(rename = "listClientOrderId")]
        pub list_client_order_id: String,
        #[serde(rename = "listOrderStatus")]
        pub list_order_status: String,
        #[serde(rename = "listStatusType")]
        pub list_status_type: String,
        #[serde(rename = "orderListId")]
        pub order_list_id: i64,
        pub orders: Vec<OrderListResponseOrdersItem>,
        pub symbol: String,
        #[serde(rename = "transactionTime")]
        pub transaction_time: i64,
    }
    impl From<&OrderListResponse> for OrderListResponse {
        fn from(value: &OrderListResponse) -> Self {
            value.clone()
        }
    }
    ///OrderListResponseOrdersItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    [
    ///      {
    ///        "clientOrderId": "qD1gy3kc3Gx0rihm9Y3xwS",
    ///        "orderId": 4,
    ///        "symbol": "LTCBTC"
    ///      },
    ///      {
    ///        "clientOrderId": "ARzZ9I00CPM8i3NhmU9Ega",
    ///        "orderId": 5,
    ///        "symbol": "LTCBTC"
    ///      }
    ///    ]
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "clientOrderId",
    ///    "orderId",
    ///    "symbol"
    ///  ],
    ///  "properties": {
    ///    "clientOrderId": {
    ///      "type": "string"
    ///    },
    ///    "orderId": {
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "symbol": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct OrderListResponseOrdersItem {
        #[serde(rename = "clientOrderId")]
        pub client_order_id: String,
        #[serde(rename = "orderId")]
        pub order_id: i64,
        pub symbol: String,
    }
    impl From<&OrderListResponseOrdersItem> for OrderListResponseOrdersItem {
        fn from(value: &OrderListResponseOrdersItem) -> Self {
            value.clone()
        }
    }
    ///OrderResponseAck
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "clientOrderId",
    ///    "orderId",
    ///    "orderListId",
    ///    "symbol",
    ///    "transactTime"
    ///  ],
    ///  "properties": {
    ///    "clientOrderId": {
    ///      "examples": [
    ///        "6gCrw2kRUAF9CvJDGP16IP"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "orderId": {
    ///      "examples": [
    ///        28
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "orderListId": {
    ///      "examples": [
    ///        -1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "symbol": {
    ///      "examples": [
    ///        "BTCUSDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "transactTime": {
    ///      "examples": [
    ///        1507725176595
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct OrderResponseAck {
        #[serde(rename = "clientOrderId")]
        pub client_order_id: String,
        #[serde(rename = "orderId")]
        pub order_id: i64,
        #[serde(rename = "orderListId")]
        pub order_list_id: i64,
        pub symbol: String,
        #[serde(rename = "transactTime")]
        pub transact_time: i64,
    }
    impl From<&OrderResponseAck> for OrderResponseAck {
        fn from(value: &OrderResponseAck) -> Self {
            value.clone()
        }
    }
    ///OrderResponseFull
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "clientOrderId",
    ///    "cummulativeQuoteQty",
    ///    "executedQty",
    ///    "fills",
    ///    "orderId",
    ///    "orderListId",
    ///    "origQty",
    ///    "price",
    ///    "selfTradePreventionMode",
    ///    "side",
    ///    "status",
    ///    "symbol",
    ///    "timeInForce",
    ///    "transactTime",
    ///    "type",
    ///    "workingTime"
    ///  ],
    ///  "properties": {
    ///    "clientOrderId": {
    ///      "examples": [
    ///        "6gCrw2kRUAF9CvJDGP16IP"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "cummulativeQuoteQty": {
    ///      "examples": [
    ///        "10.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "executedQty": {
    ///      "examples": [
    ///        "10.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "fills": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "commission",
    ///          "commissionAsset",
    ///          "price",
    ///          "qty"
    ///        ],
    ///        "properties": {
    ///          "commission": {
    ///            "examples": [
    ///              "4.00000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "commissionAsset": {
    ///            "examples": [
    ///              "USDT"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "price": {
    ///            "examples": [
    ///              "4000.00000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "qty": {
    ///            "examples": [
    ///              "1.00000000"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "orderId": {
    ///      "examples": [
    ///        28
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "orderListId": {
    ///      "examples": [
    ///        -1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "origQty": {
    ///      "examples": [
    ///        "10.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "price": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "selfTradePreventionMode": {
    ///      "examples": [
    ///        "NONE"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "side": {
    ///      "examples": [
    ///        "SELL"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "examples": [
    ///        "FILLED"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "strategyId": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "strategyType": {
    ///      "examples": [
    ///        1000000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "symbol": {
    ///      "examples": [
    ///        "BTCUSDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "timeInForce": {
    ///      "examples": [
    ///        "GTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "transactTime": {
    ///      "examples": [
    ///        1507725176595
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "type": {
    ///      "examples": [
    ///        "MARKET"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "workingTime": {
    ///      "examples": [
    ///        1507725176595
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct OrderResponseFull {
        #[serde(rename = "clientOrderId")]
        pub client_order_id: String,
        #[serde(rename = "cummulativeQuoteQty")]
        pub cummulative_quote_qty: String,
        #[serde(rename = "executedQty")]
        pub executed_qty: String,
        pub fills: Vec<OrderResponseFullFillsItem>,
        #[serde(rename = "orderId")]
        pub order_id: i64,
        #[serde(rename = "orderListId")]
        pub order_list_id: i64,
        #[serde(rename = "origQty")]
        pub orig_qty: String,
        pub price: String,
        #[serde(rename = "selfTradePreventionMode")]
        pub self_trade_prevention_mode: String,
        pub side: String,
        pub status: String,
        #[serde(rename = "strategyId", default, skip_serializing_if = "Option::is_none")]
        pub strategy_id: Option<i64>,
        #[serde(
            rename = "strategyType",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub strategy_type: Option<i64>,
        pub symbol: String,
        #[serde(rename = "timeInForce")]
        pub time_in_force: String,
        #[serde(rename = "transactTime")]
        pub transact_time: i64,
        #[serde(rename = "type")]
        pub type_: String,
        #[serde(rename = "workingTime")]
        pub working_time: i64,
    }
    impl From<&OrderResponseFull> for OrderResponseFull {
        fn from(value: &OrderResponseFull) -> Self {
            value.clone()
        }
    }
    ///OrderResponseFullFillsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "commission",
    ///    "commissionAsset",
    ///    "price",
    ///    "qty"
    ///  ],
    ///  "properties": {
    ///    "commission": {
    ///      "examples": [
    ///        "4.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "commissionAsset": {
    ///      "examples": [
    ///        "USDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "price": {
    ///      "examples": [
    ///        "4000.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "qty": {
    ///      "examples": [
    ///        "1.00000000"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct OrderResponseFullFillsItem {
        pub commission: String,
        #[serde(rename = "commissionAsset")]
        pub commission_asset: String,
        pub price: String,
        pub qty: String,
    }
    impl From<&OrderResponseFullFillsItem> for OrderResponseFullFillsItem {
        fn from(value: &OrderResponseFullFillsItem) -> Self {
            value.clone()
        }
    }
    ///OrderResponseResult
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "clientOrderId",
    ///    "cummulativeQuoteQty",
    ///    "executedQty",
    ///    "orderId",
    ///    "orderListId",
    ///    "origQty",
    ///    "price",
    ///    "selfTradePreventionMode",
    ///    "side",
    ///    "status",
    ///    "symbol",
    ///    "timeInForce",
    ///    "transactTime",
    ///    "type",
    ///    "workingTime"
    ///  ],
    ///  "properties": {
    ///    "clientOrderId": {
    ///      "examples": [
    ///        "6gCrw2kRUAF9CvJDGP16IP"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "cummulativeQuoteQty": {
    ///      "examples": [
    ///        "10.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "executedQty": {
    ///      "examples": [
    ///        "10.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "orderId": {
    ///      "examples": [
    ///        28
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "orderListId": {
    ///      "examples": [
    ///        -1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "origQty": {
    ///      "examples": [
    ///        "10.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "price": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "selfTradePreventionMode": {
    ///      "examples": [
    ///        "NONE"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "side": {
    ///      "examples": [
    ///        "SELL"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "examples": [
    ///        "FILLED"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "strategyId": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "strategyType": {
    ///      "examples": [
    ///        1000000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "symbol": {
    ///      "examples": [
    ///        "BTCUSDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "timeInForce": {
    ///      "examples": [
    ///        "GTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "transactTime": {
    ///      "examples": [
    ///        1507725176595
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "type": {
    ///      "examples": [
    ///        "MARKET"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "workingTime": {
    ///      "examples": [
    ///        1507725176595
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct OrderResponseResult {
        #[serde(rename = "clientOrderId")]
        pub client_order_id: String,
        #[serde(rename = "cummulativeQuoteQty")]
        pub cummulative_quote_qty: String,
        #[serde(rename = "executedQty")]
        pub executed_qty: String,
        #[serde(rename = "orderId")]
        pub order_id: i64,
        #[serde(rename = "orderListId")]
        pub order_list_id: i64,
        #[serde(rename = "origQty")]
        pub orig_qty: String,
        pub price: String,
        #[serde(rename = "selfTradePreventionMode")]
        pub self_trade_prevention_mode: String,
        pub side: String,
        pub status: String,
        #[serde(rename = "strategyId", default, skip_serializing_if = "Option::is_none")]
        pub strategy_id: Option<i64>,
        #[serde(
            rename = "strategyType",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub strategy_type: Option<i64>,
        pub symbol: String,
        #[serde(rename = "timeInForce")]
        pub time_in_force: String,
        #[serde(rename = "transactTime")]
        pub transact_time: i64,
        #[serde(rename = "type")]
        pub type_: String,
        #[serde(rename = "workingTime")]
        pub working_time: i64,
    }
    impl From<&OrderResponseResult> for OrderResponseResult {
        fn from(value: &OrderResponseResult) -> Self {
            value.clone()
        }
    }
    ///OrderTestNewOrderRespType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "ACK",
    ///    "RESULT",
    ///    "FULL"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum OrderTestNewOrderRespType {
        #[serde(rename = "ACK")]
        Ack,
        #[serde(rename = "RESULT")]
        Result,
        #[serde(rename = "FULL")]
        Full,
    }
    impl From<&OrderTestNewOrderRespType> for OrderTestNewOrderRespType {
        fn from(value: &OrderTestNewOrderRespType) -> Self {
            value.clone()
        }
    }
    impl ToString for OrderTestNewOrderRespType {
        fn to_string(&self) -> String {
            match *self {
                Self::Ack => "ACK".to_string(),
                Self::Result => "RESULT".to_string(),
                Self::Full => "FULL".to_string(),
            }
        }
    }
    impl std::str::FromStr for OrderTestNewOrderRespType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "ACK" => Ok(Self::Ack),
                "RESULT" => Ok(Self::Result),
                "FULL" => Ok(Self::Full),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for OrderTestNewOrderRespType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for OrderTestNewOrderRespType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for OrderTestNewOrderRespType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///OrderTestSide
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "SELL"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "SELL",
    ///    "BUY"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum OrderTestSide {
        #[serde(rename = "SELL")]
        Sell,
        #[serde(rename = "BUY")]
        Buy,
    }
    impl From<&OrderTestSide> for OrderTestSide {
        fn from(value: &OrderTestSide) -> Self {
            value.clone()
        }
    }
    impl ToString for OrderTestSide {
        fn to_string(&self) -> String {
            match *self {
                Self::Sell => "SELL".to_string(),
                Self::Buy => "BUY".to_string(),
            }
        }
    }
    impl std::str::FromStr for OrderTestSide {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "SELL" => Ok(Self::Sell),
                "BUY" => Ok(Self::Buy),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for OrderTestSide {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for OrderTestSide {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for OrderTestSide {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///OrderTestTimeInForce
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "GTC"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "GTC",
    ///    "IOC",
    ///    "FOK"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum OrderTestTimeInForce {
        #[serde(rename = "GTC")]
        Gtc,
        #[serde(rename = "IOC")]
        Ioc,
        #[serde(rename = "FOK")]
        Fok,
    }
    impl From<&OrderTestTimeInForce> for OrderTestTimeInForce {
        fn from(value: &OrderTestTimeInForce) -> Self {
            value.clone()
        }
    }
    impl ToString for OrderTestTimeInForce {
        fn to_string(&self) -> String {
            match *self {
                Self::Gtc => "GTC".to_string(),
                Self::Ioc => "IOC".to_string(),
                Self::Fok => "FOK".to_string(),
            }
        }
    }
    impl std::str::FromStr for OrderTestTimeInForce {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "GTC" => Ok(Self::Gtc),
                "IOC" => Ok(Self::Ioc),
                "FOK" => Ok(Self::Fok),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for OrderTestTimeInForce {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for OrderTestTimeInForce {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for OrderTestTimeInForce {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///OrderTestType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "LIMIT"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "LIMIT",
    ///    "MARKET",
    ///    "STOP_LOSS",
    ///    "STOP_LOSS_LIMIT",
    ///    "TAKE_PROFIT",
    ///    "TAKE_PROFIT_LIMIT",
    ///    "LIMIT_MAKER"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum OrderTestType {
        #[serde(rename = "LIMIT")]
        Limit,
        #[serde(rename = "MARKET")]
        Market,
        #[serde(rename = "STOP_LOSS")]
        StopLoss,
        #[serde(rename = "STOP_LOSS_LIMIT")]
        StopLossLimit,
        #[serde(rename = "TAKE_PROFIT")]
        TakeProfit,
        #[serde(rename = "TAKE_PROFIT_LIMIT")]
        TakeProfitLimit,
        #[serde(rename = "LIMIT_MAKER")]
        LimitMaker,
    }
    impl From<&OrderTestType> for OrderTestType {
        fn from(value: &OrderTestType) -> Self {
            value.clone()
        }
    }
    impl ToString for OrderTestType {
        fn to_string(&self) -> String {
            match *self {
                Self::Limit => "LIMIT".to_string(),
                Self::Market => "MARKET".to_string(),
                Self::StopLoss => "STOP_LOSS".to_string(),
                Self::StopLossLimit => "STOP_LOSS_LIMIT".to_string(),
                Self::TakeProfit => "TAKE_PROFIT".to_string(),
                Self::TakeProfitLimit => "TAKE_PROFIT_LIMIT".to_string(),
                Self::LimitMaker => "LIMIT_MAKER".to_string(),
            }
        }
    }
    impl std::str::FromStr for OrderTestType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "LIMIT" => Ok(Self::Limit),
                "MARKET" => Ok(Self::Market),
                "STOP_LOSS" => Ok(Self::StopLoss),
                "STOP_LOSS_LIMIT" => Ok(Self::StopLossLimit),
                "TAKE_PROFIT" => Ok(Self::TakeProfit),
                "TAKE_PROFIT_LIMIT" => Ok(Self::TakeProfitLimit),
                "LIMIT_MAKER" => Ok(Self::LimitMaker),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for OrderTestType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for OrderTestType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for OrderTestType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///PayTransactionsResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "code",
    ///    "data",
    ///    "message",
    ///    "success"
    ///  ],
    ///  "properties": {
    ///    "code": {
    ///      "examples": [
    ///        "000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "data": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "amount",
    ///          "currency",
    ///          "fundsDetail",
    ///          "orderType",
    ///          "payerInfo",
    ///          "receiverInfo",
    ///          "transactionId",
    ///          "transactionTime",
    ///          "walletType",
    ///          "walletTypes"
    ///        ],
    ///        "properties": {
    ///          "amount": {
    ///            "description": "order amount(up to 8 decimal places), positive is income, negative is expenditure",
    ///            "examples": [
    ///              "23.72469206"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "currency": {
    ///            "examples": [
    ///              "BNB"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "fundsDetail": {
    ///            "type": "array",
    ///            "items": {
    ///              "examples": [
    ///                [
    ///                  {
    ///                    "amount": "1.2",
    ///                    "currency": "USDT"
    ///                  },
    ///                  {
    ///                    "amount": "0.0001",
    ///                    "currency": "ETH"
    ///                  }
    ///                ]
    ///              ],
    ///              "type": "object",
    ///              "required": [
    ///                "amount",
    ///                "currency"
    ///              ],
    ///              "properties": {
    ///                "amount": {
    ///                  "type": "string"
    ///                },
    ///                "currency": {
    ///                  "type": "string"
    ///                }
    ///              }
    ///            }
    ///          },
    ///          "orderType": {
    ///            "description": "EnumPAY(C2B Merchant Acquiring Payment), PAY_REFUND(C2B Merchant Acquiring Payment,refund), C2C(C2C Transfer Payment),CRYPTO_BOX(Crypto box), CRYPTO_BOX_RF(Crypto Box, refund), C2C_HOLDING(Transfer to new Binance user), C2C_HOLDING_RF(Transfer to new Binance user,refund), PAYOUT(B2C Disbursement Payment)",
    ///            "examples": [
    ///              "C2C"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "payerInfo": {
    ///            "type": "object",
    ///            "required": [
    ///              "accountId",
    ///              "binanceId",
    ///              "name",
    ///              "type"
    ///            ],
    ///            "properties": {
    ///              "accountId": {
    ///                "examples": [
    ///                  "67736251"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "binanceId": {
    ///                "examples": [
    ///                  "12345678"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "name": {
    ///                "examples": [
    ///                  "Jack"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "type": {
    ///                "examples": [
    ///                  "USER"
    ///                ],
    ///                "type": "string"
    ///              }
    ///            }
    ///          },
    ///          "receiverInfo": {
    ///            "type": "object",
    ///            "required": [
    ///              "accountId",
    ///              "binanceId",
    ///              "countryCode",
    ///              "email",
    ///              "mobileCode",
    ///              "name",
    ///              "phoneNumber",
    ///              "type"
    ///            ],
    ///            "properties": {
    ///              "accountId": {
    ///                "examples": [
    ///                  "21326891"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "binanceId": {
    ///                "examples": [
    ///                  "34355667"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "countryCode": {
    ///                "examples": [
    ///                  "1"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "email": {
    ///                "examples": [
    ///                  "alan@test.com"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "extend": {
    ///                "type": "array",
    ///                "items": {
    ///                  "type": "object",
    ///                  "required": [
    ///                    "cardNumber",
    ///                    "digitalWalletId",
    ///                    "institutionName"
    ///                  ],
    ///                  "properties": {
    ///                    "cardNumber": {
    ///                      "type": "string"
    ///                    },
    ///                    "digitalWalletId": {
    ///                      "type": "string"
    ///                    },
    ///                    "institutionName": {
    ///                      "type": "string"
    ///                    }
    ///                  }
    ///                }
    ///              },
    ///              "mobileCode": {
    ///                "examples": [
    ///                  "US"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "name": {
    ///                "examples": [
    ///                  "Alan"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "phoneNumber": {
    ///                "examples": [
    ///                  "8057651210"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "type": {
    ///                "examples": [
    ///                  "MERCHANT"
    ///                ],
    ///                "type": "string"
    ///              }
    ///            }
    ///          },
    ///          "transactionId": {
    ///            "examples": [
    ///              "M_P_71505104267788288"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "transactionTime": {
    ///            "examples": [
    ///              1610090460133
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "walletType": {
    ///            "examples": [
    ///              1
    ///            ],
    ///            "type": "integer"
    ///          },
    ///          "walletTypes": {
    ///            "type": "array",
    ///            "items": {
    ///              "type": "integer"
    ///            }
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "message": {
    ///      "examples": [
    ///        "success"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "success": {
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct PayTransactionsResponse {
        pub code: String,
        pub data: Vec<PayTransactionsResponseDataItem>,
        pub message: String,
        pub success: bool,
    }
    impl From<&PayTransactionsResponse> for PayTransactionsResponse {
        fn from(value: &PayTransactionsResponse) -> Self {
            value.clone()
        }
    }
    ///PayTransactionsResponseDataItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "currency",
    ///    "fundsDetail",
    ///    "orderType",
    ///    "payerInfo",
    ///    "receiverInfo",
    ///    "transactionId",
    ///    "transactionTime",
    ///    "walletType",
    ///    "walletTypes"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "description": "order amount(up to 8 decimal places), positive is income, negative is expenditure",
    ///      "examples": [
    ///        "23.72469206"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "currency": {
    ///      "examples": [
    ///        "BNB"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "fundsDetail": {
    ///      "type": "array",
    ///      "items": {
    ///        "examples": [
    ///          [
    ///            {
    ///              "amount": "1.2",
    ///              "currency": "USDT"
    ///            },
    ///            {
    ///              "amount": "0.0001",
    ///              "currency": "ETH"
    ///            }
    ///          ]
    ///        ],
    ///        "type": "object",
    ///        "required": [
    ///          "amount",
    ///          "currency"
    ///        ],
    ///        "properties": {
    ///          "amount": {
    ///            "type": "string"
    ///          },
    ///          "currency": {
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "orderType": {
    ///      "description": "EnumPAY(C2B Merchant Acquiring Payment), PAY_REFUND(C2B Merchant Acquiring Payment,refund), C2C(C2C Transfer Payment),CRYPTO_BOX(Crypto box), CRYPTO_BOX_RF(Crypto Box, refund), C2C_HOLDING(Transfer to new Binance user), C2C_HOLDING_RF(Transfer to new Binance user,refund), PAYOUT(B2C Disbursement Payment)",
    ///      "examples": [
    ///        "C2C"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "payerInfo": {
    ///      "type": "object",
    ///      "required": [
    ///        "accountId",
    ///        "binanceId",
    ///        "name",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "accountId": {
    ///          "examples": [
    ///            "67736251"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "binanceId": {
    ///          "examples": [
    ///            "12345678"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "name": {
    ///          "examples": [
    ///            "Jack"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "type": {
    ///          "examples": [
    ///            "USER"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "receiverInfo": {
    ///      "type": "object",
    ///      "required": [
    ///        "accountId",
    ///        "binanceId",
    ///        "countryCode",
    ///        "email",
    ///        "mobileCode",
    ///        "name",
    ///        "phoneNumber",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "accountId": {
    ///          "examples": [
    ///            "21326891"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "binanceId": {
    ///          "examples": [
    ///            "34355667"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "countryCode": {
    ///          "examples": [
    ///            "1"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "email": {
    ///          "examples": [
    ///            "alan@test.com"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "extend": {
    ///          "type": "array",
    ///          "items": {
    ///            "type": "object",
    ///            "required": [
    ///              "cardNumber",
    ///              "digitalWalletId",
    ///              "institutionName"
    ///            ],
    ///            "properties": {
    ///              "cardNumber": {
    ///                "type": "string"
    ///              },
    ///              "digitalWalletId": {
    ///                "type": "string"
    ///              },
    ///              "institutionName": {
    ///                "type": "string"
    ///              }
    ///            }
    ///          }
    ///        },
    ///        "mobileCode": {
    ///          "examples": [
    ///            "US"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "name": {
    ///          "examples": [
    ///            "Alan"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "phoneNumber": {
    ///          "examples": [
    ///            "8057651210"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "type": {
    ///          "examples": [
    ///            "MERCHANT"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "transactionId": {
    ///      "examples": [
    ///        "M_P_71505104267788288"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "transactionTime": {
    ///      "examples": [
    ///        1610090460133
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "walletType": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "walletTypes": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "integer"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct PayTransactionsResponseDataItem {
        ///order amount(up to 8 decimal places), positive is income, negative is expenditure
        pub amount: String,
        pub currency: String,
        #[serde(rename = "fundsDetail")]
        pub funds_detail: Vec<PayTransactionsResponseDataItemFundsDetailItem>,
        ///EnumPAY(C2B Merchant Acquiring Payment), PAY_REFUND(C2B Merchant Acquiring Payment,refund), C2C(C2C Transfer Payment),CRYPTO_BOX(Crypto box), CRYPTO_BOX_RF(Crypto Box, refund), C2C_HOLDING(Transfer to new Binance user), C2C_HOLDING_RF(Transfer to new Binance user,refund), PAYOUT(B2C Disbursement Payment)
        #[serde(rename = "orderType")]
        pub order_type: String,
        #[serde(rename = "payerInfo")]
        pub payer_info: PayTransactionsResponseDataItemPayerInfo,
        #[serde(rename = "receiverInfo")]
        pub receiver_info: PayTransactionsResponseDataItemReceiverInfo,
        #[serde(rename = "transactionId")]
        pub transaction_id: String,
        #[serde(rename = "transactionTime")]
        pub transaction_time: i64,
        #[serde(rename = "walletType")]
        pub wallet_type: i64,
        #[serde(rename = "walletTypes")]
        pub wallet_types: Vec<i64>,
    }
    impl From<&PayTransactionsResponseDataItem> for PayTransactionsResponseDataItem {
        fn from(value: &PayTransactionsResponseDataItem) -> Self {
            value.clone()
        }
    }
    ///PayTransactionsResponseDataItemFundsDetailItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    [
    ///      {
    ///        "amount": "1.2",
    ///        "currency": "USDT"
    ///      },
    ///      {
    ///        "amount": "0.0001",
    ///        "currency": "ETH"
    ///      }
    ///    ]
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "currency"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "type": "string"
    ///    },
    ///    "currency": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct PayTransactionsResponseDataItemFundsDetailItem {
        pub amount: String,
        pub currency: String,
    }
    impl From<&PayTransactionsResponseDataItemFundsDetailItem>
    for PayTransactionsResponseDataItemFundsDetailItem {
        fn from(value: &PayTransactionsResponseDataItemFundsDetailItem) -> Self {
            value.clone()
        }
    }
    ///PayTransactionsResponseDataItemPayerInfo
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "accountId",
    ///    "binanceId",
    ///    "name",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "accountId": {
    ///      "examples": [
    ///        "67736251"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "binanceId": {
    ///      "examples": [
    ///        "12345678"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "examples": [
    ///        "Jack"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "examples": [
    ///        "USER"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct PayTransactionsResponseDataItemPayerInfo {
        #[serde(rename = "accountId")]
        pub account_id: String,
        #[serde(rename = "binanceId")]
        pub binance_id: String,
        pub name: String,
        #[serde(rename = "type")]
        pub type_: String,
    }
    impl From<&PayTransactionsResponseDataItemPayerInfo>
    for PayTransactionsResponseDataItemPayerInfo {
        fn from(value: &PayTransactionsResponseDataItemPayerInfo) -> Self {
            value.clone()
        }
    }
    ///PayTransactionsResponseDataItemReceiverInfo
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "accountId",
    ///    "binanceId",
    ///    "countryCode",
    ///    "email",
    ///    "mobileCode",
    ///    "name",
    ///    "phoneNumber",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "accountId": {
    ///      "examples": [
    ///        "21326891"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "binanceId": {
    ///      "examples": [
    ///        "34355667"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "countryCode": {
    ///      "examples": [
    ///        "1"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "email": {
    ///      "examples": [
    ///        "alan@test.com"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "extend": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "cardNumber",
    ///          "digitalWalletId",
    ///          "institutionName"
    ///        ],
    ///        "properties": {
    ///          "cardNumber": {
    ///            "type": "string"
    ///          },
    ///          "digitalWalletId": {
    ///            "type": "string"
    ///          },
    ///          "institutionName": {
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "mobileCode": {
    ///      "examples": [
    ///        "US"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "examples": [
    ///        "Alan"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "phoneNumber": {
    ///      "examples": [
    ///        "8057651210"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "examples": [
    ///        "MERCHANT"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct PayTransactionsResponseDataItemReceiverInfo {
        #[serde(rename = "accountId")]
        pub account_id: String,
        #[serde(rename = "binanceId")]
        pub binance_id: String,
        #[serde(rename = "countryCode")]
        pub country_code: String,
        pub email: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub extend: Vec<PayTransactionsResponseDataItemReceiverInfoExtendItem>,
        #[serde(rename = "mobileCode")]
        pub mobile_code: String,
        pub name: String,
        #[serde(rename = "phoneNumber")]
        pub phone_number: String,
        #[serde(rename = "type")]
        pub type_: String,
    }
    impl From<&PayTransactionsResponseDataItemReceiverInfo>
    for PayTransactionsResponseDataItemReceiverInfo {
        fn from(value: &PayTransactionsResponseDataItemReceiverInfo) -> Self {
            value.clone()
        }
    }
    ///PayTransactionsResponseDataItemReceiverInfoExtendItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "cardNumber",
    ///    "digitalWalletId",
    ///    "institutionName"
    ///  ],
    ///  "properties": {
    ///    "cardNumber": {
    ///      "type": "string"
    ///    },
    ///    "digitalWalletId": {
    ///      "type": "string"
    ///    },
    ///    "institutionName": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct PayTransactionsResponseDataItemReceiverInfoExtendItem {
        #[serde(rename = "cardNumber")]
        pub card_number: String,
        #[serde(rename = "digitalWalletId")]
        pub digital_wallet_id: String,
        #[serde(rename = "institutionName")]
        pub institution_name: String,
    }
    impl From<&PayTransactionsResponseDataItemReceiverInfoExtendItem>
    for PayTransactionsResponseDataItemReceiverInfoExtendItem {
        fn from(value: &PayTransactionsResponseDataItemReceiverInfoExtendItem) -> Self {
            value.clone()
        }
    }
    ///PlaceNewOrderNewOrderRespType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "ACK",
    ///    "RESULT",
    ///    "FULL"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum PlaceNewOrderNewOrderRespType {
        #[serde(rename = "ACK")]
        Ack,
        #[serde(rename = "RESULT")]
        Result,
        #[serde(rename = "FULL")]
        Full,
    }
    impl From<&PlaceNewOrderNewOrderRespType> for PlaceNewOrderNewOrderRespType {
        fn from(value: &PlaceNewOrderNewOrderRespType) -> Self {
            value.clone()
        }
    }
    impl ToString for PlaceNewOrderNewOrderRespType {
        fn to_string(&self) -> String {
            match *self {
                Self::Ack => "ACK".to_string(),
                Self::Result => "RESULT".to_string(),
                Self::Full => "FULL".to_string(),
            }
        }
    }
    impl std::str::FromStr for PlaceNewOrderNewOrderRespType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "ACK" => Ok(Self::Ack),
                "RESULT" => Ok(Self::Result),
                "FULL" => Ok(Self::Full),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for PlaceNewOrderNewOrderRespType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for PlaceNewOrderNewOrderRespType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for PlaceNewOrderNewOrderRespType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///PlaceNewOrderResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/orderResponseAck"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/orderResponseResult"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/orderResponseFull"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    #[serde(untagged)]
    pub enum PlaceNewOrderResponse {
        Ack(OrderResponseAck),
        Result(OrderResponseResult),
        Full(OrderResponseFull),
    }
    impl From<&PlaceNewOrderResponse> for PlaceNewOrderResponse {
        fn from(value: &PlaceNewOrderResponse) -> Self {
            value.clone()
        }
    }
    impl From<OrderResponseAck> for PlaceNewOrderResponse {
        fn from(value: OrderResponseAck) -> Self {
            Self::Ack(value)
        }
    }
    impl From<OrderResponseResult> for PlaceNewOrderResponse {
        fn from(value: OrderResponseResult) -> Self {
            Self::Result(value)
        }
    }
    impl From<OrderResponseFull> for PlaceNewOrderResponse {
        fn from(value: OrderResponseFull) -> Self {
            Self::Full(value)
        }
    }
    ///PlaceNewOrderSelfTradePreventionMode
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "EXPIRE_TAKER"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "EXPIRE_TAKER",
    ///    "EXPIRE_MAKER",
    ///    "EXPIRE_BOTH",
    ///    "NONE"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum PlaceNewOrderSelfTradePreventionMode {
        #[serde(rename = "EXPIRE_TAKER")]
        ExpireTaker,
        #[serde(rename = "EXPIRE_MAKER")]
        ExpireMaker,
        #[serde(rename = "EXPIRE_BOTH")]
        ExpireBoth,
        #[serde(rename = "NONE")]
        None,
    }
    impl From<&PlaceNewOrderSelfTradePreventionMode>
    for PlaceNewOrderSelfTradePreventionMode {
        fn from(value: &PlaceNewOrderSelfTradePreventionMode) -> Self {
            value.clone()
        }
    }
    impl ToString for PlaceNewOrderSelfTradePreventionMode {
        fn to_string(&self) -> String {
            match *self {
                Self::ExpireTaker => "EXPIRE_TAKER".to_string(),
                Self::ExpireMaker => "EXPIRE_MAKER".to_string(),
                Self::ExpireBoth => "EXPIRE_BOTH".to_string(),
                Self::None => "NONE".to_string(),
            }
        }
    }
    impl std::str::FromStr for PlaceNewOrderSelfTradePreventionMode {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "EXPIRE_TAKER" => Ok(Self::ExpireTaker),
                "EXPIRE_MAKER" => Ok(Self::ExpireMaker),
                "EXPIRE_BOTH" => Ok(Self::ExpireBoth),
                "NONE" => Ok(Self::None),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for PlaceNewOrderSelfTradePreventionMode {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for PlaceNewOrderSelfTradePreventionMode {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for PlaceNewOrderSelfTradePreventionMode {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///PlaceNewOrderSide
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "SELL"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "SELL",
    ///    "BUY"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum PlaceNewOrderSide {
        #[serde(rename = "SELL")]
        Sell,
        #[serde(rename = "BUY")]
        Buy,
    }
    impl From<&PlaceNewOrderSide> for PlaceNewOrderSide {
        fn from(value: &PlaceNewOrderSide) -> Self {
            value.clone()
        }
    }
    impl ToString for PlaceNewOrderSide {
        fn to_string(&self) -> String {
            match *self {
                Self::Sell => "SELL".to_string(),
                Self::Buy => "BUY".to_string(),
            }
        }
    }
    impl std::str::FromStr for PlaceNewOrderSide {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "SELL" => Ok(Self::Sell),
                "BUY" => Ok(Self::Buy),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for PlaceNewOrderSide {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for PlaceNewOrderSide {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for PlaceNewOrderSide {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///PlaceNewOrderTimeInForce
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "GTC"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "GTC",
    ///    "IOC",
    ///    "FOK"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum PlaceNewOrderTimeInForce {
        #[serde(rename = "GTC")]
        Gtc,
        #[serde(rename = "IOC")]
        Ioc,
        #[serde(rename = "FOK")]
        Fok,
    }
    impl From<&PlaceNewOrderTimeInForce> for PlaceNewOrderTimeInForce {
        fn from(value: &PlaceNewOrderTimeInForce) -> Self {
            value.clone()
        }
    }
    impl ToString for PlaceNewOrderTimeInForce {
        fn to_string(&self) -> String {
            match *self {
                Self::Gtc => "GTC".to_string(),
                Self::Ioc => "IOC".to_string(),
                Self::Fok => "FOK".to_string(),
            }
        }
    }
    impl std::str::FromStr for PlaceNewOrderTimeInForce {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "GTC" => Ok(Self::Gtc),
                "IOC" => Ok(Self::Ioc),
                "FOK" => Ok(Self::Fok),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for PlaceNewOrderTimeInForce {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for PlaceNewOrderTimeInForce {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for PlaceNewOrderTimeInForce {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///PlaceNewOrderType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "LIMIT"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "LIMIT",
    ///    "MARKET",
    ///    "STOP_LOSS",
    ///    "STOP_LOSS_LIMIT",
    ///    "TAKE_PROFIT",
    ///    "TAKE_PROFIT_LIMIT",
    ///    "LIMIT_MAKER"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum PlaceNewOrderType {
        #[serde(rename = "LIMIT")]
        Limit,
        #[serde(rename = "MARKET")]
        Market,
        #[serde(rename = "STOP_LOSS")]
        StopLoss,
        #[serde(rename = "STOP_LOSS_LIMIT")]
        StopLossLimit,
        #[serde(rename = "TAKE_PROFIT")]
        TakeProfit,
        #[serde(rename = "TAKE_PROFIT_LIMIT")]
        TakeProfitLimit,
        #[serde(rename = "LIMIT_MAKER")]
        LimitMaker,
    }
    impl From<&PlaceNewOrderType> for PlaceNewOrderType {
        fn from(value: &PlaceNewOrderType) -> Self {
            value.clone()
        }
    }
    impl ToString for PlaceNewOrderType {
        fn to_string(&self) -> String {
            match *self {
                Self::Limit => "LIMIT".to_string(),
                Self::Market => "MARKET".to_string(),
                Self::StopLoss => "STOP_LOSS".to_string(),
                Self::StopLossLimit => "STOP_LOSS_LIMIT".to_string(),
                Self::TakeProfit => "TAKE_PROFIT".to_string(),
                Self::TakeProfitLimit => "TAKE_PROFIT_LIMIT".to_string(),
                Self::LimitMaker => "LIMIT_MAKER".to_string(),
            }
        }
    }
    impl std::str::FromStr for PlaceNewOrderType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "LIMIT" => Ok(Self::Limit),
                "MARKET" => Ok(Self::Market),
                "STOP_LOSS" => Ok(Self::StopLoss),
                "STOP_LOSS_LIMIT" => Ok(Self::StopLossLimit),
                "TAKE_PROFIT" => Ok(Self::TakeProfit),
                "TAKE_PROFIT_LIMIT" => Ok(Self::TakeProfitLimit),
                "LIMIT_MAKER" => Ok(Self::LimitMaker),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for PlaceNewOrderType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for PlaceNewOrderType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for PlaceNewOrderType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///PlaceOrderOcoNewOrderRespType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "ACK",
    ///    "RESULT",
    ///    "FULL"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum PlaceOrderOcoNewOrderRespType {
        #[serde(rename = "ACK")]
        Ack,
        #[serde(rename = "RESULT")]
        Result,
        #[serde(rename = "FULL")]
        Full,
    }
    impl From<&PlaceOrderOcoNewOrderRespType> for PlaceOrderOcoNewOrderRespType {
        fn from(value: &PlaceOrderOcoNewOrderRespType) -> Self {
            value.clone()
        }
    }
    impl ToString for PlaceOrderOcoNewOrderRespType {
        fn to_string(&self) -> String {
            match *self {
                Self::Ack => "ACK".to_string(),
                Self::Result => "RESULT".to_string(),
                Self::Full => "FULL".to_string(),
            }
        }
    }
    impl std::str::FromStr for PlaceOrderOcoNewOrderRespType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "ACK" => Ok(Self::Ack),
                "RESULT" => Ok(Self::Result),
                "FULL" => Ok(Self::Full),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for PlaceOrderOcoNewOrderRespType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for PlaceOrderOcoNewOrderRespType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for PlaceOrderOcoNewOrderRespType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///PlaceOrderOcoResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "contingencyType",
    ///    "listClientOrderId",
    ///    "listOrderStatus",
    ///    "listStatusType",
    ///    "orderListId",
    ///    "orderReports",
    ///    "orders",
    ///    "symbol",
    ///    "transactionTime"
    ///  ],
    ///  "properties": {
    ///    "contingencyType": {
    ///      "examples": [
    ///        "OCO"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "listClientOrderId": {
    ///      "examples": [
    ///        "JYVpp3F0f5CAG15DhtrqLp"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "listOrderStatus": {
    ///      "examples": [
    ///        "EXECUTING"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "listStatusType": {
    ///      "examples": [
    ///        "EXEC_STARTED"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "orderListId": {
    ///      "examples": [
    ///        0
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "orderReports": {
    ///      "examples": [
    ///        [
    ///          {
    ///            "clientOrderId": "Kk7sqHb9J6mJWTMDVW7Vos",
    ///            "cummulativeQuoteQty": "0.000000",
    ///            "executedQty": "0.000000",
    ///            "orderId": 2,
    ///            "orderListId": 0,
    ///            "origQty": "0.624363",
    ///            "price": "0.000000",
    ///            "selfTradePreventionMode": "NONE",
    ///            "side": "BUY",
    ///            "status": "NEW",
    ///            "stopPrice": "0.960664",
    ///            "symbol": "LTCBTC",
    ///            "timeInForce": "GTC",
    ///            "transactTime": 1563417480525,
    ///            "type": "STOP_LOSS",
    ///            "workingTime": -1
    ///          },
    ///          {
    ///            "clientOrderId": "xTXKaGYd4bluPVp78IVRvl",
    ///            "cummulativeQuoteQty": "0.000000",
    ///            "executedQty": "0.000000",
    ///            "orderId": 3,
    ///            "orderListId": 0,
    ///            "origQty": "0.624363",
    ///            "price": "0.036435",
    ///            "selfTradePreventionMode": "NONE",
    ///            "side": "BUY",
    ///            "status": "NEW",
    ///            "symbol": "LTCBTC",
    ///            "timeInForce": "GTC",
    ///            "transactTime": 1563417480525,
    ///            "type": "LIMIT_MAKER",
    ///            "workingTime": 1563417480525
    ///          }
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "clientOrderId",
    ///          "cummulativeQuoteQty",
    ///          "executedQty",
    ///          "orderId",
    ///          "orderListId",
    ///          "origQty",
    ///          "price",
    ///          "selfTradePreventionMode",
    ///          "side",
    ///          "status",
    ///          "stopPrice",
    ///          "symbol",
    ///          "timeInForce",
    ///          "transactTime",
    ///          "type",
    ///          "workingTime"
    ///        ],
    ///        "properties": {
    ///          "clientOrderId": {
    ///            "type": "string"
    ///          },
    ///          "cummulativeQuoteQty": {
    ///            "type": "string"
    ///          },
    ///          "executedQty": {
    ///            "type": "string"
    ///          },
    ///          "orderId": {
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "orderListId": {
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "origQty": {
    ///            "type": "string"
    ///          },
    ///          "price": {
    ///            "type": "string"
    ///          },
    ///          "selfTradePreventionMode": {
    ///            "type": "string"
    ///          },
    ///          "side": {
    ///            "type": "string"
    ///          },
    ///          "status": {
    ///            "type": "string"
    ///          },
    ///          "stopPrice": {
    ///            "type": "string"
    ///          },
    ///          "symbol": {
    ///            "type": "string"
    ///          },
    ///          "timeInForce": {
    ///            "type": "string"
    ///          },
    ///          "transactTime": {
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "type": {
    ///            "type": "string"
    ///          },
    ///          "workingTime": {
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "orders": {
    ///      "type": "array",
    ///      "items": {
    ///        "examples": [
    ///          [
    ///            {
    ///              "clientOrderId": "Kk7sqHb9J6mJWTMDVW7Vos",
    ///              "orderId": 2,
    ///              "symbol": "LTCBTC"
    ///            },
    ///            {
    ///              "clientOrderId": "xTXKaGYd4bluPVp78IVRvl",
    ///              "orderId": 3,
    ///              "symbol": "LTCBTC"
    ///            }
    ///          ]
    ///        ],
    ///        "type": "object",
    ///        "required": [
    ///          "clientOrderId",
    ///          "orderId",
    ///          "symbol"
    ///        ],
    ///        "properties": {
    ///          "clientOrderId": {
    ///            "type": "string"
    ///          },
    ///          "orderId": {
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "symbol": {
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "symbol": {
    ///      "examples": [
    ///        "LTCBTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "transactionTime": {
    ///      "examples": [
    ///        1563417480525
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct PlaceOrderOcoResponse {
        #[serde(rename = "contingencyType")]
        pub contingency_type: String,
        #[serde(rename = "listClientOrderId")]
        pub list_client_order_id: String,
        #[serde(rename = "listOrderStatus")]
        pub list_order_status: String,
        #[serde(rename = "listStatusType")]
        pub list_status_type: String,
        #[serde(rename = "orderListId")]
        pub order_list_id: i64,
        #[serde(rename = "orderReports")]
        pub order_reports: Vec<PlaceOrderOcoResponseOrderReportsItem>,
        pub orders: Vec<PlaceOrderOcoResponseOrdersItem>,
        pub symbol: String,
        #[serde(rename = "transactionTime")]
        pub transaction_time: i64,
    }
    impl From<&PlaceOrderOcoResponse> for PlaceOrderOcoResponse {
        fn from(value: &PlaceOrderOcoResponse) -> Self {
            value.clone()
        }
    }
    ///PlaceOrderOcoResponseOrderReportsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "clientOrderId",
    ///    "cummulativeQuoteQty",
    ///    "executedQty",
    ///    "orderId",
    ///    "orderListId",
    ///    "origQty",
    ///    "price",
    ///    "selfTradePreventionMode",
    ///    "side",
    ///    "status",
    ///    "stopPrice",
    ///    "symbol",
    ///    "timeInForce",
    ///    "transactTime",
    ///    "type",
    ///    "workingTime"
    ///  ],
    ///  "properties": {
    ///    "clientOrderId": {
    ///      "type": "string"
    ///    },
    ///    "cummulativeQuoteQty": {
    ///      "type": "string"
    ///    },
    ///    "executedQty": {
    ///      "type": "string"
    ///    },
    ///    "orderId": {
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "orderListId": {
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "origQty": {
    ///      "type": "string"
    ///    },
    ///    "price": {
    ///      "type": "string"
    ///    },
    ///    "selfTradePreventionMode": {
    ///      "type": "string"
    ///    },
    ///    "side": {
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "type": "string"
    ///    },
    ///    "stopPrice": {
    ///      "type": "string"
    ///    },
    ///    "symbol": {
    ///      "type": "string"
    ///    },
    ///    "timeInForce": {
    ///      "type": "string"
    ///    },
    ///    "transactTime": {
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "type": {
    ///      "type": "string"
    ///    },
    ///    "workingTime": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct PlaceOrderOcoResponseOrderReportsItem {
        #[serde(rename = "clientOrderId")]
        pub client_order_id: String,
        #[serde(rename = "cummulativeQuoteQty")]
        pub cummulative_quote_qty: String,
        #[serde(rename = "executedQty")]
        pub executed_qty: String,
        #[serde(rename = "orderId")]
        pub order_id: i64,
        #[serde(rename = "orderListId")]
        pub order_list_id: i64,
        #[serde(rename = "origQty")]
        pub orig_qty: String,
        pub price: String,
        #[serde(rename = "selfTradePreventionMode")]
        pub self_trade_prevention_mode: String,
        pub side: String,
        pub status: String,
        #[serde(rename = "stopPrice")]
        pub stop_price: String,
        pub symbol: String,
        #[serde(rename = "timeInForce")]
        pub time_in_force: String,
        #[serde(rename = "transactTime")]
        pub transact_time: i64,
        #[serde(rename = "type")]
        pub type_: String,
        #[serde(rename = "workingTime")]
        pub working_time: String,
    }
    impl From<&PlaceOrderOcoResponseOrderReportsItem>
    for PlaceOrderOcoResponseOrderReportsItem {
        fn from(value: &PlaceOrderOcoResponseOrderReportsItem) -> Self {
            value.clone()
        }
    }
    ///PlaceOrderOcoResponseOrdersItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    [
    ///      {
    ///        "clientOrderId": "Kk7sqHb9J6mJWTMDVW7Vos",
    ///        "orderId": 2,
    ///        "symbol": "LTCBTC"
    ///      },
    ///      {
    ///        "clientOrderId": "xTXKaGYd4bluPVp78IVRvl",
    ///        "orderId": 3,
    ///        "symbol": "LTCBTC"
    ///      }
    ///    ]
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "clientOrderId",
    ///    "orderId",
    ///    "symbol"
    ///  ],
    ///  "properties": {
    ///    "clientOrderId": {
    ///      "type": "string"
    ///    },
    ///    "orderId": {
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "symbol": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct PlaceOrderOcoResponseOrdersItem {
        #[serde(rename = "clientOrderId")]
        pub client_order_id: String,
        #[serde(rename = "orderId")]
        pub order_id: i64,
        pub symbol: String,
    }
    impl From<&PlaceOrderOcoResponseOrdersItem> for PlaceOrderOcoResponseOrdersItem {
        fn from(value: &PlaceOrderOcoResponseOrdersItem) -> Self {
            value.clone()
        }
    }
    ///PlaceOrderOcoSelfTradePreventionMode
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "EXPIRE_TAKER"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "EXPIRE_TAKER",
    ///    "EXPIRE_MAKER",
    ///    "EXPIRE_BOTH",
    ///    "NONE"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum PlaceOrderOcoSelfTradePreventionMode {
        #[serde(rename = "EXPIRE_TAKER")]
        ExpireTaker,
        #[serde(rename = "EXPIRE_MAKER")]
        ExpireMaker,
        #[serde(rename = "EXPIRE_BOTH")]
        ExpireBoth,
        #[serde(rename = "NONE")]
        None,
    }
    impl From<&PlaceOrderOcoSelfTradePreventionMode>
    for PlaceOrderOcoSelfTradePreventionMode {
        fn from(value: &PlaceOrderOcoSelfTradePreventionMode) -> Self {
            value.clone()
        }
    }
    impl ToString for PlaceOrderOcoSelfTradePreventionMode {
        fn to_string(&self) -> String {
            match *self {
                Self::ExpireTaker => "EXPIRE_TAKER".to_string(),
                Self::ExpireMaker => "EXPIRE_MAKER".to_string(),
                Self::ExpireBoth => "EXPIRE_BOTH".to_string(),
                Self::None => "NONE".to_string(),
            }
        }
    }
    impl std::str::FromStr for PlaceOrderOcoSelfTradePreventionMode {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "EXPIRE_TAKER" => Ok(Self::ExpireTaker),
                "EXPIRE_MAKER" => Ok(Self::ExpireMaker),
                "EXPIRE_BOTH" => Ok(Self::ExpireBoth),
                "NONE" => Ok(Self::None),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for PlaceOrderOcoSelfTradePreventionMode {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for PlaceOrderOcoSelfTradePreventionMode {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for PlaceOrderOcoSelfTradePreventionMode {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///PlaceOrderOcoSide
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "SELL"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "SELL",
    ///    "BUY"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum PlaceOrderOcoSide {
        #[serde(rename = "SELL")]
        Sell,
        #[serde(rename = "BUY")]
        Buy,
    }
    impl From<&PlaceOrderOcoSide> for PlaceOrderOcoSide {
        fn from(value: &PlaceOrderOcoSide) -> Self {
            value.clone()
        }
    }
    impl ToString for PlaceOrderOcoSide {
        fn to_string(&self) -> String {
            match *self {
                Self::Sell => "SELL".to_string(),
                Self::Buy => "BUY".to_string(),
            }
        }
    }
    impl std::str::FromStr for PlaceOrderOcoSide {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "SELL" => Ok(Self::Sell),
                "BUY" => Ok(Self::Buy),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for PlaceOrderOcoSide {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for PlaceOrderOcoSide {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for PlaceOrderOcoSide {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///PlaceOrderOcoStopLimitTimeInForce
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "GTC",
    ///    "FOK",
    ///    "IOC"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum PlaceOrderOcoStopLimitTimeInForce {
        #[serde(rename = "GTC")]
        Gtc,
        #[serde(rename = "FOK")]
        Fok,
        #[serde(rename = "IOC")]
        Ioc,
    }
    impl From<&PlaceOrderOcoStopLimitTimeInForce> for PlaceOrderOcoStopLimitTimeInForce {
        fn from(value: &PlaceOrderOcoStopLimitTimeInForce) -> Self {
            value.clone()
        }
    }
    impl ToString for PlaceOrderOcoStopLimitTimeInForce {
        fn to_string(&self) -> String {
            match *self {
                Self::Gtc => "GTC".to_string(),
                Self::Fok => "FOK".to_string(),
                Self::Ioc => "IOC".to_string(),
            }
        }
    }
    impl std::str::FromStr for PlaceOrderOcoStopLimitTimeInForce {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "GTC" => Ok(Self::Gtc),
                "FOK" => Ok(Self::Fok),
                "IOC" => Ok(Self::Ioc),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for PlaceOrderOcoStopLimitTimeInForce {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for PlaceOrderOcoStopLimitTimeInForce {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for PlaceOrderOcoStopLimitTimeInForce {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///PortfolioAccountResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "accountEquity",
    ///    "accountMaintMargin",
    ///    "accountStatus",
    ///    "accountType",
    ///    "actualEquity",
    ///    "uniMMR"
    ///  ],
    ///  "properties": {
    ///    "accountEquity": {
    ///      "description": "Account equity, unit is USD",
    ///      "examples": [
    ///        "122607.35137903"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "accountMaintMargin": {
    ///      "description": "Classic Portfolio margin account maintenance margin, unit is USD",
    ///      "examples": [
    ///        "23.72469206"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "accountStatus": {
    ///      "description": "Classic Portfolio margin account status:\"NORMAL\", \"MARGIN_CALL\", \"SUPPLY_MARGIN\", \"REDUCE_ONLY\", \"ACTIVE_LIQUIDATION\", \"FORCE_LIQUIDATION\", \"BANKRUPTED\"",
    ///      "examples": [
    ///        "NORMAL"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "accountType": {
    ///      "description": "PM_1 for classic PM, PM_2 for PM",
    ///      "examples": [
    ///        "PM_1"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "actualEquity": {
    ///      "description": "Actual equity, unit is USD",
    ///      "examples": [
    ///        "142607.35137903"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "uniMMR": {
    ///      "description": "Classic Portfolio margin account maintenance margin rate",
    ///      "examples": [
    ///        "1.87987800"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct PortfolioAccountResponse {
        ///Account equity, unit is USD
        #[serde(rename = "accountEquity")]
        pub account_equity: String,
        ///Classic Portfolio margin account maintenance margin, unit is USD
        #[serde(rename = "accountMaintMargin")]
        pub account_maint_margin: String,
        ///Classic Portfolio margin account status:"NORMAL", "MARGIN_CALL", "SUPPLY_MARGIN", "REDUCE_ONLY", "ACTIVE_LIQUIDATION", "FORCE_LIQUIDATION", "BANKRUPTED"
        #[serde(rename = "accountStatus")]
        pub account_status: String,
        ///PM_1 for classic PM, PM_2 for PM
        #[serde(rename = "accountType")]
        pub account_type: String,
        ///Actual equity, unit is USD
        #[serde(rename = "actualEquity")]
        pub actual_equity: String,
        ///Classic Portfolio margin account maintenance margin rate
        #[serde(rename = "uniMMR")]
        pub uni_mmr: String,
    }
    impl From<&PortfolioAccountResponse> for PortfolioAccountResponse {
        fn from(value: &PortfolioAccountResponse) -> Self {
            value.clone()
        }
    }
    ///PortfolioAssetCollectionResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "msg"
    ///  ],
    ///  "properties": {
    ///    "msg": {
    ///      "examples": [
    ///        "success"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct PortfolioAssetCollectionResponse {
        pub msg: String,
    }
    impl From<&PortfolioAssetCollectionResponse> for PortfolioAssetCollectionResponse {
        fn from(value: &PortfolioAssetCollectionResponse) -> Self {
            value.clone()
        }
    }
    ///PortfolioAssetIndexPriceResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "asset",
    ///    "assetIndexPrice",
    ///    "time"
    ///  ],
    ///  "properties": {
    ///    "asset": {
    ///      "examples": [
    ///        "USDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "assetIndexPrice": {
    ///      "examples": [
    ///        "28251.9136906"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "time": {
    ///      "examples": [
    ///        1683518338121
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct PortfolioAssetIndexPriceResponseItem {
        pub asset: String,
        #[serde(rename = "assetIndexPrice")]
        pub asset_index_price: String,
        pub time: i64,
    }
    impl From<&PortfolioAssetIndexPriceResponseItem>
    for PortfolioAssetIndexPriceResponseItem {
        fn from(value: &PortfolioAssetIndexPriceResponseItem) -> Self {
            value.clone()
        }
    }
    ///PortfolioAutoCollectionResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "msg"
    ///  ],
    ///  "properties": {
    ///    "msg": {
    ///      "examples": [
    ///        "success"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct PortfolioAutoCollectionResponse {
        pub msg: String,
    }
    impl From<&PortfolioAutoCollectionResponse> for PortfolioAutoCollectionResponse {
        fn from(value: &PortfolioAutoCollectionResponse) -> Self {
            value.clone()
        }
    }
    ///PortfolioBnbTransferResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "tranId"
    ///  ],
    ///  "properties": {
    ///    "tranId": {
    ///      "examples": [
    ///        100000001
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct PortfolioBnbTransferResponse {
        #[serde(rename = "tranId")]
        pub tran_id: i64,
    }
    impl From<&PortfolioBnbTransferResponse> for PortfolioBnbTransferResponse {
        fn from(value: &PortfolioBnbTransferResponse) -> Self {
            value.clone()
        }
    }
    ///PortfolioBnbTransferTransferSide
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "TO_UM"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "TO_UM",
    ///    "FROM_UM"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum PortfolioBnbTransferTransferSide {
        #[serde(rename = "TO_UM")]
        ToUm,
        #[serde(rename = "FROM_UM")]
        FromUm,
    }
    impl From<&PortfolioBnbTransferTransferSide> for PortfolioBnbTransferTransferSide {
        fn from(value: &PortfolioBnbTransferTransferSide) -> Self {
            value.clone()
        }
    }
    impl ToString for PortfolioBnbTransferTransferSide {
        fn to_string(&self) -> String {
            match *self {
                Self::ToUm => "TO_UM".to_string(),
                Self::FromUm => "FROM_UM".to_string(),
            }
        }
    }
    impl std::str::FromStr for PortfolioBnbTransferTransferSide {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "TO_UM" => Ok(Self::ToUm),
                "FROM_UM" => Ok(Self::FromUm),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for PortfolioBnbTransferTransferSide {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for PortfolioBnbTransferTransferSide {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for PortfolioBnbTransferTransferSide {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///PortfolioCollateralRateResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "asset",
    ///    "collateralRate"
    ///  ],
    ///  "properties": {
    ///    "asset": {
    ///      "examples": [
    ///        "USDC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "collateralRate": {
    ///      "examples": [
    ///        "1.0000"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct PortfolioCollateralRateResponseItem {
        pub asset: String,
        #[serde(rename = "collateralRate")]
        pub collateral_rate: String,
    }
    impl From<&PortfolioCollateralRateResponseItem>
    for PortfolioCollateralRateResponseItem {
        fn from(value: &PortfolioCollateralRateResponseItem) -> Self {
            value.clone()
        }
    }
    ///PortfolioInterestHistoryResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "asset",
    ///    "interest",
    ///    "interestAccruedTime",
    ///    "interestRate",
    ///    "principal"
    ///  ],
    ///  "properties": {
    ///    "asset": {
    ///      "examples": [
    ///        "USDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "interest": {
    ///      "examples": [
    ///        "24.4440"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "interestAccruedTime": {
    ///      "examples": [
    ///        1672801339253
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "interestRate": {
    ///      "examples": [
    ///        "0.0001164"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "principal": {
    ///      "examples": [
    ///        "210000"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct PortfolioInterestHistoryResponseItem {
        pub asset: String,
        pub interest: String,
        #[serde(rename = "interestAccruedTime")]
        pub interest_accrued_time: i64,
        #[serde(rename = "interestRate")]
        pub interest_rate: String,
        pub principal: String,
    }
    impl From<&PortfolioInterestHistoryResponseItem>
    for PortfolioInterestHistoryResponseItem {
        fn from(value: &PortfolioInterestHistoryResponseItem) -> Self {
            value.clone()
        }
    }
    ///PortfolioMarginAssetLeverageResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "asset": {
    ///      "examples": [
    ///        "USDC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "collateralRate": {
    ///      "examples": [
    ///        "1.0000"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct PortfolioMarginAssetLeverageResponseItem {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub asset: Option<String>,
        #[serde(
            rename = "collateralRate",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub collateral_rate: Option<String>,
    }
    impl From<&PortfolioMarginAssetLeverageResponseItem>
    for PortfolioMarginAssetLeverageResponseItem {
        fn from(value: &PortfolioMarginAssetLeverageResponseItem) -> Self {
            value.clone()
        }
    }
    ///PortfolioPmLoanResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "asset"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "examples": [
    ///        "579.45"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "asset": {
    ///      "examples": [
    ///        "BUSD"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct PortfolioPmLoanResponse {
        pub amount: String,
        pub asset: String,
    }
    impl From<&PortfolioPmLoanResponse> for PortfolioPmLoanResponse {
        fn from(value: &PortfolioPmLoanResponse) -> Self {
            value.clone()
        }
    }
    ///PortfolioRepayFuturesNegativeBalanceResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "msg"
    ///  ],
    ///  "properties": {
    ///    "msg": {
    ///      "examples": [
    ///        "success"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct PortfolioRepayFuturesNegativeBalanceResponse {
        pub msg: String,
    }
    impl From<&PortfolioRepayFuturesNegativeBalanceResponse>
    for PortfolioRepayFuturesNegativeBalanceResponse {
        fn from(value: &PortfolioRepayFuturesNegativeBalanceResponse) -> Self {
            value.clone()
        }
    }
    ///PortfolioRepayFuturesSwitchResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "msg"
    ///  ],
    ///  "properties": {
    ///    "msg": {
    ///      "examples": [
    ///        "success"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct PortfolioRepayFuturesSwitchResponse {
        pub msg: String,
    }
    impl From<&PortfolioRepayFuturesSwitchResponse>
    for PortfolioRepayFuturesSwitchResponse {
        fn from(value: &PortfolioRepayFuturesSwitchResponse) -> Self {
            value.clone()
        }
    }
    ///PortfolioRepayResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "tranId"
    ///  ],
    ///  "properties": {
    ///    "tranId": {
    ///      "examples": [
    ///        58203331886213500
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct PortfolioRepayResponse {
        #[serde(rename = "tranId")]
        pub tran_id: i64,
    }
    impl From<&PortfolioRepayResponse> for PortfolioRepayResponse {
        fn from(value: &PortfolioRepayResponse) -> Self {
            value.clone()
        }
    }
    ///PostMarginIsolatedAccountResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "success",
    ///    "symbol"
    ///  ],
    ///  "properties": {
    ///    "success": {
    ///      "type": "boolean"
    ///    },
    ///    "symbol": {
    ///      "examples": [
    ///        "BTCUSDT"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct PostMarginIsolatedAccountResponse {
        pub success: bool,
        pub symbol: String,
    }
    impl From<&PostMarginIsolatedAccountResponse> for PostMarginIsolatedAccountResponse {
        fn from(value: &PostMarginIsolatedAccountResponse) -> Self {
            value.clone()
        }
    }
    ///PostMarginIsolatedTransferTransFrom
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "SPOT"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "SPOT",
    ///    "ISOLATED_MARGIN"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum PostMarginIsolatedTransferTransFrom {
        #[serde(rename = "SPOT")]
        Spot,
        #[serde(rename = "ISOLATED_MARGIN")]
        IsolatedMargin,
    }
    impl From<&PostMarginIsolatedTransferTransFrom>
    for PostMarginIsolatedTransferTransFrom {
        fn from(value: &PostMarginIsolatedTransferTransFrom) -> Self {
            value.clone()
        }
    }
    impl ToString for PostMarginIsolatedTransferTransFrom {
        fn to_string(&self) -> String {
            match *self {
                Self::Spot => "SPOT".to_string(),
                Self::IsolatedMargin => "ISOLATED_MARGIN".to_string(),
            }
        }
    }
    impl std::str::FromStr for PostMarginIsolatedTransferTransFrom {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "SPOT" => Ok(Self::Spot),
                "ISOLATED_MARGIN" => Ok(Self::IsolatedMargin),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for PostMarginIsolatedTransferTransFrom {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for PostMarginIsolatedTransferTransFrom {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for PostMarginIsolatedTransferTransFrom {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///PostMarginIsolatedTransferTransTo
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "ISOLATED_MARGIN"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "SPOT",
    ///    "ISOLATED_MARGIN"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum PostMarginIsolatedTransferTransTo {
        #[serde(rename = "SPOT")]
        Spot,
        #[serde(rename = "ISOLATED_MARGIN")]
        IsolatedMargin,
    }
    impl From<&PostMarginIsolatedTransferTransTo> for PostMarginIsolatedTransferTransTo {
        fn from(value: &PostMarginIsolatedTransferTransTo) -> Self {
            value.clone()
        }
    }
    impl ToString for PostMarginIsolatedTransferTransTo {
        fn to_string(&self) -> String {
            match *self {
                Self::Spot => "SPOT".to_string(),
                Self::IsolatedMargin => "ISOLATED_MARGIN".to_string(),
            }
        }
    }
    impl std::str::FromStr for PostMarginIsolatedTransferTransTo {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "SPOT" => Ok(Self::Spot),
                "ISOLATED_MARGIN" => Ok(Self::IsolatedMargin),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for PostMarginIsolatedTransferTransTo {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for PostMarginIsolatedTransferTransTo {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for PostMarginIsolatedTransferTransTo {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///PostMarginOrderIsIsolated
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "TRUE",
    ///    "FALSE"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum PostMarginOrderIsIsolated {
        #[serde(rename = "TRUE")]
        True,
        #[serde(rename = "FALSE")]
        False,
    }
    impl From<&PostMarginOrderIsIsolated> for PostMarginOrderIsIsolated {
        fn from(value: &PostMarginOrderIsIsolated) -> Self {
            value.clone()
        }
    }
    impl ToString for PostMarginOrderIsIsolated {
        fn to_string(&self) -> String {
            match *self {
                Self::True => "TRUE".to_string(),
                Self::False => "FALSE".to_string(),
            }
        }
    }
    impl std::str::FromStr for PostMarginOrderIsIsolated {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "TRUE" => Ok(Self::True),
                "FALSE" => Ok(Self::False),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for PostMarginOrderIsIsolated {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for PostMarginOrderIsIsolated {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for PostMarginOrderIsIsolated {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///PostMarginOrderNewOrderRespType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "ACK",
    ///    "RESULT",
    ///    "FULL"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum PostMarginOrderNewOrderRespType {
        #[serde(rename = "ACK")]
        Ack,
        #[serde(rename = "RESULT")]
        Result,
        #[serde(rename = "FULL")]
        Full,
    }
    impl From<&PostMarginOrderNewOrderRespType> for PostMarginOrderNewOrderRespType {
        fn from(value: &PostMarginOrderNewOrderRespType) -> Self {
            value.clone()
        }
    }
    impl ToString for PostMarginOrderNewOrderRespType {
        fn to_string(&self) -> String {
            match *self {
                Self::Ack => "ACK".to_string(),
                Self::Result => "RESULT".to_string(),
                Self::Full => "FULL".to_string(),
            }
        }
    }
    impl std::str::FromStr for PostMarginOrderNewOrderRespType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "ACK" => Ok(Self::Ack),
                "RESULT" => Ok(Self::Result),
                "FULL" => Ok(Self::Full),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for PostMarginOrderNewOrderRespType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for PostMarginOrderNewOrderRespType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for PostMarginOrderNewOrderRespType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///PostMarginOrderResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/marginOrderResponseAck"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/marginOrderResponseResult"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/marginOrderResponseFull"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    #[serde(untagged)]
    pub enum PostMarginOrderResponse {
        Ack(MarginOrderResponseAck),
        Result(MarginOrderResponseResult),
        Full(MarginOrderResponseFull),
    }
    impl From<&PostMarginOrderResponse> for PostMarginOrderResponse {
        fn from(value: &PostMarginOrderResponse) -> Self {
            value.clone()
        }
    }
    impl From<MarginOrderResponseAck> for PostMarginOrderResponse {
        fn from(value: MarginOrderResponseAck) -> Self {
            Self::Ack(value)
        }
    }
    impl From<MarginOrderResponseResult> for PostMarginOrderResponse {
        fn from(value: MarginOrderResponseResult) -> Self {
            Self::Result(value)
        }
    }
    impl From<MarginOrderResponseFull> for PostMarginOrderResponse {
        fn from(value: MarginOrderResponseFull) -> Self {
            Self::Full(value)
        }
    }
    ///PostMarginOrderSelfTradePreventionMode
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "EXPIRE_TAKER"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "EXPIRE_TAKER",
    ///    "EXPIRE_MAKER",
    ///    "EXPIRE_BOTH",
    ///    "NONE"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum PostMarginOrderSelfTradePreventionMode {
        #[serde(rename = "EXPIRE_TAKER")]
        ExpireTaker,
        #[serde(rename = "EXPIRE_MAKER")]
        ExpireMaker,
        #[serde(rename = "EXPIRE_BOTH")]
        ExpireBoth,
        #[serde(rename = "NONE")]
        None,
    }
    impl From<&PostMarginOrderSelfTradePreventionMode>
    for PostMarginOrderSelfTradePreventionMode {
        fn from(value: &PostMarginOrderSelfTradePreventionMode) -> Self {
            value.clone()
        }
    }
    impl ToString for PostMarginOrderSelfTradePreventionMode {
        fn to_string(&self) -> String {
            match *self {
                Self::ExpireTaker => "EXPIRE_TAKER".to_string(),
                Self::ExpireMaker => "EXPIRE_MAKER".to_string(),
                Self::ExpireBoth => "EXPIRE_BOTH".to_string(),
                Self::None => "NONE".to_string(),
            }
        }
    }
    impl std::str::FromStr for PostMarginOrderSelfTradePreventionMode {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "EXPIRE_TAKER" => Ok(Self::ExpireTaker),
                "EXPIRE_MAKER" => Ok(Self::ExpireMaker),
                "EXPIRE_BOTH" => Ok(Self::ExpireBoth),
                "NONE" => Ok(Self::None),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for PostMarginOrderSelfTradePreventionMode {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for PostMarginOrderSelfTradePreventionMode {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for PostMarginOrderSelfTradePreventionMode {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///PostMarginOrderSide
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "SELL"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "SELL",
    ///    "BUY"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum PostMarginOrderSide {
        #[serde(rename = "SELL")]
        Sell,
        #[serde(rename = "BUY")]
        Buy,
    }
    impl From<&PostMarginOrderSide> for PostMarginOrderSide {
        fn from(value: &PostMarginOrderSide) -> Self {
            value.clone()
        }
    }
    impl ToString for PostMarginOrderSide {
        fn to_string(&self) -> String {
            match *self {
                Self::Sell => "SELL".to_string(),
                Self::Buy => "BUY".to_string(),
            }
        }
    }
    impl std::str::FromStr for PostMarginOrderSide {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "SELL" => Ok(Self::Sell),
                "BUY" => Ok(Self::Buy),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for PostMarginOrderSide {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for PostMarginOrderSide {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for PostMarginOrderSide {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///PostMarginOrderSideEffectType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "NO_SIDE_EFFECT",
    ///    "MARGIN_BUY",
    ///    "AUTO_REPAY"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum PostMarginOrderSideEffectType {
        #[serde(rename = "NO_SIDE_EFFECT")]
        NoSideEffect,
        #[serde(rename = "MARGIN_BUY")]
        MarginBuy,
        #[serde(rename = "AUTO_REPAY")]
        AutoRepay,
    }
    impl From<&PostMarginOrderSideEffectType> for PostMarginOrderSideEffectType {
        fn from(value: &PostMarginOrderSideEffectType) -> Self {
            value.clone()
        }
    }
    impl ToString for PostMarginOrderSideEffectType {
        fn to_string(&self) -> String {
            match *self {
                Self::NoSideEffect => "NO_SIDE_EFFECT".to_string(),
                Self::MarginBuy => "MARGIN_BUY".to_string(),
                Self::AutoRepay => "AUTO_REPAY".to_string(),
            }
        }
    }
    impl std::str::FromStr for PostMarginOrderSideEffectType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "NO_SIDE_EFFECT" => Ok(Self::NoSideEffect),
                "MARGIN_BUY" => Ok(Self::MarginBuy),
                "AUTO_REPAY" => Ok(Self::AutoRepay),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for PostMarginOrderSideEffectType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for PostMarginOrderSideEffectType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for PostMarginOrderSideEffectType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///PostMarginOrderTimeInForce
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "GTC"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "GTC",
    ///    "IOC",
    ///    "FOK"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum PostMarginOrderTimeInForce {
        #[serde(rename = "GTC")]
        Gtc,
        #[serde(rename = "IOC")]
        Ioc,
        #[serde(rename = "FOK")]
        Fok,
    }
    impl From<&PostMarginOrderTimeInForce> for PostMarginOrderTimeInForce {
        fn from(value: &PostMarginOrderTimeInForce) -> Self {
            value.clone()
        }
    }
    impl ToString for PostMarginOrderTimeInForce {
        fn to_string(&self) -> String {
            match *self {
                Self::Gtc => "GTC".to_string(),
                Self::Ioc => "IOC".to_string(),
                Self::Fok => "FOK".to_string(),
            }
        }
    }
    impl std::str::FromStr for PostMarginOrderTimeInForce {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "GTC" => Ok(Self::Gtc),
                "IOC" => Ok(Self::Ioc),
                "FOK" => Ok(Self::Fok),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for PostMarginOrderTimeInForce {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for PostMarginOrderTimeInForce {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for PostMarginOrderTimeInForce {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///PostMarginOrderType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "LIMIT"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "LIMIT",
    ///    "MARKET",
    ///    "STOP_LOSS",
    ///    "STOP_LOSS_LIMIT",
    ///    "TAKE_PROFIT",
    ///    "TAKE_PROFIT_LIMIT",
    ///    "LIMIT_MAKER"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum PostMarginOrderType {
        #[serde(rename = "LIMIT")]
        Limit,
        #[serde(rename = "MARKET")]
        Market,
        #[serde(rename = "STOP_LOSS")]
        StopLoss,
        #[serde(rename = "STOP_LOSS_LIMIT")]
        StopLossLimit,
        #[serde(rename = "TAKE_PROFIT")]
        TakeProfit,
        #[serde(rename = "TAKE_PROFIT_LIMIT")]
        TakeProfitLimit,
        #[serde(rename = "LIMIT_MAKER")]
        LimitMaker,
    }
    impl From<&PostMarginOrderType> for PostMarginOrderType {
        fn from(value: &PostMarginOrderType) -> Self {
            value.clone()
        }
    }
    impl ToString for PostMarginOrderType {
        fn to_string(&self) -> String {
            match *self {
                Self::Limit => "LIMIT".to_string(),
                Self::Market => "MARKET".to_string(),
                Self::StopLoss => "STOP_LOSS".to_string(),
                Self::StopLossLimit => "STOP_LOSS_LIMIT".to_string(),
                Self::TakeProfit => "TAKE_PROFIT".to_string(),
                Self::TakeProfitLimit => "TAKE_PROFIT_LIMIT".to_string(),
                Self::LimitMaker => "LIMIT_MAKER".to_string(),
            }
        }
    }
    impl std::str::FromStr for PostMarginOrderType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "LIMIT" => Ok(Self::Limit),
                "MARKET" => Ok(Self::Market),
                "STOP_LOSS" => Ok(Self::StopLoss),
                "STOP_LOSS_LIMIT" => Ok(Self::StopLossLimit),
                "TAKE_PROFIT" => Ok(Self::TakeProfit),
                "TAKE_PROFIT_LIMIT" => Ok(Self::TakeProfitLimit),
                "LIMIT_MAKER" => Ok(Self::LimitMaker),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for PostMarginOrderType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for PostMarginOrderType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for PostMarginOrderType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///PostSubAccountFutureAssetTransferResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "success",
    ///    "txnId"
    ///  ],
    ///  "properties": {
    ///    "success": {
    ///      "type": "boolean"
    ///    },
    ///    "txnId": {
    ///      "examples": [
    ///        "2934662589"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct PostSubAccountFutureAssetTransferResponse {
        pub success: bool,
        #[serde(rename = "txnId")]
        pub txn_id: String,
    }
    impl From<&PostSubAccountFutureAssetTransferResponse>
    for PostSubAccountFutureAssetTransferResponse {
        fn from(value: &PostSubAccountFutureAssetTransferResponse) -> Self {
            value.clone()
        }
    }
    ///PostUserUniversalTransferResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "tranId"
    ///  ],
    ///  "properties": {
    ///    "tranId": {
    ///      "examples": [
    ///        13526853623
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct PostUserUniversalTransferResponse {
        #[serde(rename = "tranId")]
        pub tran_id: i64,
    }
    impl From<&PostUserUniversalTransferResponse> for PostUserUniversalTransferResponse {
        fn from(value: &PostUserUniversalTransferResponse) -> Self {
            value.clone()
        }
    }
    ///PostUserUniversalTransferType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "MAIN_C2C"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "MAIN_C2C",
    ///    "MAIN_UMFUTURE",
    ///    "MAIN_CMFUTURE",
    ///    "MAIN_MARGIN",
    ///    "MAIN_MINING",
    ///    "C2C_MAIN",
    ///    "C2C_UMFUTURE",
    ///    "C2C_MINING",
    ///    "C2C_MARGIN",
    ///    "UMFUTURE_MAIN",
    ///    "UMFUTURE_C2C",
    ///    "UMFUTURE_MARGIN",
    ///    "CMFUTURE_MAIN",
    ///    "CMFUTURE_MARGIN",
    ///    "MARGIN_MAIN",
    ///    "MARGIN_UMFUTURE",
    ///    "MARGIN_CMFUTURE",
    ///    "MARGIN_MINING",
    ///    "MARGIN_C2C",
    ///    "MINING_MAIN",
    ///    "MINING_UMFUTURE",
    ///    "MINING_C2C",
    ///    "MINING_MARGIN",
    ///    "MAIN_PAY",
    ///    "PAY_MAIN",
    ///    "ISOLATEDMARGIN_MARGIN",
    ///    "MARGIN_ISOLATEDMARGIN",
    ///    "ISOLATEDMARGIN_ISOLATEDMARGIN"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum PostUserUniversalTransferType {
        #[serde(rename = "MAIN_C2C")]
        MainC2c,
        #[serde(rename = "MAIN_UMFUTURE")]
        MainUmfuture,
        #[serde(rename = "MAIN_CMFUTURE")]
        MainCmfuture,
        #[serde(rename = "MAIN_MARGIN")]
        MainMargin,
        #[serde(rename = "MAIN_MINING")]
        MainMining,
        #[serde(rename = "C2C_MAIN")]
        C2cMain,
        #[serde(rename = "C2C_UMFUTURE")]
        C2cUmfuture,
        #[serde(rename = "C2C_MINING")]
        C2cMining,
        #[serde(rename = "C2C_MARGIN")]
        C2cMargin,
        #[serde(rename = "UMFUTURE_MAIN")]
        UmfutureMain,
        #[serde(rename = "UMFUTURE_C2C")]
        UmfutureC2c,
        #[serde(rename = "UMFUTURE_MARGIN")]
        UmfutureMargin,
        #[serde(rename = "CMFUTURE_MAIN")]
        CmfutureMain,
        #[serde(rename = "CMFUTURE_MARGIN")]
        CmfutureMargin,
        #[serde(rename = "MARGIN_MAIN")]
        MarginMain,
        #[serde(rename = "MARGIN_UMFUTURE")]
        MarginUmfuture,
        #[serde(rename = "MARGIN_CMFUTURE")]
        MarginCmfuture,
        #[serde(rename = "MARGIN_MINING")]
        MarginMining,
        #[serde(rename = "MARGIN_C2C")]
        MarginC2c,
        #[serde(rename = "MINING_MAIN")]
        MiningMain,
        #[serde(rename = "MINING_UMFUTURE")]
        MiningUmfuture,
        #[serde(rename = "MINING_C2C")]
        MiningC2c,
        #[serde(rename = "MINING_MARGIN")]
        MiningMargin,
        #[serde(rename = "MAIN_PAY")]
        MainPay,
        #[serde(rename = "PAY_MAIN")]
        PayMain,
        #[serde(rename = "ISOLATEDMARGIN_MARGIN")]
        IsolatedmarginMargin,
        #[serde(rename = "MARGIN_ISOLATEDMARGIN")]
        MarginIsolatedmargin,
        #[serde(rename = "ISOLATEDMARGIN_ISOLATEDMARGIN")]
        IsolatedmarginIsolatedmargin,
    }
    impl From<&PostUserUniversalTransferType> for PostUserUniversalTransferType {
        fn from(value: &PostUserUniversalTransferType) -> Self {
            value.clone()
        }
    }
    impl ToString for PostUserUniversalTransferType {
        fn to_string(&self) -> String {
            match *self {
                Self::MainC2c => "MAIN_C2C".to_string(),
                Self::MainUmfuture => "MAIN_UMFUTURE".to_string(),
                Self::MainCmfuture => "MAIN_CMFUTURE".to_string(),
                Self::MainMargin => "MAIN_MARGIN".to_string(),
                Self::MainMining => "MAIN_MINING".to_string(),
                Self::C2cMain => "C2C_MAIN".to_string(),
                Self::C2cUmfuture => "C2C_UMFUTURE".to_string(),
                Self::C2cMining => "C2C_MINING".to_string(),
                Self::C2cMargin => "C2C_MARGIN".to_string(),
                Self::UmfutureMain => "UMFUTURE_MAIN".to_string(),
                Self::UmfutureC2c => "UMFUTURE_C2C".to_string(),
                Self::UmfutureMargin => "UMFUTURE_MARGIN".to_string(),
                Self::CmfutureMain => "CMFUTURE_MAIN".to_string(),
                Self::CmfutureMargin => "CMFUTURE_MARGIN".to_string(),
                Self::MarginMain => "MARGIN_MAIN".to_string(),
                Self::MarginUmfuture => "MARGIN_UMFUTURE".to_string(),
                Self::MarginCmfuture => "MARGIN_CMFUTURE".to_string(),
                Self::MarginMining => "MARGIN_MINING".to_string(),
                Self::MarginC2c => "MARGIN_C2C".to_string(),
                Self::MiningMain => "MINING_MAIN".to_string(),
                Self::MiningUmfuture => "MINING_UMFUTURE".to_string(),
                Self::MiningC2c => "MINING_C2C".to_string(),
                Self::MiningMargin => "MINING_MARGIN".to_string(),
                Self::MainPay => "MAIN_PAY".to_string(),
                Self::PayMain => "PAY_MAIN".to_string(),
                Self::IsolatedmarginMargin => "ISOLATEDMARGIN_MARGIN".to_string(),
                Self::MarginIsolatedmargin => "MARGIN_ISOLATEDMARGIN".to_string(),
                Self::IsolatedmarginIsolatedmargin => {
                    "ISOLATEDMARGIN_ISOLATEDMARGIN".to_string()
                }
            }
        }
    }
    impl std::str::FromStr for PostUserUniversalTransferType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "MAIN_C2C" => Ok(Self::MainC2c),
                "MAIN_UMFUTURE" => Ok(Self::MainUmfuture),
                "MAIN_CMFUTURE" => Ok(Self::MainCmfuture),
                "MAIN_MARGIN" => Ok(Self::MainMargin),
                "MAIN_MINING" => Ok(Self::MainMining),
                "C2C_MAIN" => Ok(Self::C2cMain),
                "C2C_UMFUTURE" => Ok(Self::C2cUmfuture),
                "C2C_MINING" => Ok(Self::C2cMining),
                "C2C_MARGIN" => Ok(Self::C2cMargin),
                "UMFUTURE_MAIN" => Ok(Self::UmfutureMain),
                "UMFUTURE_C2C" => Ok(Self::UmfutureC2c),
                "UMFUTURE_MARGIN" => Ok(Self::UmfutureMargin),
                "CMFUTURE_MAIN" => Ok(Self::CmfutureMain),
                "CMFUTURE_MARGIN" => Ok(Self::CmfutureMargin),
                "MARGIN_MAIN" => Ok(Self::MarginMain),
                "MARGIN_UMFUTURE" => Ok(Self::MarginUmfuture),
                "MARGIN_CMFUTURE" => Ok(Self::MarginCmfuture),
                "MARGIN_MINING" => Ok(Self::MarginMining),
                "MARGIN_C2C" => Ok(Self::MarginC2c),
                "MINING_MAIN" => Ok(Self::MiningMain),
                "MINING_UMFUTURE" => Ok(Self::MiningUmfuture),
                "MINING_C2C" => Ok(Self::MiningC2c),
                "MINING_MARGIN" => Ok(Self::MiningMargin),
                "MAIN_PAY" => Ok(Self::MainPay),
                "PAY_MAIN" => Ok(Self::PayMain),
                "ISOLATEDMARGIN_MARGIN" => Ok(Self::IsolatedmarginMargin),
                "MARGIN_ISOLATEDMARGIN" => Ok(Self::MarginIsolatedmargin),
                "ISOLATEDMARGIN_ISOLATEDMARGIN" => Ok(Self::IsolatedmarginIsolatedmargin),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for PostUserUniversalTransferType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for PostUserUniversalTransferType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for PostUserUniversalTransferType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///PriceTicker
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "price",
    ///    "symbol"
    ///  ],
    ///  "properties": {
    ///    "price": {
    ///      "examples": [
    ///        "0.17160000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "symbol": {
    ///      "examples": [
    ///        "BNBBTC"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct PriceTicker {
        pub price: String,
        pub symbol: String,
    }
    impl From<&PriceTicker> for PriceTicker {
        fn from(value: &PriceTicker) -> Self {
            value.clone()
        }
    }
    ///PriceTickerList
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "array",
    ///  "items": {
    ///    "$ref": "#/components/schemas/priceTicker"
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct PriceTickerList(pub Vec<PriceTicker>);
    impl std::ops::Deref for PriceTickerList {
        type Target = Vec<PriceTicker>;
        fn deref(&self) -> &Vec<PriceTicker> {
            &self.0
        }
    }
    impl From<PriceTickerList> for Vec<PriceTicker> {
        fn from(value: PriceTickerList) -> Self {
            value.0
        }
    }
    impl From<&PriceTickerList> for PriceTickerList {
        fn from(value: &PriceTickerList) -> Self {
            value.clone()
        }
    }
    impl From<Vec<PriceTicker>> for PriceTickerList {
        fn from(value: Vec<PriceTicker>) -> Self {
            Self(value)
        }
    }
    ///QueryMarginIsolatedTransferType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "ROLL_IN",
    ///    "ROLL_OUT"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum QueryMarginIsolatedTransferType {
        #[serde(rename = "ROLL_IN")]
        RollIn,
        #[serde(rename = "ROLL_OUT")]
        RollOut,
    }
    impl From<&QueryMarginIsolatedTransferType> for QueryMarginIsolatedTransferType {
        fn from(value: &QueryMarginIsolatedTransferType) -> Self {
            value.clone()
        }
    }
    impl ToString for QueryMarginIsolatedTransferType {
        fn to_string(&self) -> String {
            match *self {
                Self::RollIn => "ROLL_IN".to_string(),
                Self::RollOut => "ROLL_OUT".to_string(),
            }
        }
    }
    impl std::str::FromStr for QueryMarginIsolatedTransferType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "ROLL_IN" => Ok(Self::RollIn),
                "ROLL_OUT" => Ok(Self::RollOut),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for QueryMarginIsolatedTransferType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for QueryMarginIsolatedTransferType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for QueryMarginIsolatedTransferType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///QueryMarginLoanRecordResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    {
    ///      "rows": [
    ///        {
    ///          "asset": "BNB",
    ///          "isolatedSymbol": "BNBUSDT",
    ///          "principal": "0.84624403",
    ///          "status": "CONFIRMED",
    ///          "timestamp": 1555056425000,
    ///          "txId": 12807067523
    ///        }
    ///      ],
    ///      "total": 1
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "rows",
    ///    "total"
    ///  ],
    ///  "properties": {
    ///    "rows": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "asset",
    ///          "isolatedSymbol",
    ///          "principal",
    ///          "status",
    ///          "timestamp",
    ///          "txId"
    ///        ],
    ///        "properties": {
    ///          "asset": {
    ///            "type": "string"
    ///          },
    ///          "isolatedSymbol": {
    ///            "type": "string"
    ///          },
    ///          "principal": {
    ///            "type": "string"
    ///          },
    ///          "status": {
    ///            "type": "string"
    ///          },
    ///          "timestamp": {
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "txId": {
    ///            "type": "integer",
    ///            "format": "int64"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "total": {
    ///      "type": "integer",
    ///      "format": "int32"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct QueryMarginLoanRecordResponse {
        pub rows: Vec<QueryMarginLoanRecordResponseRowsItem>,
        pub total: i32,
    }
    impl From<&QueryMarginLoanRecordResponse> for QueryMarginLoanRecordResponse {
        fn from(value: &QueryMarginLoanRecordResponse) -> Self {
            value.clone()
        }
    }
    ///QueryMarginLoanRecordResponseRowsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "asset",
    ///    "isolatedSymbol",
    ///    "principal",
    ///    "status",
    ///    "timestamp",
    ///    "txId"
    ///  ],
    ///  "properties": {
    ///    "asset": {
    ///      "type": "string"
    ///    },
    ///    "isolatedSymbol": {
    ///      "type": "string"
    ///    },
    ///    "principal": {
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "type": "string"
    ///    },
    ///    "timestamp": {
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "txId": {
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct QueryMarginLoanRecordResponseRowsItem {
        pub asset: String,
        #[serde(rename = "isolatedSymbol")]
        pub isolated_symbol: String,
        pub principal: String,
        pub status: String,
        pub timestamp: i64,
        #[serde(rename = "txId")]
        pub tx_id: i64,
    }
    impl From<&QueryMarginLoanRecordResponseRowsItem>
    for QueryMarginLoanRecordResponseRowsItem {
        fn from(value: &QueryMarginLoanRecordResponseRowsItem) -> Self {
            value.clone()
        }
    }
    ///QueryMarginRepayResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "rows",
    ///    "total"
    ///  ],
    ///  "properties": {
    ///    "rows": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "amount",
    ///          "asset",
    ///          "interest",
    ///          "isolatedSymbol",
    ///          "principal",
    ///          "status",
    ///          "timestamp",
    ///          "txId"
    ///        ],
    ///        "properties": {
    ///          "amount": {
    ///            "description": "Total amount repaid",
    ///            "examples": [
    ///              "14.00000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "asset": {
    ///            "examples": [
    ///              "BNB"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "interest": {
    ///            "description": "Interest repaid",
    ///            "examples": [
    ///              "0.01866667"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "isolatedSymbol": {
    ///            "description": "Isolated symbol, will not be returned for crossed margin",
    ///            "examples": [
    ///              "BNBUSDT"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "principal": {
    ///            "description": "Principal repaid",
    ///            "examples": [
    ///              "13.98133333"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "status": {
    ///            "description": "One of PENDING (pending execution), CONFIRMED (successfully execution), FAILED (execution failed, nothing happened to your account)",
    ///            "examples": [
    ///              "CONFIRMED"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "timestamp": {
    ///            "examples": [
    ///              1563438204000
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "txId": {
    ///            "examples": [
    ///              2970933056
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "total": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct QueryMarginRepayResponse {
        pub rows: Vec<QueryMarginRepayResponseRowsItem>,
        pub total: i32,
    }
    impl From<&QueryMarginRepayResponse> for QueryMarginRepayResponse {
        fn from(value: &QueryMarginRepayResponse) -> Self {
            value.clone()
        }
    }
    ///QueryMarginRepayResponseRowsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "asset",
    ///    "interest",
    ///    "isolatedSymbol",
    ///    "principal",
    ///    "status",
    ///    "timestamp",
    ///    "txId"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "description": "Total amount repaid",
    ///      "examples": [
    ///        "14.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "asset": {
    ///      "examples": [
    ///        "BNB"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "interest": {
    ///      "description": "Interest repaid",
    ///      "examples": [
    ///        "0.01866667"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "isolatedSymbol": {
    ///      "description": "Isolated symbol, will not be returned for crossed margin",
    ///      "examples": [
    ///        "BNBUSDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "principal": {
    ///      "description": "Principal repaid",
    ///      "examples": [
    ///        "13.98133333"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "description": "One of PENDING (pending execution), CONFIRMED (successfully execution), FAILED (execution failed, nothing happened to your account)",
    ///      "examples": [
    ///        "CONFIRMED"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "timestamp": {
    ///      "examples": [
    ///        1563438204000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "txId": {
    ///      "examples": [
    ///        2970933056
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct QueryMarginRepayResponseRowsItem {
        ///Total amount repaid
        pub amount: String,
        pub asset: String,
        ///Interest repaid
        pub interest: String,
        ///Isolated symbol, will not be returned for crossed margin
        #[serde(rename = "isolatedSymbol")]
        pub isolated_symbol: String,
        ///Principal repaid
        pub principal: String,
        ///One of PENDING (pending execution), CONFIRMED (successfully execution), FAILED (execution failed, nothing happened to your account)
        pub status: String,
        pub timestamp: i64,
        #[serde(rename = "txId")]
        pub tx_id: i64,
    }
    impl From<&QueryMarginRepayResponseRowsItem> for QueryMarginRepayResponseRowsItem {
        fn from(value: &QueryMarginRepayResponseRowsItem) -> Self {
            value.clone()
        }
    }
    ///QuerySubAccountAssetsResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "balances"
    ///  ],
    ///  "properties": {
    ///    "balances": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "asset",
    ///          "free",
    ///          "locked"
    ///        ],
    ///        "properties": {
    ///          "asset": {
    ///            "examples": [
    ///              "BNB"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "free": {
    ///            "examples": [
    ///              "10000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "locked": {
    ///            "examples": [
    ///              "0"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct QuerySubAccountAssetsResponse {
        pub balances: Vec<QuerySubAccountAssetsResponseBalancesItem>,
    }
    impl From<&QuerySubAccountAssetsResponse> for QuerySubAccountAssetsResponse {
        fn from(value: &QuerySubAccountAssetsResponse) -> Self {
            value.clone()
        }
    }
    ///QuerySubAccountAssetsResponseBalancesItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "asset",
    ///    "free",
    ///    "locked"
    ///  ],
    ///  "properties": {
    ///    "asset": {
    ///      "examples": [
    ///        "BNB"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "free": {
    ///      "examples": [
    ///        "10000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "locked": {
    ///      "examples": [
    ///        "0"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct QuerySubAccountAssetsResponseBalancesItem {
        pub asset: String,
        pub free: String,
        pub locked: String,
    }
    impl From<&QuerySubAccountAssetsResponseBalancesItem>
    for QuerySubAccountAssetsResponseBalancesItem {
        fn from(value: &QuerySubAccountAssetsResponseBalancesItem) -> Self {
            value.clone()
        }
    }
    ///QuerySubAccountFuturesAccountSummaryResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/subAccountUSDTFuturesSummary"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/subAccountCOINFuturesSummary"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    #[serde(untagged)]
    pub enum QuerySubAccountFuturesAccountSummaryResponse {
        UsdtFuturesSummary(SubAccountUsdtFuturesSummary),
        CoinFuturesSummary(SubAccountCoinFuturesSummary),
    }
    impl From<&QuerySubAccountFuturesAccountSummaryResponse>
    for QuerySubAccountFuturesAccountSummaryResponse {
        fn from(value: &QuerySubAccountFuturesAccountSummaryResponse) -> Self {
            value.clone()
        }
    }
    impl From<SubAccountUsdtFuturesSummary>
    for QuerySubAccountFuturesAccountSummaryResponse {
        fn from(value: SubAccountUsdtFuturesSummary) -> Self {
            Self::UsdtFuturesSummary(value)
        }
    }
    impl From<SubAccountCoinFuturesSummary>
    for QuerySubAccountFuturesAccountSummaryResponse {
        fn from(value: SubAccountCoinFuturesSummary) -> Self {
            Self::CoinFuturesSummary(value)
        }
    }
    ///QuerySubAccountFuturesAccountV1Response
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "asset",
    ///    "assets",
    ///    "canDeposit",
    ///    "canTrade",
    ///    "canWithdraw",
    ///    "email",
    ///    "feeTier",
    ///    "maxWithdrawAmount",
    ///    "totalInitialMargin",
    ///    "totalMaintenanceMargin",
    ///    "totalMarginBalance",
    ///    "totalOpenOrderInitialMargin",
    ///    "totalPositionInitialMargin",
    ///    "totalUnrealizedProfit",
    ///    "totalWalletBalance",
    ///    "updateTime"
    ///  ],
    ///  "properties": {
    ///    "asset": {
    ///      "examples": [
    ///        "USDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "assets": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "asset",
    ///          "initialMargin",
    ///          "maintenanceMargin",
    ///          "marginBalance",
    ///          "maxWithdrawAmount",
    ///          "openOrderInitialMargin",
    ///          "positionInitialMargin",
    ///          "unrealizedProfit",
    ///          "walletBalance"
    ///        ],
    ///        "properties": {
    ///          "asset": {
    ///            "examples": [
    ///              "USDT"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "initialMargin": {
    ///            "examples": [
    ///              "0.00000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "maintenanceMargin": {
    ///            "examples": [
    ///              "0.00000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "marginBalance": {
    ///            "examples": [
    ///              "0.88308000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "maxWithdrawAmount": {
    ///            "examples": [
    ///              "0.88308000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "openOrderInitialMargin": {
    ///            "examples": [
    ///              "0.00000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "positionInitialMargin": {
    ///            "examples": [
    ///              "0.00000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "unrealizedProfit": {
    ///            "examples": [
    ///              "0.00000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "walletBalance": {
    ///            "examples": [
    ///              "0.88308000"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "canDeposit": {
    ///      "type": "boolean"
    ///    },
    ///    "canTrade": {
    ///      "type": "boolean"
    ///    },
    ///    "canWithdraw": {
    ///      "type": "boolean"
    ///    },
    ///    "email": {
    ///      "examples": [
    ///        "abc@test.com"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "feeTier": {
    ///      "examples": [
    ///        2
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "maxWithdrawAmount": {
    ///      "examples": [
    ///        "0.88308000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalInitialMargin": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalMaintenanceMargin": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalMarginBalance": {
    ///      "examples": [
    ///        "0.88308000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalOpenOrderInitialMargin": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalPositionInitialMargin": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalUnrealizedProfit": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalWalletBalance": {
    ///      "examples": [
    ///        "0.88308000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "updateTime": {
    ///      "examples": [
    ///        1576756674610
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct QuerySubAccountFuturesAccountV1Response {
        pub asset: String,
        pub assets: Vec<QuerySubAccountFuturesAccountV1ResponseAssetsItem>,
        #[serde(rename = "canDeposit")]
        pub can_deposit: bool,
        #[serde(rename = "canTrade")]
        pub can_trade: bool,
        #[serde(rename = "canWithdraw")]
        pub can_withdraw: bool,
        pub email: String,
        #[serde(rename = "feeTier")]
        pub fee_tier: i64,
        #[serde(rename = "maxWithdrawAmount")]
        pub max_withdraw_amount: String,
        #[serde(rename = "totalInitialMargin")]
        pub total_initial_margin: String,
        #[serde(rename = "totalMaintenanceMargin")]
        pub total_maintenance_margin: String,
        #[serde(rename = "totalMarginBalance")]
        pub total_margin_balance: String,
        #[serde(rename = "totalOpenOrderInitialMargin")]
        pub total_open_order_initial_margin: String,
        #[serde(rename = "totalPositionInitialMargin")]
        pub total_position_initial_margin: String,
        #[serde(rename = "totalUnrealizedProfit")]
        pub total_unrealized_profit: String,
        #[serde(rename = "totalWalletBalance")]
        pub total_wallet_balance: String,
        #[serde(rename = "updateTime")]
        pub update_time: i64,
    }
    impl From<&QuerySubAccountFuturesAccountV1Response>
    for QuerySubAccountFuturesAccountV1Response {
        fn from(value: &QuerySubAccountFuturesAccountV1Response) -> Self {
            value.clone()
        }
    }
    ///QuerySubAccountFuturesAccountV1ResponseAssetsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "asset",
    ///    "initialMargin",
    ///    "maintenanceMargin",
    ///    "marginBalance",
    ///    "maxWithdrawAmount",
    ///    "openOrderInitialMargin",
    ///    "positionInitialMargin",
    ///    "unrealizedProfit",
    ///    "walletBalance"
    ///  ],
    ///  "properties": {
    ///    "asset": {
    ///      "examples": [
    ///        "USDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "initialMargin": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "maintenanceMargin": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "marginBalance": {
    ///      "examples": [
    ///        "0.88308000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "maxWithdrawAmount": {
    ///      "examples": [
    ///        "0.88308000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "openOrderInitialMargin": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "positionInitialMargin": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "unrealizedProfit": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "walletBalance": {
    ///      "examples": [
    ///        "0.88308000"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct QuerySubAccountFuturesAccountV1ResponseAssetsItem {
        pub asset: String,
        #[serde(rename = "initialMargin")]
        pub initial_margin: String,
        #[serde(rename = "maintenanceMargin")]
        pub maintenance_margin: String,
        #[serde(rename = "marginBalance")]
        pub margin_balance: String,
        #[serde(rename = "maxWithdrawAmount")]
        pub max_withdraw_amount: String,
        #[serde(rename = "openOrderInitialMargin")]
        pub open_order_initial_margin: String,
        #[serde(rename = "positionInitialMargin")]
        pub position_initial_margin: String,
        #[serde(rename = "unrealizedProfit")]
        pub unrealized_profit: String,
        #[serde(rename = "walletBalance")]
        pub wallet_balance: String,
    }
    impl From<&QuerySubAccountFuturesAccountV1ResponseAssetsItem>
    for QuerySubAccountFuturesAccountV1ResponseAssetsItem {
        fn from(value: &QuerySubAccountFuturesAccountV1ResponseAssetsItem) -> Self {
            value.clone()
        }
    }
    ///QuerySubAccountFuturesAccountV2Response
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/subAccountUSDTFuturesDetails"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/subAccountCOINFuturesDetails"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    #[serde(untagged)]
    pub enum QuerySubAccountFuturesAccountV2Response {
        UsdtFuturesDetails(SubAccountUsdtFuturesDetails),
        CoinFuturesDetails(SubAccountCoinFuturesDetails),
    }
    impl From<&QuerySubAccountFuturesAccountV2Response>
    for QuerySubAccountFuturesAccountV2Response {
        fn from(value: &QuerySubAccountFuturesAccountV2Response) -> Self {
            value.clone()
        }
    }
    impl From<SubAccountUsdtFuturesDetails> for QuerySubAccountFuturesAccountV2Response {
        fn from(value: SubAccountUsdtFuturesDetails) -> Self {
            Self::UsdtFuturesDetails(value)
        }
    }
    impl From<SubAccountCoinFuturesDetails> for QuerySubAccountFuturesAccountV2Response {
        fn from(value: SubAccountCoinFuturesDetails) -> Self {
            Self::CoinFuturesDetails(value)
        }
    }
    ///QuerySubAccountFuturesPositionRiskResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/subAccountUSDTFuturesPositionRisk"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/subAccountCOINFuturesPositionRisk"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    #[serde(untagged)]
    pub enum QuerySubAccountFuturesPositionRiskResponse {
        UsdtFuturesPositionRisk(SubAccountUsdtFuturesPositionRisk),
        CoinFuturesPositionRisk(SubAccountCoinFuturesPositionRisk),
    }
    impl From<&QuerySubAccountFuturesPositionRiskResponse>
    for QuerySubAccountFuturesPositionRiskResponse {
        fn from(value: &QuerySubAccountFuturesPositionRiskResponse) -> Self {
            value.clone()
        }
    }
    impl From<SubAccountUsdtFuturesPositionRisk>
    for QuerySubAccountFuturesPositionRiskResponse {
        fn from(value: SubAccountUsdtFuturesPositionRisk) -> Self {
            Self::UsdtFuturesPositionRisk(value)
        }
    }
    impl From<SubAccountCoinFuturesPositionRisk>
    for QuerySubAccountFuturesPositionRiskResponse {
        fn from(value: SubAccountCoinFuturesPositionRisk) -> Self {
            Self::CoinFuturesPositionRisk(value)
        }
    }
    ///QuerySubAccountSubAccountApiIpRestrictionResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "apiKey",
    ///    "ipList",
    ///    "ipRestrict",
    ///    "updateTime"
    ///  ],
    ///  "properties": {
    ///    "apiKey": {
    ///      "examples": [
    ///        "k5V49ldtn4tszj6W3hystegdfvmGbqDzjmkCtpTvC0G74WhK7yd4rfCTo4lShf"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "ipList": {
    ///      "examples": [
    ///        [
    ///          "69.210.67.14",
    ///          "8.34.21.10"
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string"
    ///      }
    ///    },
    ///    "ipRestrict": {
    ///      "examples": [
    ///        "true"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "updateTime": {
    ///      "examples": [
    ///        1636369557189
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct QuerySubAccountSubAccountApiIpRestrictionResponse {
        #[serde(rename = "apiKey")]
        pub api_key: String,
        #[serde(rename = "ipList")]
        pub ip_list: Vec<String>,
        #[serde(rename = "ipRestrict")]
        pub ip_restrict: String,
        #[serde(rename = "updateTime")]
        pub update_time: i64,
    }
    impl From<&QuerySubAccountSubAccountApiIpRestrictionResponse>
    for QuerySubAccountSubAccountApiIpRestrictionResponse {
        fn from(value: &QuerySubAccountSubAccountApiIpRestrictionResponse) -> Self {
            value.clone()
        }
    }
    ///RateLimitOrderResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "interval",
    ///    "intervalNum",
    ///    "limit",
    ///    "rateLimitType"
    ///  ],
    ///  "properties": {
    ///    "count": {
    ///      "type": "integer",
    ///      "format": "int32"
    ///    },
    ///    "interval": {
    ///      "type": "string"
    ///    },
    ///    "intervalNum": {
    ///      "type": "integer",
    ///      "format": "int32"
    ///    },
    ///    "limit": {
    ///      "type": "integer",
    ///      "format": "int32"
    ///    },
    ///    "rateLimitType": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct RateLimitOrderResponseItem {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub count: Option<i32>,
        pub interval: String,
        #[serde(rename = "intervalNum")]
        pub interval_num: i32,
        pub limit: i32,
        #[serde(rename = "rateLimitType")]
        pub rate_limit_type: String,
    }
    impl From<&RateLimitOrderResponseItem> for RateLimitOrderResponseItem {
        fn from(value: &RateLimitOrderResponseItem) -> Self {
            value.clone()
        }
    }
    ///RebateTaxQueryResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "code",
    ///    "data",
    ///    "status",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "code": {
    ///      "examples": [
    ///        "000000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "data": {
    ///      "type": "object",
    ///      "required": [
    ///        "data",
    ///        "page",
    ///        "totalPageNum",
    ///        "totalRecords"
    ///      ],
    ///      "properties": {
    ///        "data": {
    ///          "type": "array",
    ///          "items": {
    ///            "type": "object",
    ///            "required": [
    ///              "amount",
    ///              "asset",
    ///              "type",
    ///              "updateTime"
    ///            ],
    ///            "properties": {
    ///              "amount": {
    ///                "examples": [
    ///                  "0.0001126"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "asset": {
    ///                "examples": [
    ///                  "USDT"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "type": {
    ///                "description": "rebate type1 is commission rebate2 is referral kickback",
    ///                "examples": [
    ///                  1
    ///                ],
    ///                "type": "integer",
    ///                "format": "int32"
    ///              },
    ///              "updateTime": {
    ///                "examples": [
    ///                  1637651320000
    ///                ],
    ///                "type": "integer",
    ///                "format": "int64"
    ///              }
    ///            }
    ///          }
    ///        },
    ///        "page": {
    ///          "examples": [
    ///            1
    ///          ],
    ///          "type": "integer",
    ///          "format": "int32"
    ///        },
    ///        "totalPageNum": {
    ///          "examples": [
    ///            1
    ///          ],
    ///          "type": "integer",
    ///          "format": "int32"
    ///        },
    ///        "totalRecords": {
    ///          "examples": [
    ///            2
    ///          ],
    ///          "type": "integer",
    ///          "format": "int32"
    ///        }
    ///      }
    ///    },
    ///    "status": {
    ///      "examples": [
    ///        "OK"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "examples": [
    ///        "GENERAL"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct RebateTaxQueryResponse {
        pub code: String,
        pub data: RebateTaxQueryResponseData,
        pub status: String,
        #[serde(rename = "type")]
        pub type_: String,
    }
    impl From<&RebateTaxQueryResponse> for RebateTaxQueryResponse {
        fn from(value: &RebateTaxQueryResponse) -> Self {
            value.clone()
        }
    }
    ///RebateTaxQueryResponseData
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "data",
    ///    "page",
    ///    "totalPageNum",
    ///    "totalRecords"
    ///  ],
    ///  "properties": {
    ///    "data": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "amount",
    ///          "asset",
    ///          "type",
    ///          "updateTime"
    ///        ],
    ///        "properties": {
    ///          "amount": {
    ///            "examples": [
    ///              "0.0001126"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "asset": {
    ///            "examples": [
    ///              "USDT"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "type": {
    ///            "description": "rebate type1 is commission rebate2 is referral kickback",
    ///            "examples": [
    ///              1
    ///            ],
    ///            "type": "integer",
    ///            "format": "int32"
    ///          },
    ///          "updateTime": {
    ///            "examples": [
    ///              1637651320000
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "page": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    },
    ///    "totalPageNum": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    },
    ///    "totalRecords": {
    ///      "examples": [
    ///        2
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct RebateTaxQueryResponseData {
        pub data: Vec<RebateTaxQueryResponseDataDataItem>,
        pub page: i32,
        #[serde(rename = "totalPageNum")]
        pub total_page_num: i32,
        #[serde(rename = "totalRecords")]
        pub total_records: i32,
    }
    impl From<&RebateTaxQueryResponseData> for RebateTaxQueryResponseData {
        fn from(value: &RebateTaxQueryResponseData) -> Self {
            value.clone()
        }
    }
    ///RebateTaxQueryResponseDataDataItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "asset",
    ///    "type",
    ///    "updateTime"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "examples": [
    ///        "0.0001126"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "asset": {
    ///      "examples": [
    ///        "USDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "description": "rebate type1 is commission rebate2 is referral kickback",
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    },
    ///    "updateTime": {
    ///      "examples": [
    ///        1637651320000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct RebateTaxQueryResponseDataDataItem {
        pub amount: String,
        pub asset: String,
        ///rebate type1 is commission rebate2 is referral kickback
        #[serde(rename = "type")]
        pub type_: i32,
        #[serde(rename = "updateTime")]
        pub update_time: i64,
    }
    impl From<&RebateTaxQueryResponseDataDataItem>
    for RebateTaxQueryResponseDataDataItem {
        fn from(value: &RebateTaxQueryResponseDataDataItem) -> Self {
            value.clone()
        }
    }
    ///RepaymentInfo
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "collateralCoin",
    ///    "currentLTV",
    ///    "loanCoin",
    ///    "remainingCollateral",
    ///    "remainingInterest",
    ///    "remainingPrincipal",
    ///    "repayStatus"
    ///  ],
    ///  "properties": {
    ///    "collateralCoin": {
    ///      "examples": [
    ///        "BNB"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "currentLTV": {
    ///      "examples": [
    ///        "0.25"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "loanCoin": {
    ///      "examples": [
    ///        "BUSD"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "remainingCollateral": {
    ///      "examples": [
    ///        "5.253"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "remainingInterest": {
    ///      "examples": [
    ///        "0"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "remainingPrincipal": {
    ///      "examples": [
    ///        "100.5"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "repayStatus": {
    ///      "examples": [
    ///        "Repaying"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct RepaymentInfo {
        #[serde(rename = "collateralCoin")]
        pub collateral_coin: String,
        #[serde(rename = "currentLTV")]
        pub current_ltv: String,
        #[serde(rename = "loanCoin")]
        pub loan_coin: String,
        #[serde(rename = "remainingCollateral")]
        pub remaining_collateral: String,
        #[serde(rename = "remainingInterest")]
        pub remaining_interest: String,
        #[serde(rename = "remainingPrincipal")]
        pub remaining_principal: String,
        #[serde(rename = "repayStatus")]
        pub repay_status: String,
    }
    impl From<&RepaymentInfo> for RepaymentInfo {
        fn from(value: &RepaymentInfo) -> Self {
            value.clone()
        }
    }
    ///RepaymentInfo2
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "collateralCoin",
    ///    "loanCoin",
    ///    "repayStatus"
    ///  ],
    ///  "properties": {
    ///    "collateralCoin": {
    ///      "examples": [
    ///        "BNB"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "loanCoin": {
    ///      "examples": [
    ///        "BUSD"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "repayStatus": {
    ///      "examples": [
    ///        "Repaying"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct RepaymentInfo2 {
        #[serde(rename = "collateralCoin")]
        pub collateral_coin: String,
        #[serde(rename = "loanCoin")]
        pub loan_coin: String,
        #[serde(rename = "repayStatus")]
        pub repay_status: String,
    }
    impl From<&RepaymentInfo2> for RepaymentInfo2 {
        fn from(value: &RepaymentInfo2) -> Self {
            value.clone()
        }
    }
    ///ReplaceOrderCancelRestrictions
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "ONLY_NEW"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "ONLY_NEW",
    ///    "ONLY_PARTIALLY_FILLED"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum ReplaceOrderCancelRestrictions {
        #[serde(rename = "ONLY_NEW")]
        OnlyNew,
        #[serde(rename = "ONLY_PARTIALLY_FILLED")]
        OnlyPartiallyFilled,
    }
    impl From<&ReplaceOrderCancelRestrictions> for ReplaceOrderCancelRestrictions {
        fn from(value: &ReplaceOrderCancelRestrictions) -> Self {
            value.clone()
        }
    }
    impl ToString for ReplaceOrderCancelRestrictions {
        fn to_string(&self) -> String {
            match *self {
                Self::OnlyNew => "ONLY_NEW".to_string(),
                Self::OnlyPartiallyFilled => "ONLY_PARTIALLY_FILLED".to_string(),
            }
        }
    }
    impl std::str::FromStr for ReplaceOrderCancelRestrictions {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "ONLY_NEW" => Ok(Self::OnlyNew),
                "ONLY_PARTIALLY_FILLED" => Ok(Self::OnlyPartiallyFilled),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for ReplaceOrderCancelRestrictions {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for ReplaceOrderCancelRestrictions {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for ReplaceOrderCancelRestrictions {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///ReplaceOrderNewOrderRespType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "ACK",
    ///    "RESULT",
    ///    "FULL"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum ReplaceOrderNewOrderRespType {
        #[serde(rename = "ACK")]
        Ack,
        #[serde(rename = "RESULT")]
        Result,
        #[serde(rename = "FULL")]
        Full,
    }
    impl From<&ReplaceOrderNewOrderRespType> for ReplaceOrderNewOrderRespType {
        fn from(value: &ReplaceOrderNewOrderRespType) -> Self {
            value.clone()
        }
    }
    impl ToString for ReplaceOrderNewOrderRespType {
        fn to_string(&self) -> String {
            match *self {
                Self::Ack => "ACK".to_string(),
                Self::Result => "RESULT".to_string(),
                Self::Full => "FULL".to_string(),
            }
        }
    }
    impl std::str::FromStr for ReplaceOrderNewOrderRespType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "ACK" => Ok(Self::Ack),
                "RESULT" => Ok(Self::Result),
                "FULL" => Ok(Self::Full),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for ReplaceOrderNewOrderRespType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for ReplaceOrderNewOrderRespType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for ReplaceOrderNewOrderRespType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///ReplaceOrderResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "cancelResponse",
    ///    "cancelResult",
    ///    "newOrderResponse",
    ///    "newOrderResult"
    ///  ],
    ///  "properties": {
    ///    "cancelResponse": {
    ///      "type": "object",
    ///      "required": [
    ///        "clientOrderId",
    ///        "cummulativeQuoteQty",
    ///        "executedQty",
    ///        "orderId",
    ///        "orderListId",
    ///        "origClientOrderId",
    ///        "origQty",
    ///        "price",
    ///        "selfTradePreventionMode",
    ///        "side",
    ///        "status",
    ///        "symbol",
    ///        "timeInForce",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "clientOrderId": {
    ///          "examples": [
    ///            "osxN3JXAtJvKvCqGeMWMVR"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "cummulativeQuoteQty": {
    ///          "examples": [
    ///            "0.00000000"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "executedQty": {
    ///          "examples": [
    ///            "0.00000000"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "orderId": {
    ///          "examples": [
    ///            9
    ///          ],
    ///          "type": "integer",
    ///          "format": "int64"
    ///        },
    ///        "orderListId": {
    ///          "examples": [
    ///            -1
    ///          ],
    ///          "type": "integer",
    ///          "format": "int64"
    ///        },
    ///        "origClientOrderId": {
    ///          "examples": [
    ///            "DnLo3vTAQcjha43lAZhZ0y"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "origQty": {
    ///          "examples": [
    ///            "0.000100"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "price": {
    ///          "examples": [
    ///            "0.01000000"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "selfTradePreventionMode": {
    ///          "examples": [
    ///            "NONE"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "side": {
    ///          "examples": [
    ///            "SELL"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "status": {
    ///          "examples": [
    ///            "CANCELED"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "symbol": {
    ///          "examples": [
    ///            "BTCUSDT"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "timeInForce": {
    ///          "examples": [
    ///            "GTC"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "transactTime": {
    ///          "examples": [
    ///            1507725176595
    ///          ],
    ///          "type": "integer",
    ///          "format": "int64"
    ///        },
    ///        "type": {
    ///          "examples": [
    ///            "LIMIT"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "cancelResult": {
    ///      "examples": [
    ///        "SUCCESS"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "newOrderResponse": {
    ///      "type": "object",
    ///      "required": [
    ///        "clientOrderId",
    ///        "cummulativeQuoteQty",
    ///        "executedQty",
    ///        "fills",
    ///        "orderId",
    ///        "orderListId",
    ///        "origQty",
    ///        "price",
    ///        "selfTradePreventionMode",
    ///        "side",
    ///        "status",
    ///        "symbol",
    ///        "timeInForce",
    ///        "transactTime",
    ///        "type",
    ///        "workingTime"
    ///      ],
    ///      "properties": {
    ///        "clientOrderId": {
    ///          "examples": [
    ///            "wOceeeOzNORyLiQfw7jd8S"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "cummulativeQuoteQty": {
    ///          "examples": [
    ///            "0.00000000"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "executedQty": {
    ///          "examples": [
    ///            "0.00000000"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "fills": {
    ///          "type": "array",
    ///          "items": {
    ///            "type": "string"
    ///          },
    ///          "maxItems": 0
    ///        },
    ///        "orderId": {
    ///          "examples": [
    ///            10
    ///          ],
    ///          "type": "integer",
    ///          "format": "int64"
    ///        },
    ///        "orderListId": {
    ///          "examples": [
    ///            -1
    ///          ],
    ///          "type": "integer",
    ///          "format": "int64"
    ///        },
    ///        "origQty": {
    ///          "examples": [
    ///            "0.040000"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "price": {
    ///          "examples": [
    ///            "0.02000000"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "selfTradePreventionMode": {
    ///          "examples": [
    ///            "NONE"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "side": {
    ///          "examples": [
    ///            "BUY"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "status": {
    ///          "examples": [
    ///            "NEW"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "symbol": {
    ///          "examples": [
    ///            "BTCUSDT"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "timeInForce": {
    ///          "examples": [
    ///            "GTC"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "transactTime": {
    ///          "examples": [
    ///            1652928801803
    ///          ],
    ///          "type": "integer",
    ///          "format": "int64"
    ///        },
    ///        "type": {
    ///          "examples": [
    ///            "LIMIT"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "workingTime": {
    ///          "examples": [
    ///            1669277163808
    ///          ],
    ///          "type": "integer",
    ///          "format": "int64"
    ///        }
    ///      }
    ///    },
    ///    "newOrderResult": {
    ///      "examples": [
    ///        "SUCCESS"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct ReplaceOrderResponse {
        #[serde(rename = "cancelResponse")]
        pub cancel_response: ReplaceOrderResponseCancelResponse,
        #[serde(rename = "cancelResult")]
        pub cancel_result: String,
        #[serde(rename = "newOrderResponse")]
        pub new_order_response: ReplaceOrderResponseNewOrderResponse,
        #[serde(rename = "newOrderResult")]
        pub new_order_result: String,
    }
    impl From<&ReplaceOrderResponse> for ReplaceOrderResponse {
        fn from(value: &ReplaceOrderResponse) -> Self {
            value.clone()
        }
    }
    ///ReplaceOrderResponseCancelResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "clientOrderId",
    ///    "cummulativeQuoteQty",
    ///    "executedQty",
    ///    "orderId",
    ///    "orderListId",
    ///    "origClientOrderId",
    ///    "origQty",
    ///    "price",
    ///    "selfTradePreventionMode",
    ///    "side",
    ///    "status",
    ///    "symbol",
    ///    "timeInForce",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "clientOrderId": {
    ///      "examples": [
    ///        "osxN3JXAtJvKvCqGeMWMVR"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "cummulativeQuoteQty": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "executedQty": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "orderId": {
    ///      "examples": [
    ///        9
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "orderListId": {
    ///      "examples": [
    ///        -1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "origClientOrderId": {
    ///      "examples": [
    ///        "DnLo3vTAQcjha43lAZhZ0y"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "origQty": {
    ///      "examples": [
    ///        "0.000100"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "price": {
    ///      "examples": [
    ///        "0.01000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "selfTradePreventionMode": {
    ///      "examples": [
    ///        "NONE"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "side": {
    ///      "examples": [
    ///        "SELL"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "examples": [
    ///        "CANCELED"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "symbol": {
    ///      "examples": [
    ///        "BTCUSDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "timeInForce": {
    ///      "examples": [
    ///        "GTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "transactTime": {
    ///      "examples": [
    ///        1507725176595
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "type": {
    ///      "examples": [
    ///        "LIMIT"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct ReplaceOrderResponseCancelResponse {
        #[serde(rename = "clientOrderId")]
        pub client_order_id: String,
        #[serde(rename = "cummulativeQuoteQty")]
        pub cummulative_quote_qty: String,
        #[serde(rename = "executedQty")]
        pub executed_qty: String,
        #[serde(rename = "orderId")]
        pub order_id: i64,
        #[serde(rename = "orderListId")]
        pub order_list_id: i64,
        #[serde(rename = "origClientOrderId")]
        pub orig_client_order_id: String,
        #[serde(rename = "origQty")]
        pub orig_qty: String,
        pub price: String,
        #[serde(rename = "selfTradePreventionMode")]
        pub self_trade_prevention_mode: String,
        pub side: String,
        pub status: String,
        pub symbol: String,
        #[serde(rename = "timeInForce")]
        pub time_in_force: String,
        #[serde(
            rename = "transactTime",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub transact_time: Option<i64>,
        #[serde(rename = "type")]
        pub type_: String,
    }
    impl From<&ReplaceOrderResponseCancelResponse>
    for ReplaceOrderResponseCancelResponse {
        fn from(value: &ReplaceOrderResponseCancelResponse) -> Self {
            value.clone()
        }
    }
    ///ReplaceOrderResponseNewOrderResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "clientOrderId",
    ///    "cummulativeQuoteQty",
    ///    "executedQty",
    ///    "fills",
    ///    "orderId",
    ///    "orderListId",
    ///    "origQty",
    ///    "price",
    ///    "selfTradePreventionMode",
    ///    "side",
    ///    "status",
    ///    "symbol",
    ///    "timeInForce",
    ///    "transactTime",
    ///    "type",
    ///    "workingTime"
    ///  ],
    ///  "properties": {
    ///    "clientOrderId": {
    ///      "examples": [
    ///        "wOceeeOzNORyLiQfw7jd8S"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "cummulativeQuoteQty": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "executedQty": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "fills": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string"
    ///      },
    ///      "maxItems": 0
    ///    },
    ///    "orderId": {
    ///      "examples": [
    ///        10
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "orderListId": {
    ///      "examples": [
    ///        -1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "origQty": {
    ///      "examples": [
    ///        "0.040000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "price": {
    ///      "examples": [
    ///        "0.02000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "selfTradePreventionMode": {
    ///      "examples": [
    ///        "NONE"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "side": {
    ///      "examples": [
    ///        "BUY"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "examples": [
    ///        "NEW"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "symbol": {
    ///      "examples": [
    ///        "BTCUSDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "timeInForce": {
    ///      "examples": [
    ///        "GTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "transactTime": {
    ///      "examples": [
    ///        1652928801803
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "type": {
    ///      "examples": [
    ///        "LIMIT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "workingTime": {
    ///      "examples": [
    ///        1669277163808
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct ReplaceOrderResponseNewOrderResponse {
        #[serde(rename = "clientOrderId")]
        pub client_order_id: String,
        #[serde(rename = "cummulativeQuoteQty")]
        pub cummulative_quote_qty: String,
        #[serde(rename = "executedQty")]
        pub executed_qty: String,
        pub fills: Vec<String>,
        #[serde(rename = "orderId")]
        pub order_id: i64,
        #[serde(rename = "orderListId")]
        pub order_list_id: i64,
        #[serde(rename = "origQty")]
        pub orig_qty: String,
        pub price: String,
        #[serde(rename = "selfTradePreventionMode")]
        pub self_trade_prevention_mode: String,
        pub side: String,
        pub status: String,
        pub symbol: String,
        #[serde(rename = "timeInForce")]
        pub time_in_force: String,
        #[serde(rename = "transactTime")]
        pub transact_time: i64,
        #[serde(rename = "type")]
        pub type_: String,
        #[serde(rename = "workingTime")]
        pub working_time: i64,
    }
    impl From<&ReplaceOrderResponseNewOrderResponse>
    for ReplaceOrderResponseNewOrderResponse {
        fn from(value: &ReplaceOrderResponseNewOrderResponse) -> Self {
            value.clone()
        }
    }
    ///ReplaceOrderSelfTradePreventionMode
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "EXPIRE_TAKER"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "EXPIRE_TAKER",
    ///    "EXPIRE_MAKER",
    ///    "EXPIRE_BOTH",
    ///    "NONE"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum ReplaceOrderSelfTradePreventionMode {
        #[serde(rename = "EXPIRE_TAKER")]
        ExpireTaker,
        #[serde(rename = "EXPIRE_MAKER")]
        ExpireMaker,
        #[serde(rename = "EXPIRE_BOTH")]
        ExpireBoth,
        #[serde(rename = "NONE")]
        None,
    }
    impl From<&ReplaceOrderSelfTradePreventionMode>
    for ReplaceOrderSelfTradePreventionMode {
        fn from(value: &ReplaceOrderSelfTradePreventionMode) -> Self {
            value.clone()
        }
    }
    impl ToString for ReplaceOrderSelfTradePreventionMode {
        fn to_string(&self) -> String {
            match *self {
                Self::ExpireTaker => "EXPIRE_TAKER".to_string(),
                Self::ExpireMaker => "EXPIRE_MAKER".to_string(),
                Self::ExpireBoth => "EXPIRE_BOTH".to_string(),
                Self::None => "NONE".to_string(),
            }
        }
    }
    impl std::str::FromStr for ReplaceOrderSelfTradePreventionMode {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "EXPIRE_TAKER" => Ok(Self::ExpireTaker),
                "EXPIRE_MAKER" => Ok(Self::ExpireMaker),
                "EXPIRE_BOTH" => Ok(Self::ExpireBoth),
                "NONE" => Ok(Self::None),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for ReplaceOrderSelfTradePreventionMode {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for ReplaceOrderSelfTradePreventionMode {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for ReplaceOrderSelfTradePreventionMode {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///ReplaceOrderSide
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "SELL"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "SELL",
    ///    "BUY"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum ReplaceOrderSide {
        #[serde(rename = "SELL")]
        Sell,
        #[serde(rename = "BUY")]
        Buy,
    }
    impl From<&ReplaceOrderSide> for ReplaceOrderSide {
        fn from(value: &ReplaceOrderSide) -> Self {
            value.clone()
        }
    }
    impl ToString for ReplaceOrderSide {
        fn to_string(&self) -> String {
            match *self {
                Self::Sell => "SELL".to_string(),
                Self::Buy => "BUY".to_string(),
            }
        }
    }
    impl std::str::FromStr for ReplaceOrderSide {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "SELL" => Ok(Self::Sell),
                "BUY" => Ok(Self::Buy),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for ReplaceOrderSide {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for ReplaceOrderSide {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for ReplaceOrderSide {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///ReplaceOrderTimeInForce
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "GTC"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "GTC",
    ///    "IOC",
    ///    "FOK"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum ReplaceOrderTimeInForce {
        #[serde(rename = "GTC")]
        Gtc,
        #[serde(rename = "IOC")]
        Ioc,
        #[serde(rename = "FOK")]
        Fok,
    }
    impl From<&ReplaceOrderTimeInForce> for ReplaceOrderTimeInForce {
        fn from(value: &ReplaceOrderTimeInForce) -> Self {
            value.clone()
        }
    }
    impl ToString for ReplaceOrderTimeInForce {
        fn to_string(&self) -> String {
            match *self {
                Self::Gtc => "GTC".to_string(),
                Self::Ioc => "IOC".to_string(),
                Self::Fok => "FOK".to_string(),
            }
        }
    }
    impl std::str::FromStr for ReplaceOrderTimeInForce {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "GTC" => Ok(Self::Gtc),
                "IOC" => Ok(Self::Ioc),
                "FOK" => Ok(Self::Fok),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for ReplaceOrderTimeInForce {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for ReplaceOrderTimeInForce {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for ReplaceOrderTimeInForce {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///ReplaceOrderType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "LIMIT"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "LIMIT",
    ///    "MARKET",
    ///    "STOP_LOSS",
    ///    "STOP_LOSS_LIMIT",
    ///    "TAKE_PROFIT",
    ///    "TAKE_PROFIT_LIMIT",
    ///    "LIMIT_MAKER"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum ReplaceOrderType {
        #[serde(rename = "LIMIT")]
        Limit,
        #[serde(rename = "MARKET")]
        Market,
        #[serde(rename = "STOP_LOSS")]
        StopLoss,
        #[serde(rename = "STOP_LOSS_LIMIT")]
        StopLossLimit,
        #[serde(rename = "TAKE_PROFIT")]
        TakeProfit,
        #[serde(rename = "TAKE_PROFIT_LIMIT")]
        TakeProfitLimit,
        #[serde(rename = "LIMIT_MAKER")]
        LimitMaker,
    }
    impl From<&ReplaceOrderType> for ReplaceOrderType {
        fn from(value: &ReplaceOrderType) -> Self {
            value.clone()
        }
    }
    impl ToString for ReplaceOrderType {
        fn to_string(&self) -> String {
            match *self {
                Self::Limit => "LIMIT".to_string(),
                Self::Market => "MARKET".to_string(),
                Self::StopLoss => "STOP_LOSS".to_string(),
                Self::StopLossLimit => "STOP_LOSS_LIMIT".to_string(),
                Self::TakeProfit => "TAKE_PROFIT".to_string(),
                Self::TakeProfitLimit => "TAKE_PROFIT_LIMIT".to_string(),
                Self::LimitMaker => "LIMIT_MAKER".to_string(),
            }
        }
    }
    impl std::str::FromStr for ReplaceOrderType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "LIMIT" => Ok(Self::Limit),
                "MARKET" => Ok(Self::Market),
                "STOP_LOSS" => Ok(Self::StopLoss),
                "STOP_LOSS_LIMIT" => Ok(Self::StopLossLimit),
                "TAKE_PROFIT" => Ok(Self::TakeProfit),
                "TAKE_PROFIT_LIMIT" => Ok(Self::TakeProfitLimit),
                "LIMIT_MAKER" => Ok(Self::LimitMaker),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for ReplaceOrderType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for ReplaceOrderType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for ReplaceOrderType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///SendMarginQueryOcoIsIsolated
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "TRUE",
    ///    "FALSE"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum SendMarginQueryOcoIsIsolated {
        #[serde(rename = "TRUE")]
        True,
        #[serde(rename = "FALSE")]
        False,
    }
    impl From<&SendMarginQueryOcoIsIsolated> for SendMarginQueryOcoIsIsolated {
        fn from(value: &SendMarginQueryOcoIsIsolated) -> Self {
            value.clone()
        }
    }
    impl ToString for SendMarginQueryOcoIsIsolated {
        fn to_string(&self) -> String {
            match *self {
                Self::True => "TRUE".to_string(),
                Self::False => "FALSE".to_string(),
            }
        }
    }
    impl std::str::FromStr for SendMarginQueryOcoIsIsolated {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "TRUE" => Ok(Self::True),
                "FALSE" => Ok(Self::False),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for SendMarginQueryOcoIsIsolated {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for SendMarginQueryOcoIsIsolated {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for SendMarginQueryOcoIsIsolated {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///SendMarginQueryOcoNewOrderRespType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "ACK",
    ///    "RESULT",
    ///    "FULL"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum SendMarginQueryOcoNewOrderRespType {
        #[serde(rename = "ACK")]
        Ack,
        #[serde(rename = "RESULT")]
        Result,
        #[serde(rename = "FULL")]
        Full,
    }
    impl From<&SendMarginQueryOcoNewOrderRespType>
    for SendMarginQueryOcoNewOrderRespType {
        fn from(value: &SendMarginQueryOcoNewOrderRespType) -> Self {
            value.clone()
        }
    }
    impl ToString for SendMarginQueryOcoNewOrderRespType {
        fn to_string(&self) -> String {
            match *self {
                Self::Ack => "ACK".to_string(),
                Self::Result => "RESULT".to_string(),
                Self::Full => "FULL".to_string(),
            }
        }
    }
    impl std::str::FromStr for SendMarginQueryOcoNewOrderRespType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "ACK" => Ok(Self::Ack),
                "RESULT" => Ok(Self::Result),
                "FULL" => Ok(Self::Full),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for SendMarginQueryOcoNewOrderRespType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for SendMarginQueryOcoNewOrderRespType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for SendMarginQueryOcoNewOrderRespType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///SendMarginQueryOcoResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "contingencyType",
    ///    "isIsolated",
    ///    "listClientOrderId",
    ///    "listOrderStatus",
    ///    "listStatusType",
    ///    "marginBuyBorrowAmount",
    ///    "marginBuyBorrowAsset",
    ///    "orderListId",
    ///    "orderReports",
    ///    "orders",
    ///    "symbol",
    ///    "transactionTime"
    ///  ],
    ///  "properties": {
    ///    "contingencyType": {
    ///      "examples": [
    ///        "OCO"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "isIsolated": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "listClientOrderId": {
    ///      "examples": [
    ///        "JYVpp3F0f5CAG15DhtrqLp"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "listOrderStatus": {
    ///      "examples": [
    ///        "EXECUTING"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "listStatusType": {
    ///      "examples": [
    ///        "EXEC_STARTED"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "marginBuyBorrowAmount": {
    ///      "description": "will not return if no margin trade happens",
    ///      "examples": [
    ///        "5"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "marginBuyBorrowAsset": {
    ///      "description": "will not return if no margin trade happens",
    ///      "examples": [
    ///        "BTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "orderListId": {
    ///      "examples": [
    ///        0
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "orderReports": {
    ///      "examples": [
    ///        [
    ///          {
    ///            "clientOrderId": "Kk7sqHb9J6mJWTMDVW7Vos",
    ///            "cummulativeQuoteQty": "0.000000",
    ///            "executedQty": "0.000000",
    ///            "orderId": 2,
    ///            "orderListId": 0,
    ///            "origQty": "0.624363",
    ///            "price": "0.000000",
    ///            "side": "BUY",
    ///            "status": "NEW",
    ///            "stopPrice": "0.960664",
    ///            "symbol": "LTCBTC",
    ///            "timeInForce": "GTC",
    ///            "transactTime": 1563417480525,
    ///            "type": "STOP_LOSS"
    ///          },
    ///          {
    ///            "clientOrderId": "xTXKaGYd4bluPVp78IVRvl",
    ///            "cummulativeQuoteQty": "0.000000",
    ///            "executedQty": "0.000000",
    ///            "orderId": 3,
    ///            "orderListId": 0,
    ///            "origQty": "0.624363",
    ///            "price": "0.036435",
    ///            "side": "BUY",
    ///            "status": "NEW",
    ///            "symbol": "LTCBTC",
    ///            "timeInForce": "GTC",
    ///            "transactTime": 1563417480525,
    ///            "type": "LIMIT_MAKER"
    ///          }
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "clientOrderId",
    ///          "cummulativeQuoteQty",
    ///          "executedQty",
    ///          "orderId",
    ///          "orderListId",
    ///          "origQty",
    ///          "price",
    ///          "side",
    ///          "status",
    ///          "stopPrice",
    ///          "symbol",
    ///          "timeInForce",
    ///          "transactTime",
    ///          "type"
    ///        ],
    ///        "properties": {
    ///          "clientOrderId": {
    ///            "type": "string"
    ///          },
    ///          "cummulativeQuoteQty": {
    ///            "type": "string"
    ///          },
    ///          "executedQty": {
    ///            "type": "string"
    ///          },
    ///          "orderId": {
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "orderListId": {
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "origQty": {
    ///            "type": "string"
    ///          },
    ///          "price": {
    ///            "type": "string"
    ///          },
    ///          "side": {
    ///            "type": "string"
    ///          },
    ///          "status": {
    ///            "type": "string"
    ///          },
    ///          "stopPrice": {
    ///            "type": "string"
    ///          },
    ///          "symbol": {
    ///            "type": "string"
    ///          },
    ///          "timeInForce": {
    ///            "type": "string"
    ///          },
    ///          "transactTime": {
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "type": {
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "orders": {
    ///      "examples": [
    ///        [
    ///          {
    ///            "clientOrderId": "Kk7sqHb9J6mJWTMDVW7Vos",
    ///            "orderId": 2,
    ///            "symbol": "LTCBTC"
    ///          },
    ///          {
    ///            "clientOrderId": "xTXKaGYd4bluPVp78IVRvl",
    ///            "orderId": 3,
    ///            "symbol": "LTCBTC"
    ///          }
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "clientOrderId",
    ///          "orderId",
    ///          "symbol"
    ///        ],
    ///        "properties": {
    ///          "clientOrderId": {
    ///            "type": "string"
    ///          },
    ///          "orderId": {
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "symbol": {
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "symbol": {
    ///      "examples": [
    ///        "LTCBTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "transactionTime": {
    ///      "examples": [
    ///        1563417480525
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SendMarginQueryOcoResponse {
        #[serde(rename = "contingencyType")]
        pub contingency_type: String,
        #[serde(rename = "isIsolated")]
        pub is_isolated: bool,
        #[serde(rename = "listClientOrderId")]
        pub list_client_order_id: String,
        #[serde(rename = "listOrderStatus")]
        pub list_order_status: String,
        #[serde(rename = "listStatusType")]
        pub list_status_type: String,
        ///will not return if no margin trade happens
        #[serde(rename = "marginBuyBorrowAmount")]
        pub margin_buy_borrow_amount: String,
        ///will not return if no margin trade happens
        #[serde(rename = "marginBuyBorrowAsset")]
        pub margin_buy_borrow_asset: String,
        #[serde(rename = "orderListId")]
        pub order_list_id: i64,
        #[serde(rename = "orderReports")]
        pub order_reports: Vec<SendMarginQueryOcoResponseOrderReportsItem>,
        pub orders: Vec<SendMarginQueryOcoResponseOrdersItem>,
        pub symbol: String,
        #[serde(rename = "transactionTime")]
        pub transaction_time: i64,
    }
    impl From<&SendMarginQueryOcoResponse> for SendMarginQueryOcoResponse {
        fn from(value: &SendMarginQueryOcoResponse) -> Self {
            value.clone()
        }
    }
    ///SendMarginQueryOcoResponseOrderReportsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "clientOrderId",
    ///    "cummulativeQuoteQty",
    ///    "executedQty",
    ///    "orderId",
    ///    "orderListId",
    ///    "origQty",
    ///    "price",
    ///    "side",
    ///    "status",
    ///    "stopPrice",
    ///    "symbol",
    ///    "timeInForce",
    ///    "transactTime",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "clientOrderId": {
    ///      "type": "string"
    ///    },
    ///    "cummulativeQuoteQty": {
    ///      "type": "string"
    ///    },
    ///    "executedQty": {
    ///      "type": "string"
    ///    },
    ///    "orderId": {
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "orderListId": {
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "origQty": {
    ///      "type": "string"
    ///    },
    ///    "price": {
    ///      "type": "string"
    ///    },
    ///    "side": {
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "type": "string"
    ///    },
    ///    "stopPrice": {
    ///      "type": "string"
    ///    },
    ///    "symbol": {
    ///      "type": "string"
    ///    },
    ///    "timeInForce": {
    ///      "type": "string"
    ///    },
    ///    "transactTime": {
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "type": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SendMarginQueryOcoResponseOrderReportsItem {
        #[serde(rename = "clientOrderId")]
        pub client_order_id: String,
        #[serde(rename = "cummulativeQuoteQty")]
        pub cummulative_quote_qty: String,
        #[serde(rename = "executedQty")]
        pub executed_qty: String,
        #[serde(rename = "orderId")]
        pub order_id: i64,
        #[serde(rename = "orderListId")]
        pub order_list_id: i64,
        #[serde(rename = "origQty")]
        pub orig_qty: String,
        pub price: String,
        pub side: String,
        pub status: String,
        #[serde(rename = "stopPrice")]
        pub stop_price: String,
        pub symbol: String,
        #[serde(rename = "timeInForce")]
        pub time_in_force: String,
        #[serde(rename = "transactTime")]
        pub transact_time: i64,
        #[serde(rename = "type")]
        pub type_: String,
    }
    impl From<&SendMarginQueryOcoResponseOrderReportsItem>
    for SendMarginQueryOcoResponseOrderReportsItem {
        fn from(value: &SendMarginQueryOcoResponseOrderReportsItem) -> Self {
            value.clone()
        }
    }
    ///SendMarginQueryOcoResponseOrdersItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "clientOrderId",
    ///    "orderId",
    ///    "symbol"
    ///  ],
    ///  "properties": {
    ///    "clientOrderId": {
    ///      "type": "string"
    ///    },
    ///    "orderId": {
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "symbol": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SendMarginQueryOcoResponseOrdersItem {
        #[serde(rename = "clientOrderId")]
        pub client_order_id: String,
        #[serde(rename = "orderId")]
        pub order_id: i64,
        pub symbol: String,
    }
    impl From<&SendMarginQueryOcoResponseOrdersItem>
    for SendMarginQueryOcoResponseOrdersItem {
        fn from(value: &SendMarginQueryOcoResponseOrdersItem) -> Self {
            value.clone()
        }
    }
    ///SendMarginQueryOcoSelfTradePreventionMode
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "EXPIRE_TAKER"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "EXPIRE_TAKER",
    ///    "EXPIRE_MAKER",
    ///    "EXPIRE_BOTH",
    ///    "NONE"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum SendMarginQueryOcoSelfTradePreventionMode {
        #[serde(rename = "EXPIRE_TAKER")]
        ExpireTaker,
        #[serde(rename = "EXPIRE_MAKER")]
        ExpireMaker,
        #[serde(rename = "EXPIRE_BOTH")]
        ExpireBoth,
        #[serde(rename = "NONE")]
        None,
    }
    impl From<&SendMarginQueryOcoSelfTradePreventionMode>
    for SendMarginQueryOcoSelfTradePreventionMode {
        fn from(value: &SendMarginQueryOcoSelfTradePreventionMode) -> Self {
            value.clone()
        }
    }
    impl ToString for SendMarginQueryOcoSelfTradePreventionMode {
        fn to_string(&self) -> String {
            match *self {
                Self::ExpireTaker => "EXPIRE_TAKER".to_string(),
                Self::ExpireMaker => "EXPIRE_MAKER".to_string(),
                Self::ExpireBoth => "EXPIRE_BOTH".to_string(),
                Self::None => "NONE".to_string(),
            }
        }
    }
    impl std::str::FromStr for SendMarginQueryOcoSelfTradePreventionMode {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "EXPIRE_TAKER" => Ok(Self::ExpireTaker),
                "EXPIRE_MAKER" => Ok(Self::ExpireMaker),
                "EXPIRE_BOTH" => Ok(Self::ExpireBoth),
                "NONE" => Ok(Self::None),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for SendMarginQueryOcoSelfTradePreventionMode {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for SendMarginQueryOcoSelfTradePreventionMode {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for SendMarginQueryOcoSelfTradePreventionMode {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///SendMarginQueryOcoSide
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "SELL"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "SELL",
    ///    "BUY"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum SendMarginQueryOcoSide {
        #[serde(rename = "SELL")]
        Sell,
        #[serde(rename = "BUY")]
        Buy,
    }
    impl From<&SendMarginQueryOcoSide> for SendMarginQueryOcoSide {
        fn from(value: &SendMarginQueryOcoSide) -> Self {
            value.clone()
        }
    }
    impl ToString for SendMarginQueryOcoSide {
        fn to_string(&self) -> String {
            match *self {
                Self::Sell => "SELL".to_string(),
                Self::Buy => "BUY".to_string(),
            }
        }
    }
    impl std::str::FromStr for SendMarginQueryOcoSide {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "SELL" => Ok(Self::Sell),
                "BUY" => Ok(Self::Buy),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for SendMarginQueryOcoSide {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for SendMarginQueryOcoSide {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for SendMarginQueryOcoSide {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///SendMarginQueryOcoSideEffectType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "NO_SIDE_EFFECT",
    ///    "MARGIN_BUY",
    ///    "AUTO_REPAY"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum SendMarginQueryOcoSideEffectType {
        #[serde(rename = "NO_SIDE_EFFECT")]
        NoSideEffect,
        #[serde(rename = "MARGIN_BUY")]
        MarginBuy,
        #[serde(rename = "AUTO_REPAY")]
        AutoRepay,
    }
    impl From<&SendMarginQueryOcoSideEffectType> for SendMarginQueryOcoSideEffectType {
        fn from(value: &SendMarginQueryOcoSideEffectType) -> Self {
            value.clone()
        }
    }
    impl ToString for SendMarginQueryOcoSideEffectType {
        fn to_string(&self) -> String {
            match *self {
                Self::NoSideEffect => "NO_SIDE_EFFECT".to_string(),
                Self::MarginBuy => "MARGIN_BUY".to_string(),
                Self::AutoRepay => "AUTO_REPAY".to_string(),
            }
        }
    }
    impl std::str::FromStr for SendMarginQueryOcoSideEffectType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "NO_SIDE_EFFECT" => Ok(Self::NoSideEffect),
                "MARGIN_BUY" => Ok(Self::MarginBuy),
                "AUTO_REPAY" => Ok(Self::AutoRepay),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for SendMarginQueryOcoSideEffectType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for SendMarginQueryOcoSideEffectType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for SendMarginQueryOcoSideEffectType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///SendMarginQueryOcoStopLimitTimeInForce
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "GTC",
    ///    "FOK",
    ///    "IOC"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum SendMarginQueryOcoStopLimitTimeInForce {
        #[serde(rename = "GTC")]
        Gtc,
        #[serde(rename = "FOK")]
        Fok,
        #[serde(rename = "IOC")]
        Ioc,
    }
    impl From<&SendMarginQueryOcoStopLimitTimeInForce>
    for SendMarginQueryOcoStopLimitTimeInForce {
        fn from(value: &SendMarginQueryOcoStopLimitTimeInForce) -> Self {
            value.clone()
        }
    }
    impl ToString for SendMarginQueryOcoStopLimitTimeInForce {
        fn to_string(&self) -> String {
            match *self {
                Self::Gtc => "GTC".to_string(),
                Self::Fok => "FOK".to_string(),
                Self::Ioc => "IOC".to_string(),
            }
        }
    }
    impl std::str::FromStr for SendMarginQueryOcoStopLimitTimeInForce {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "GTC" => Ok(Self::Gtc),
                "FOK" => Ok(Self::Fok),
                "IOC" => Ok(Self::Ioc),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for SendMarginQueryOcoStopLimitTimeInForce {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for SendMarginQueryOcoStopLimitTimeInForce {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for SendMarginQueryOcoStopLimitTimeInForce {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///SetSubAccountAssetsResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "balances"
    ///  ],
    ///  "properties": {
    ///    "balances": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "asset",
    ///          "free",
    ///          "locked"
    ///        ],
    ///        "properties": {
    ///          "asset": {
    ///            "examples": [
    ///              "ADA"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "free": {
    ///            "examples": [
    ///              10000
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "locked": {
    ///            "examples": [
    ///              0
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SetSubAccountAssetsResponse {
        pub balances: Vec<SetSubAccountAssetsResponseBalancesItem>,
    }
    impl From<&SetSubAccountAssetsResponse> for SetSubAccountAssetsResponse {
        fn from(value: &SetSubAccountAssetsResponse) -> Self {
            value.clone()
        }
    }
    ///SetSubAccountAssetsResponseBalancesItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "asset",
    ///    "free",
    ///    "locked"
    ///  ],
    ///  "properties": {
    ///    "asset": {
    ///      "examples": [
    ///        "ADA"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "free": {
    ///      "examples": [
    ///        10000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "locked": {
    ///      "examples": [
    ///        0
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SetSubAccountAssetsResponseBalancesItem {
        pub asset: String,
        pub free: i64,
        pub locked: i64,
    }
    impl From<&SetSubAccountAssetsResponseBalancesItem>
    for SetSubAccountAssetsResponseBalancesItem {
        fn from(value: &SetSubAccountAssetsResponseBalancesItem) -> Self {
            value.clone()
        }
    }
    ///SetSubAccountSubAccountApiIpRestrictionResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "apiKey",
    ///    "ipList",
    ///    "status",
    ///    "updateTime"
    ///  ],
    ///  "properties": {
    ///    "apiKey": {
    ///      "examples": [
    ///        "k5V49ldtn4tszj6W3hystegdfvmGbqDzjmkCtpTvC0G74WhK7yd4rfCTo4lShf"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "ipList": {
    ///      "examples": [
    ///        [
    ///          "69.210.67.14",
    ///          "8.34.21.10",
    ///          "thirdPartyName"
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string"
    ///      }
    ///    },
    ///    "status": {
    ///      "examples": [
    ///        "2"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "updateTime": {
    ///      "examples": [
    ///        1636369557189
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SetSubAccountSubAccountApiIpRestrictionResponse {
        #[serde(rename = "apiKey")]
        pub api_key: String,
        #[serde(rename = "ipList")]
        pub ip_list: Vec<String>,
        pub status: String,
        #[serde(rename = "updateTime")]
        pub update_time: i64,
    }
    impl From<&SetSubAccountSubAccountApiIpRestrictionResponse>
    for SetSubAccountSubAccountApiIpRestrictionResponse {
        fn from(value: &SetSubAccountSubAccountApiIpRestrictionResponse) -> Self {
            value.clone()
        }
    }
    ///SimpleEarnAccountResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "totalAmountInBTC",
    ///    "totalAmountInUSDT",
    ///    "totalFlexibleAmountInBTC",
    ///    "totalFlexibleAmountInUSDT",
    ///    "totalLockedInBTC",
    ///    "totalLockedInUSDT"
    ///  ],
    ///  "properties": {
    ///    "totalAmountInBTC": {
    ///      "examples": [
    ///        "0.01067982"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalAmountInUSDT": {
    ///      "examples": [
    ///        "77.13289230"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalFlexibleAmountInBTC": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalFlexibleAmountInUSDT": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalLockedInBTC": {
    ///      "examples": [
    ///        "0.01067982"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalLockedInUSDT": {
    ///      "examples": [
    ///        "77.13289230"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SimpleEarnAccountResponse {
        #[serde(rename = "totalAmountInBTC")]
        pub total_amount_in_btc: String,
        #[serde(rename = "totalAmountInUSDT")]
        pub total_amount_in_usdt: String,
        #[serde(rename = "totalFlexibleAmountInBTC")]
        pub total_flexible_amount_in_btc: String,
        #[serde(rename = "totalFlexibleAmountInUSDT")]
        pub total_flexible_amount_in_usdt: String,
        #[serde(rename = "totalLockedInBTC")]
        pub total_locked_in_btc: String,
        #[serde(rename = "totalLockedInUSDT")]
        pub total_locked_in_usdt: String,
    }
    impl From<&SimpleEarnAccountResponse> for SimpleEarnAccountResponse {
        fn from(value: &SimpleEarnAccountResponse) -> Self {
            value.clone()
        }
    }
    ///SimpleEarnFlexibleHistoryCollateralRecordResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "rows",
    ///    "total"
    ///  ],
    ///  "properties": {
    ///    "rows": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "amount",
    ///          "asset",
    ///          "createTime",
    ///          "orderId",
    ///          "productId",
    ///          "productName",
    ///          "type"
    ///        ],
    ///        "properties": {
    ///          "amount": {
    ///            "examples": [
    ///              "100.00000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "asset": {
    ///            "examples": [
    ///              "USDT"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "createTime": {
    ///            "examples": [
    ///              1575018510000
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "orderId": {
    ///            "examples": [
    ///              26055
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "productId": {
    ///            "examples": [
    ///              "BUSD001"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "productName": {
    ///            "examples": [
    ///              "USDT"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "type": {
    ///            "examples": [
    ///              "REPAY"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "total": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SimpleEarnFlexibleHistoryCollateralRecordResponse {
        pub rows: Vec<SimpleEarnFlexibleHistoryCollateralRecordResponseRowsItem>,
        pub total: i64,
    }
    impl From<&SimpleEarnFlexibleHistoryCollateralRecordResponse>
    for SimpleEarnFlexibleHistoryCollateralRecordResponse {
        fn from(value: &SimpleEarnFlexibleHistoryCollateralRecordResponse) -> Self {
            value.clone()
        }
    }
    ///SimpleEarnFlexibleHistoryCollateralRecordResponseRowsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "asset",
    ///    "createTime",
    ///    "orderId",
    ///    "productId",
    ///    "productName",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "examples": [
    ///        "100.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "asset": {
    ///      "examples": [
    ///        "USDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "createTime": {
    ///      "examples": [
    ///        1575018510000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "orderId": {
    ///      "examples": [
    ///        26055
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "productId": {
    ///      "examples": [
    ///        "BUSD001"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "productName": {
    ///      "examples": [
    ///        "USDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "examples": [
    ///        "REPAY"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SimpleEarnFlexibleHistoryCollateralRecordResponseRowsItem {
        pub amount: String,
        pub asset: String,
        #[serde(rename = "createTime")]
        pub create_time: i64,
        #[serde(rename = "orderId")]
        pub order_id: i64,
        #[serde(rename = "productId")]
        pub product_id: String,
        #[serde(rename = "productName")]
        pub product_name: String,
        #[serde(rename = "type")]
        pub type_: String,
    }
    impl From<&SimpleEarnFlexibleHistoryCollateralRecordResponseRowsItem>
    for SimpleEarnFlexibleHistoryCollateralRecordResponseRowsItem {
        fn from(
            value: &SimpleEarnFlexibleHistoryCollateralRecordResponseRowsItem,
        ) -> Self {
            value.clone()
        }
    }
    ///SimpleEarnFlexibleHistoryRateHistoryResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "rows",
    ///    "total"
    ///  ],
    ///  "properties": {
    ///    "rows": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "annualPercentageRate",
    ///          "asset",
    ///          "productId",
    ///          "time"
    ///        ],
    ///        "properties": {
    ///          "annualPercentageRate": {
    ///            "examples": [
    ///              "0.00006408"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "asset": {
    ///            "examples": [
    ///              "BUSD"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "productId": {
    ///            "examples": [
    ///              "BUSD001"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "time": {
    ///            "examples": [
    ///              1577233578000
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "total": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SimpleEarnFlexibleHistoryRateHistoryResponse {
        pub rows: Vec<SimpleEarnFlexibleHistoryRateHistoryResponseRowsItem>,
        pub total: i64,
    }
    impl From<&SimpleEarnFlexibleHistoryRateHistoryResponse>
    for SimpleEarnFlexibleHistoryRateHistoryResponse {
        fn from(value: &SimpleEarnFlexibleHistoryRateHistoryResponse) -> Self {
            value.clone()
        }
    }
    ///SimpleEarnFlexibleHistoryRateHistoryResponseRowsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "annualPercentageRate",
    ///    "asset",
    ///    "productId",
    ///    "time"
    ///  ],
    ///  "properties": {
    ///    "annualPercentageRate": {
    ///      "examples": [
    ///        "0.00006408"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "asset": {
    ///      "examples": [
    ///        "BUSD"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "productId": {
    ///      "examples": [
    ///        "BUSD001"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "time": {
    ///      "examples": [
    ///        1577233578000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SimpleEarnFlexibleHistoryRateHistoryResponseRowsItem {
        #[serde(rename = "annualPercentageRate")]
        pub annual_percentage_rate: String,
        pub asset: String,
        #[serde(rename = "productId")]
        pub product_id: String,
        pub time: i64,
    }
    impl From<&SimpleEarnFlexibleHistoryRateHistoryResponseRowsItem>
    for SimpleEarnFlexibleHistoryRateHistoryResponseRowsItem {
        fn from(value: &SimpleEarnFlexibleHistoryRateHistoryResponseRowsItem) -> Self {
            value.clone()
        }
    }
    ///SimpleEarnFlexibleHistoryRedemptionRecordResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "rows",
    ///    "total"
    ///  ],
    ///  "properties": {
    ///    "rows": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "amount",
    ///          "asset",
    ///          "destAccount",
    ///          "projectId",
    ///          "redeemId",
    ///          "status",
    ///          "time"
    ///        ],
    ///        "properties": {
    ///          "amount": {
    ///            "examples": [
    ///              "10.54000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "asset": {
    ///            "examples": [
    ///              "USDT"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "destAccount": {
    ///            "description": "SPOT, FUNDING",
    ///            "examples": [
    ///              "SPOT"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "projectId": {
    ///            "examples": [
    ///              "USDT001"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "redeemId": {
    ///            "examples": [
    ///              40607
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "status": {
    ///            "examples": [
    ///              "PAID"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "time": {
    ///            "examples": [
    ///              1577257222000
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "total": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SimpleEarnFlexibleHistoryRedemptionRecordResponse {
        pub rows: Vec<SimpleEarnFlexibleHistoryRedemptionRecordResponseRowsItem>,
        pub total: i64,
    }
    impl From<&SimpleEarnFlexibleHistoryRedemptionRecordResponse>
    for SimpleEarnFlexibleHistoryRedemptionRecordResponse {
        fn from(value: &SimpleEarnFlexibleHistoryRedemptionRecordResponse) -> Self {
            value.clone()
        }
    }
    ///SimpleEarnFlexibleHistoryRedemptionRecordResponseRowsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "asset",
    ///    "destAccount",
    ///    "projectId",
    ///    "redeemId",
    ///    "status",
    ///    "time"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "examples": [
    ///        "10.54000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "asset": {
    ///      "examples": [
    ///        "USDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "destAccount": {
    ///      "description": "SPOT, FUNDING",
    ///      "examples": [
    ///        "SPOT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "projectId": {
    ///      "examples": [
    ///        "USDT001"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "redeemId": {
    ///      "examples": [
    ///        40607
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "status": {
    ///      "examples": [
    ///        "PAID"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "time": {
    ///      "examples": [
    ///        1577257222000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SimpleEarnFlexibleHistoryRedemptionRecordResponseRowsItem {
        pub amount: String,
        pub asset: String,
        ///SPOT, FUNDING
        #[serde(rename = "destAccount")]
        pub dest_account: String,
        #[serde(rename = "projectId")]
        pub project_id: String,
        #[serde(rename = "redeemId")]
        pub redeem_id: i64,
        pub status: String,
        pub time: i64,
    }
    impl From<&SimpleEarnFlexibleHistoryRedemptionRecordResponseRowsItem>
    for SimpleEarnFlexibleHistoryRedemptionRecordResponseRowsItem {
        fn from(
            value: &SimpleEarnFlexibleHistoryRedemptionRecordResponseRowsItem,
        ) -> Self {
            value.clone()
        }
    }
    ///SimpleEarnFlexibleHistoryRewardsRecordResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "rows",
    ///    "total"
    ///  ],
    ///  "properties": {
    ///    "rows": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "asset",
    ///          "projectId",
    ///          "rewards",
    ///          "time",
    ///          "type"
    ///        ],
    ///        "properties": {
    ///          "asset": {
    ///            "examples": [
    ///              "BUSD"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "projectId": {
    ///            "examples": [
    ///              "USDT001"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "rewards": {
    ///            "examples": [
    ///              "0.00006408"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "time": {
    ///            "examples": [
    ///              1577257222000
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "type": {
    ///            "examples": [
    ///              "BONUS"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "total": {
    ///      "examples": [
    ///        2
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SimpleEarnFlexibleHistoryRewardsRecordResponse {
        pub rows: Vec<SimpleEarnFlexibleHistoryRewardsRecordResponseRowsItem>,
        pub total: i64,
    }
    impl From<&SimpleEarnFlexibleHistoryRewardsRecordResponse>
    for SimpleEarnFlexibleHistoryRewardsRecordResponse {
        fn from(value: &SimpleEarnFlexibleHistoryRewardsRecordResponse) -> Self {
            value.clone()
        }
    }
    ///SimpleEarnFlexibleHistoryRewardsRecordResponseRowsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "asset",
    ///    "projectId",
    ///    "rewards",
    ///    "time",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "asset": {
    ///      "examples": [
    ///        "BUSD"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "projectId": {
    ///      "examples": [
    ///        "USDT001"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "rewards": {
    ///      "examples": [
    ///        "0.00006408"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "time": {
    ///      "examples": [
    ///        1577257222000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "type": {
    ///      "examples": [
    ///        "BONUS"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SimpleEarnFlexibleHistoryRewardsRecordResponseRowsItem {
        pub asset: String,
        #[serde(rename = "projectId")]
        pub project_id: String,
        pub rewards: String,
        pub time: i64,
        #[serde(rename = "type")]
        pub type_: String,
    }
    impl From<&SimpleEarnFlexibleHistoryRewardsRecordResponseRowsItem>
    for SimpleEarnFlexibleHistoryRewardsRecordResponseRowsItem {
        fn from(value: &SimpleEarnFlexibleHistoryRewardsRecordResponseRowsItem) -> Self {
            value.clone()
        }
    }
    ///SimpleEarnFlexibleHistorySubscriptionRecordResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "rows",
    ///    "total"
    ///  ],
    ///  "properties": {
    ///    "rows": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "amount",
    ///          "amtFromFunding",
    ///          "amtFromSpot",
    ///          "asset",
    ///          "purchaseId",
    ///          "sourceAccount",
    ///          "status",
    ///          "time",
    ///          "type"
    ///        ],
    ///        "properties": {
    ///          "amount": {
    ///            "examples": [
    ///              "100.00000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "amtFromFunding": {
    ///            "description": "Display if sourceAccount is SPOTANDFUNDING",
    ///            "examples": [
    ///              "70"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "amtFromSpot": {
    ///            "description": "Display if sourceAccount is SPOTANDFUNDING ",
    ///            "examples": [
    ///              "30"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "asset": {
    ///            "examples": [
    ///              "USDT"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "purchaseId": {
    ///            "examples": [
    ///              26055
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "sourceAccount": {
    ///            "description": "SPOT, FUNDING, SPOTANDFUNDING",
    ///            "examples": [
    ///              "SPOT"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "status": {
    ///            "description": "PURCHASING/SUCCESS/FAILED",
    ///            "examples": [
    ///              "SUCCESS"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "time": {
    ///            "examples": [
    ///              1575018510000
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "type": {
    ///            "description": "AUTO for auto subscribe, NORMAL for normal subscription, CONVERT for Locked to Flexible, LOAN for flexible loan collateral, AI for Auto Invest subscribe, TRANSFER for Locked Savings to Flexible",
    ///            "examples": [
    ///              "AUTO"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "total": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SimpleEarnFlexibleHistorySubscriptionRecordResponse {
        pub rows: Vec<SimpleEarnFlexibleHistorySubscriptionRecordResponseRowsItem>,
        pub total: i64,
    }
    impl From<&SimpleEarnFlexibleHistorySubscriptionRecordResponse>
    for SimpleEarnFlexibleHistorySubscriptionRecordResponse {
        fn from(value: &SimpleEarnFlexibleHistorySubscriptionRecordResponse) -> Self {
            value.clone()
        }
    }
    ///SimpleEarnFlexibleHistorySubscriptionRecordResponseRowsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "amtFromFunding",
    ///    "amtFromSpot",
    ///    "asset",
    ///    "purchaseId",
    ///    "sourceAccount",
    ///    "status",
    ///    "time",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "examples": [
    ///        "100.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "amtFromFunding": {
    ///      "description": "Display if sourceAccount is SPOTANDFUNDING",
    ///      "examples": [
    ///        "70"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "amtFromSpot": {
    ///      "description": "Display if sourceAccount is SPOTANDFUNDING ",
    ///      "examples": [
    ///        "30"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "asset": {
    ///      "examples": [
    ///        "USDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "purchaseId": {
    ///      "examples": [
    ///        26055
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "sourceAccount": {
    ///      "description": "SPOT, FUNDING, SPOTANDFUNDING",
    ///      "examples": [
    ///        "SPOT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "description": "PURCHASING/SUCCESS/FAILED",
    ///      "examples": [
    ///        "SUCCESS"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "time": {
    ///      "examples": [
    ///        1575018510000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "type": {
    ///      "description": "AUTO for auto subscribe, NORMAL for normal subscription, CONVERT for Locked to Flexible, LOAN for flexible loan collateral, AI for Auto Invest subscribe, TRANSFER for Locked Savings to Flexible",
    ///      "examples": [
    ///        "AUTO"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SimpleEarnFlexibleHistorySubscriptionRecordResponseRowsItem {
        pub amount: String,
        ///Display if sourceAccount is SPOTANDFUNDING
        #[serde(rename = "amtFromFunding")]
        pub amt_from_funding: String,
        ///Display if sourceAccount is SPOTANDFUNDING
        #[serde(rename = "amtFromSpot")]
        pub amt_from_spot: String,
        pub asset: String,
        #[serde(rename = "purchaseId")]
        pub purchase_id: i64,
        ///SPOT, FUNDING, SPOTANDFUNDING
        #[serde(rename = "sourceAccount")]
        pub source_account: String,
        ///PURCHASING/SUCCESS/FAILED
        pub status: String,
        pub time: i64,
        ///AUTO for auto subscribe, NORMAL for normal subscription, CONVERT for Locked to Flexible, LOAN for flexible loan collateral, AI for Auto Invest subscribe, TRANSFER for Locked Savings to Flexible
        #[serde(rename = "type")]
        pub type_: String,
    }
    impl From<&SimpleEarnFlexibleHistorySubscriptionRecordResponseRowsItem>
    for SimpleEarnFlexibleHistorySubscriptionRecordResponseRowsItem {
        fn from(
            value: &SimpleEarnFlexibleHistorySubscriptionRecordResponseRowsItem,
        ) -> Self {
            value.clone()
        }
    }
    ///SimpleEarnFlexibleListResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "rows",
    ///    "total"
    ///  ],
    ///  "properties": {
    ///    "rows": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "airDropPercentageRate",
    ///          "asset",
    ///          "canPurchase",
    ///          "canRedeem",
    ///          "hot",
    ///          "isSoldOut",
    ///          "latestAnnualPercentageRate",
    ///          "minPurchaseAmount",
    ///          "productId",
    ///          "status",
    ///          "subscriptionStartTime",
    ///          "tierAnnualPercentageRate"
    ///        ],
    ///        "properties": {
    ///          "airDropPercentageRate": {
    ///            "examples": [
    ///              "0.05000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "asset": {
    ///            "examples": [
    ///              "BTC"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "canPurchase": {
    ///            "examples": [
    ///              true
    ///            ],
    ///            "type": "boolean"
    ///          },
    ///          "canRedeem": {
    ///            "examples": [
    ///              true
    ///            ],
    ///            "type": "boolean"
    ///          },
    ///          "hot": {
    ///            "examples": [
    ///              true
    ///            ],
    ///            "type": "boolean"
    ///          },
    ///          "isSoldOut": {
    ///            "examples": [
    ///              true
    ///            ],
    ///            "type": "boolean"
    ///          },
    ///          "latestAnnualPercentageRate": {
    ///            "examples": [
    ///              "0.05000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "minPurchaseAmount": {
    ///            "examples": [
    ///              "0.01000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "productId": {
    ///            "examples": [
    ///              "BTC001"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "status": {
    ///            "examples": [
    ///              "PURCHASING"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "subscriptionStartTime": {
    ///            "examples": [
    ///              "1646182276000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "tierAnnualPercentageRate": {
    ///            "type": "object",
    ///            "required": [
    ///              "0-5BTC",
    ///              "5-10BTC"
    ///            ],
    ///            "properties": {
    ///              "0-5BTC": {
    ///                "examples": [
    ///                  0.05
    ///                ],
    ///                "type": "number",
    ///                "format": "double"
    ///              },
    ///              "5-10BTC": {
    ///                "examples": [
    ///                  0.03
    ///                ],
    ///                "type": "number",
    ///                "format": "double"
    ///              }
    ///            }
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "total": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SimpleEarnFlexibleListResponse {
        pub rows: Vec<SimpleEarnFlexibleListResponseRowsItem>,
        pub total: i64,
    }
    impl From<&SimpleEarnFlexibleListResponse> for SimpleEarnFlexibleListResponse {
        fn from(value: &SimpleEarnFlexibleListResponse) -> Self {
            value.clone()
        }
    }
    ///SimpleEarnFlexibleListResponseRowsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "airDropPercentageRate",
    ///    "asset",
    ///    "canPurchase",
    ///    "canRedeem",
    ///    "hot",
    ///    "isSoldOut",
    ///    "latestAnnualPercentageRate",
    ///    "minPurchaseAmount",
    ///    "productId",
    ///    "status",
    ///    "subscriptionStartTime",
    ///    "tierAnnualPercentageRate"
    ///  ],
    ///  "properties": {
    ///    "airDropPercentageRate": {
    ///      "examples": [
    ///        "0.05000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "asset": {
    ///      "examples": [
    ///        "BTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "canPurchase": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "canRedeem": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "hot": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "isSoldOut": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "latestAnnualPercentageRate": {
    ///      "examples": [
    ///        "0.05000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "minPurchaseAmount": {
    ///      "examples": [
    ///        "0.01000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "productId": {
    ///      "examples": [
    ///        "BTC001"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "examples": [
    ///        "PURCHASING"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "subscriptionStartTime": {
    ///      "examples": [
    ///        "1646182276000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "tierAnnualPercentageRate": {
    ///      "type": "object",
    ///      "required": [
    ///        "0-5BTC",
    ///        "5-10BTC"
    ///      ],
    ///      "properties": {
    ///        "0-5BTC": {
    ///          "examples": [
    ///            0.05
    ///          ],
    ///          "type": "number",
    ///          "format": "double"
    ///        },
    ///        "5-10BTC": {
    ///          "examples": [
    ///            0.03
    ///          ],
    ///          "type": "number",
    ///          "format": "double"
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SimpleEarnFlexibleListResponseRowsItem {
        #[serde(rename = "airDropPercentageRate")]
        pub air_drop_percentage_rate: String,
        pub asset: String,
        #[serde(rename = "canPurchase")]
        pub can_purchase: bool,
        #[serde(rename = "canRedeem")]
        pub can_redeem: bool,
        pub hot: bool,
        #[serde(rename = "isSoldOut")]
        pub is_sold_out: bool,
        #[serde(rename = "latestAnnualPercentageRate")]
        pub latest_annual_percentage_rate: String,
        #[serde(rename = "minPurchaseAmount")]
        pub min_purchase_amount: String,
        #[serde(rename = "productId")]
        pub product_id: String,
        pub status: String,
        #[serde(rename = "subscriptionStartTime")]
        pub subscription_start_time: String,
        #[serde(rename = "tierAnnualPercentageRate")]
        pub tier_annual_percentage_rate: SimpleEarnFlexibleListResponseRowsItemTierAnnualPercentageRate,
    }
    impl From<&SimpleEarnFlexibleListResponseRowsItem>
    for SimpleEarnFlexibleListResponseRowsItem {
        fn from(value: &SimpleEarnFlexibleListResponseRowsItem) -> Self {
            value.clone()
        }
    }
    ///SimpleEarnFlexibleListResponseRowsItemTierAnnualPercentageRate
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "0-5BTC",
    ///    "5-10BTC"
    ///  ],
    ///  "properties": {
    ///    "0-5BTC": {
    ///      "examples": [
    ///        0.05
    ///      ],
    ///      "type": "number",
    ///      "format": "double"
    ///    },
    ///    "5-10BTC": {
    ///      "examples": [
    ///        0.03
    ///      ],
    ///      "type": "number",
    ///      "format": "double"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SimpleEarnFlexibleListResponseRowsItemTierAnnualPercentageRate {
        #[serde(rename = "0-5BTC")]
        pub _0_5btc: f64,
        #[serde(rename = "5-10BTC")]
        pub _5_10btc: f64,
    }
    impl From<&SimpleEarnFlexibleListResponseRowsItemTierAnnualPercentageRate>
    for SimpleEarnFlexibleListResponseRowsItemTierAnnualPercentageRate {
        fn from(
            value: &SimpleEarnFlexibleListResponseRowsItemTierAnnualPercentageRate,
        ) -> Self {
            value.clone()
        }
    }
    ///SimpleEarnFlexiblePersonalLeftQuotaResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "leftPersonalQuota"
    ///  ],
    ///  "properties": {
    ///    "leftPersonalQuota": {
    ///      "examples": [
    ///        "1000"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SimpleEarnFlexiblePersonalLeftQuotaResponse {
        #[serde(rename = "leftPersonalQuota")]
        pub left_personal_quota: String,
    }
    impl From<&SimpleEarnFlexiblePersonalLeftQuotaResponse>
    for SimpleEarnFlexiblePersonalLeftQuotaResponse {
        fn from(value: &SimpleEarnFlexiblePersonalLeftQuotaResponse) -> Self {
            value.clone()
        }
    }
    ///SimpleEarnFlexiblePositionResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "rows",
    ///    "total"
    ///  ],
    ///  "properties": {
    ///    "rows": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "airDropAsset",
    ///          "asset",
    ///          "autoSubscribe",
    ///          "canRedeem",
    ///          "collateralAmount",
    ///          "cumulativeBonusRewards",
    ///          "cumulativeRealTimeRewards",
    ///          "cumulativeTotalRewards",
    ///          "latestAnnualPercentageRate",
    ///          "productId",
    ///          "tierAnnualPercentageRate",
    ///          "totalAmount",
    ///          "yesterdayAirdropPercentageRate",
    ///          "yesterdayRealTimeRewards"
    ///        ],
    ///        "properties": {
    ///          "airDropAsset": {
    ///            "examples": [
    ///              "BETH"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "asset": {
    ///            "examples": [
    ///              "USDT"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "autoSubscribe": {
    ///            "examples": [
    ///              true
    ///            ],
    ///            "type": "boolean"
    ///          },
    ///          "canRedeem": {
    ///            "examples": [
    ///              true
    ///            ],
    ///            "type": "boolean"
    ///          },
    ///          "collateralAmount": {
    ///            "examples": [
    ///              "232.23123213"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "cumulativeBonusRewards": {
    ///            "examples": [
    ///              "0.22759183"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "cumulativeRealTimeRewards": {
    ///            "examples": [
    ///              "0.22759183"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "cumulativeTotalRewards": {
    ///            "examples": [
    ///              "0.45459183"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "latestAnnualPercentageRate": {
    ///            "examples": [
    ///              "0.02599895"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "productId": {
    ///            "examples": [
    ///              "USDT001"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "tierAnnualPercentageRate": {
    ///            "type": "object",
    ///            "required": [
    ///              "0-5BTC",
    ///              "5-10BTC"
    ///            ],
    ///            "properties": {
    ///              "0-5BTC": {
    ///                "examples": [
    ///                  0.05
    ///                ],
    ///                "type": "number",
    ///                "format": "double"
    ///              },
    ///              "5-10BTC": {
    ///                "examples": [
    ///                  0.03
    ///                ],
    ///                "type": "number",
    ///                "format": "double"
    ///              }
    ///            }
    ///          },
    ///          "totalAmount": {
    ///            "examples": [
    ///              "75.46000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "yesterdayAirdropPercentageRate": {
    ///            "examples": [
    ///              "0.02599895"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "yesterdayRealTimeRewards": {
    ///            "examples": [
    ///              "0.10293829"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "total": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SimpleEarnFlexiblePositionResponse {
        pub rows: Vec<SimpleEarnFlexiblePositionResponseRowsItem>,
        pub total: i64,
    }
    impl From<&SimpleEarnFlexiblePositionResponse>
    for SimpleEarnFlexiblePositionResponse {
        fn from(value: &SimpleEarnFlexiblePositionResponse) -> Self {
            value.clone()
        }
    }
    ///SimpleEarnFlexiblePositionResponseRowsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "airDropAsset",
    ///    "asset",
    ///    "autoSubscribe",
    ///    "canRedeem",
    ///    "collateralAmount",
    ///    "cumulativeBonusRewards",
    ///    "cumulativeRealTimeRewards",
    ///    "cumulativeTotalRewards",
    ///    "latestAnnualPercentageRate",
    ///    "productId",
    ///    "tierAnnualPercentageRate",
    ///    "totalAmount",
    ///    "yesterdayAirdropPercentageRate",
    ///    "yesterdayRealTimeRewards"
    ///  ],
    ///  "properties": {
    ///    "airDropAsset": {
    ///      "examples": [
    ///        "BETH"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "asset": {
    ///      "examples": [
    ///        "USDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "autoSubscribe": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "canRedeem": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "collateralAmount": {
    ///      "examples": [
    ///        "232.23123213"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "cumulativeBonusRewards": {
    ///      "examples": [
    ///        "0.22759183"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "cumulativeRealTimeRewards": {
    ///      "examples": [
    ///        "0.22759183"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "cumulativeTotalRewards": {
    ///      "examples": [
    ///        "0.45459183"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "latestAnnualPercentageRate": {
    ///      "examples": [
    ///        "0.02599895"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "productId": {
    ///      "examples": [
    ///        "USDT001"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "tierAnnualPercentageRate": {
    ///      "type": "object",
    ///      "required": [
    ///        "0-5BTC",
    ///        "5-10BTC"
    ///      ],
    ///      "properties": {
    ///        "0-5BTC": {
    ///          "examples": [
    ///            0.05
    ///          ],
    ///          "type": "number",
    ///          "format": "double"
    ///        },
    ///        "5-10BTC": {
    ///          "examples": [
    ///            0.03
    ///          ],
    ///          "type": "number",
    ///          "format": "double"
    ///        }
    ///      }
    ///    },
    ///    "totalAmount": {
    ///      "examples": [
    ///        "75.46000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "yesterdayAirdropPercentageRate": {
    ///      "examples": [
    ///        "0.02599895"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "yesterdayRealTimeRewards": {
    ///      "examples": [
    ///        "0.10293829"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SimpleEarnFlexiblePositionResponseRowsItem {
        #[serde(rename = "airDropAsset")]
        pub air_drop_asset: String,
        pub asset: String,
        #[serde(rename = "autoSubscribe")]
        pub auto_subscribe: bool,
        #[serde(rename = "canRedeem")]
        pub can_redeem: bool,
        #[serde(rename = "collateralAmount")]
        pub collateral_amount: String,
        #[serde(rename = "cumulativeBonusRewards")]
        pub cumulative_bonus_rewards: String,
        #[serde(rename = "cumulativeRealTimeRewards")]
        pub cumulative_real_time_rewards: String,
        #[serde(rename = "cumulativeTotalRewards")]
        pub cumulative_total_rewards: String,
        #[serde(rename = "latestAnnualPercentageRate")]
        pub latest_annual_percentage_rate: String,
        #[serde(rename = "productId")]
        pub product_id: String,
        #[serde(rename = "tierAnnualPercentageRate")]
        pub tier_annual_percentage_rate: SimpleEarnFlexiblePositionResponseRowsItemTierAnnualPercentageRate,
        #[serde(rename = "totalAmount")]
        pub total_amount: String,
        #[serde(rename = "yesterdayAirdropPercentageRate")]
        pub yesterday_airdrop_percentage_rate: String,
        #[serde(rename = "yesterdayRealTimeRewards")]
        pub yesterday_real_time_rewards: String,
    }
    impl From<&SimpleEarnFlexiblePositionResponseRowsItem>
    for SimpleEarnFlexiblePositionResponseRowsItem {
        fn from(value: &SimpleEarnFlexiblePositionResponseRowsItem) -> Self {
            value.clone()
        }
    }
    ///SimpleEarnFlexiblePositionResponseRowsItemTierAnnualPercentageRate
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "0-5BTC",
    ///    "5-10BTC"
    ///  ],
    ///  "properties": {
    ///    "0-5BTC": {
    ///      "examples": [
    ///        0.05
    ///      ],
    ///      "type": "number",
    ///      "format": "double"
    ///    },
    ///    "5-10BTC": {
    ///      "examples": [
    ///        0.03
    ///      ],
    ///      "type": "number",
    ///      "format": "double"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SimpleEarnFlexiblePositionResponseRowsItemTierAnnualPercentageRate {
        #[serde(rename = "0-5BTC")]
        pub _0_5btc: f64,
        #[serde(rename = "5-10BTC")]
        pub _5_10btc: f64,
    }
    impl From<&SimpleEarnFlexiblePositionResponseRowsItemTierAnnualPercentageRate>
    for SimpleEarnFlexiblePositionResponseRowsItemTierAnnualPercentageRate {
        fn from(
            value: &SimpleEarnFlexiblePositionResponseRowsItemTierAnnualPercentageRate,
        ) -> Self {
            value.clone()
        }
    }
    ///SimpleEarnFlexibleRedeemResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "redeemId",
    ///    "success"
    ///  ],
    ///  "properties": {
    ///    "redeemId": {
    ///      "examples": [
    ///        40607
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "success": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SimpleEarnFlexibleRedeemResponse {
        #[serde(rename = "redeemId")]
        pub redeem_id: i64,
        pub success: bool,
    }
    impl From<&SimpleEarnFlexibleRedeemResponse> for SimpleEarnFlexibleRedeemResponse {
        fn from(value: &SimpleEarnFlexibleRedeemResponse) -> Self {
            value.clone()
        }
    }
    ///SimpleEarnFlexibleSetAutoSubscribeResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "success"
    ///  ],
    ///  "properties": {
    ///    "success": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SimpleEarnFlexibleSetAutoSubscribeResponse {
        pub success: bool,
    }
    impl From<&SimpleEarnFlexibleSetAutoSubscribeResponse>
    for SimpleEarnFlexibleSetAutoSubscribeResponse {
        fn from(value: &SimpleEarnFlexibleSetAutoSubscribeResponse) -> Self {
            value.clone()
        }
    }
    ///SimpleEarnFlexibleSubscribeResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "purchaseId",
    ///    "success"
    ///  ],
    ///  "properties": {
    ///    "purchaseId": {
    ///      "examples": [
    ///        40607
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "success": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SimpleEarnFlexibleSubscribeResponse {
        #[serde(rename = "purchaseId")]
        pub purchase_id: i64,
        pub success: bool,
    }
    impl From<&SimpleEarnFlexibleSubscribeResponse>
    for SimpleEarnFlexibleSubscribeResponse {
        fn from(value: &SimpleEarnFlexibleSubscribeResponse) -> Self {
            value.clone()
        }
    }
    ///SimpleEarnFlexibleSubscriptionPreviewResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "airDropAsset",
    ///    "estDailyAirdropRewards",
    ///    "estDailyBonusRewards",
    ///    "estDailyRealTimeRewards",
    ///    "rewardAsset",
    ///    "totalAmount"
    ///  ],
    ///  "properties": {
    ///    "airDropAsset": {
    ///      "examples": [
    ///        "BETH"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "estDailyAirdropRewards": {
    ///      "examples": [
    ///        "0.22759183"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "estDailyBonusRewards": {
    ///      "examples": [
    ///        "0.22759183"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "estDailyRealTimeRewards": {
    ///      "examples": [
    ///        "0.22759183"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "rewardAsset": {
    ///      "examples": [
    ///        "BUSD"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalAmount": {
    ///      "examples": [
    ///        "1232.32230982"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SimpleEarnFlexibleSubscriptionPreviewResponse {
        #[serde(rename = "airDropAsset")]
        pub air_drop_asset: String,
        #[serde(rename = "estDailyAirdropRewards")]
        pub est_daily_airdrop_rewards: String,
        #[serde(rename = "estDailyBonusRewards")]
        pub est_daily_bonus_rewards: String,
        #[serde(rename = "estDailyRealTimeRewards")]
        pub est_daily_real_time_rewards: String,
        #[serde(rename = "rewardAsset")]
        pub reward_asset: String,
        #[serde(rename = "totalAmount")]
        pub total_amount: String,
    }
    impl From<&SimpleEarnFlexibleSubscriptionPreviewResponse>
    for SimpleEarnFlexibleSubscriptionPreviewResponse {
        fn from(value: &SimpleEarnFlexibleSubscriptionPreviewResponse) -> Self {
            value.clone()
        }
    }
    ///SimpleEarnLockedHistoryRedemptionRecordResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "rows",
    ///    "total"
    ///  ],
    ///  "properties": {
    ///    "rows": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "amount",
    ///          "asset",
    ///          "deliverDate",
    ///          "lockPeriod",
    ///          "positionId",
    ///          "redeemId",
    ///          "status",
    ///          "time",
    ///          "type"
    ///        ],
    ///        "properties": {
    ///          "amount": {
    ///            "examples": [
    ///              "21312.23223"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "asset": {
    ///            "examples": [
    ///              "BNB"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "deliverDate": {
    ///            "examples": [
    ///              "1575018510000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "lockPeriod": {
    ///            "examples": [
    ///              "30"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "positionId": {
    ///            "examples": [
    ///              "123123"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "redeemId": {
    ///            "examples": [
    ///              40607
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "status": {
    ///            "examples": [
    ///              "PAID"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "time": {
    ///            "examples": [
    ///              1575018510000
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "type": {
    ///            "description": "MATURE for redeem to Spot Wallet, NEW_TRANSFERRED for redeem to Flexible product, AHEAD for early redemption",
    ///            "examples": [
    ///              "MATURE"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "total": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SimpleEarnLockedHistoryRedemptionRecordResponse {
        pub rows: Vec<SimpleEarnLockedHistoryRedemptionRecordResponseRowsItem>,
        pub total: i64,
    }
    impl From<&SimpleEarnLockedHistoryRedemptionRecordResponse>
    for SimpleEarnLockedHistoryRedemptionRecordResponse {
        fn from(value: &SimpleEarnLockedHistoryRedemptionRecordResponse) -> Self {
            value.clone()
        }
    }
    ///SimpleEarnLockedHistoryRedemptionRecordResponseRowsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "asset",
    ///    "deliverDate",
    ///    "lockPeriod",
    ///    "positionId",
    ///    "redeemId",
    ///    "status",
    ///    "time",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "examples": [
    ///        "21312.23223"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "asset": {
    ///      "examples": [
    ///        "BNB"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "deliverDate": {
    ///      "examples": [
    ///        "1575018510000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "lockPeriod": {
    ///      "examples": [
    ///        "30"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "positionId": {
    ///      "examples": [
    ///        "123123"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "redeemId": {
    ///      "examples": [
    ///        40607
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "status": {
    ///      "examples": [
    ///        "PAID"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "time": {
    ///      "examples": [
    ///        1575018510000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "type": {
    ///      "description": "MATURE for redeem to Spot Wallet, NEW_TRANSFERRED for redeem to Flexible product, AHEAD for early redemption",
    ///      "examples": [
    ///        "MATURE"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SimpleEarnLockedHistoryRedemptionRecordResponseRowsItem {
        pub amount: String,
        pub asset: String,
        #[serde(rename = "deliverDate")]
        pub deliver_date: String,
        #[serde(rename = "lockPeriod")]
        pub lock_period: String,
        #[serde(rename = "positionId")]
        pub position_id: String,
        #[serde(rename = "redeemId")]
        pub redeem_id: i64,
        pub status: String,
        pub time: i64,
        ///MATURE for redeem to Spot Wallet, NEW_TRANSFERRED for redeem to Flexible product, AHEAD for early redemption
        #[serde(rename = "type")]
        pub type_: String,
    }
    impl From<&SimpleEarnLockedHistoryRedemptionRecordResponseRowsItem>
    for SimpleEarnLockedHistoryRedemptionRecordResponseRowsItem {
        fn from(
            value: &SimpleEarnLockedHistoryRedemptionRecordResponseRowsItem,
        ) -> Self {
            value.clone()
        }
    }
    ///SimpleEarnLockedHistoryRewardsRecordResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "rows",
    ///    "total"
    ///  ],
    ///  "properties": {
    ///    "rows": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "amount",
    ///          "asset",
    ///          "lockPeriod",
    ///          "positionId",
    ///          "time"
    ///        ],
    ///        "properties": {
    ///          "amount": {
    ///            "examples": [
    ///              "21312.23223"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "asset": {
    ///            "examples": [
    ///              "BNB"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "lockPeriod": {
    ///            "examples": [
    ///              "30"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "positionId": {
    ///            "examples": [
    ///              "123123"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "time": {
    ///            "examples": [
    ///              1577257222000
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "total": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SimpleEarnLockedHistoryRewardsRecordResponse {
        pub rows: Vec<SimpleEarnLockedHistoryRewardsRecordResponseRowsItem>,
        pub total: i64,
    }
    impl From<&SimpleEarnLockedHistoryRewardsRecordResponse>
    for SimpleEarnLockedHistoryRewardsRecordResponse {
        fn from(value: &SimpleEarnLockedHistoryRewardsRecordResponse) -> Self {
            value.clone()
        }
    }
    ///SimpleEarnLockedHistoryRewardsRecordResponseRowsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "asset",
    ///    "lockPeriod",
    ///    "positionId",
    ///    "time"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "examples": [
    ///        "21312.23223"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "asset": {
    ///      "examples": [
    ///        "BNB"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "lockPeriod": {
    ///      "examples": [
    ///        "30"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "positionId": {
    ///      "examples": [
    ///        "123123"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "time": {
    ///      "examples": [
    ///        1577257222000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SimpleEarnLockedHistoryRewardsRecordResponseRowsItem {
        pub amount: String,
        pub asset: String,
        #[serde(rename = "lockPeriod")]
        pub lock_period: String,
        #[serde(rename = "positionId")]
        pub position_id: String,
        pub time: i64,
    }
    impl From<&SimpleEarnLockedHistoryRewardsRecordResponseRowsItem>
    for SimpleEarnLockedHistoryRewardsRecordResponseRowsItem {
        fn from(value: &SimpleEarnLockedHistoryRewardsRecordResponseRowsItem) -> Self {
            value.clone()
        }
    }
    ///SimpleEarnLockedHistorySubscriptionRecordResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "rows",
    ///    "total"
    ///  ],
    ///  "properties": {
    ///    "rows": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "amount",
    ///          "amtFromFunding",
    ///          "amtFromSpot",
    ///          "asset",
    ///          "lockPeriod",
    ///          "positionId",
    ///          "purchaseId",
    ///          "sourceAccount",
    ///          "status",
    ///          "time",
    ///          "type"
    ///        ],
    ///        "properties": {
    ///          "amount": {
    ///            "examples": [
    ///              "21312.23223"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "amtFromFunding": {
    ///            "description": "Display if sourceAccount is SPOTANDFUNDING",
    ///            "examples": [
    ///              "70"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "amtFromSpot": {
    ///            "description": "Display if sourceAccount is SPOTANDFUNDING ",
    ///            "examples": [
    ///              "30"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "asset": {
    ///            "examples": [
    ///              "BNB"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "lockPeriod": {
    ///            "examples": [
    ///              "30"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "positionId": {
    ///            "examples": [
    ///              "123123"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "purchaseId": {
    ///            "examples": [
    ///              26055
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "sourceAccount": {
    ///            "description": "SPOT, FUNDING, SPOTANDFUNDING",
    ///            "examples": [
    ///              "SPOT"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "status": {
    ///            "description": "PURCHASING/SUCCESS/FAILED",
    ///            "examples": [
    ///              "SUCCESS"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "time": {
    ///            "examples": [
    ///              1575018510000
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "type": {
    ///            "description": "NORMAL for normal subscription, AUTO for auto-subscription order, ACTIVITY for activity order, TRIAL for trial fund order, RESTAKE for restake order",
    ///            "examples": [
    ///              "AUTO"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "total": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SimpleEarnLockedHistorySubscriptionRecordResponse {
        pub rows: Vec<SimpleEarnLockedHistorySubscriptionRecordResponseRowsItem>,
        pub total: i64,
    }
    impl From<&SimpleEarnLockedHistorySubscriptionRecordResponse>
    for SimpleEarnLockedHistorySubscriptionRecordResponse {
        fn from(value: &SimpleEarnLockedHistorySubscriptionRecordResponse) -> Self {
            value.clone()
        }
    }
    ///SimpleEarnLockedHistorySubscriptionRecordResponseRowsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "amtFromFunding",
    ///    "amtFromSpot",
    ///    "asset",
    ///    "lockPeriod",
    ///    "positionId",
    ///    "purchaseId",
    ///    "sourceAccount",
    ///    "status",
    ///    "time",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "examples": [
    ///        "21312.23223"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "amtFromFunding": {
    ///      "description": "Display if sourceAccount is SPOTANDFUNDING",
    ///      "examples": [
    ///        "70"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "amtFromSpot": {
    ///      "description": "Display if sourceAccount is SPOTANDFUNDING ",
    ///      "examples": [
    ///        "30"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "asset": {
    ///      "examples": [
    ///        "BNB"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "lockPeriod": {
    ///      "examples": [
    ///        "30"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "positionId": {
    ///      "examples": [
    ///        "123123"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "purchaseId": {
    ///      "examples": [
    ///        26055
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "sourceAccount": {
    ///      "description": "SPOT, FUNDING, SPOTANDFUNDING",
    ///      "examples": [
    ///        "SPOT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "description": "PURCHASING/SUCCESS/FAILED",
    ///      "examples": [
    ///        "SUCCESS"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "time": {
    ///      "examples": [
    ///        1575018510000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "type": {
    ///      "description": "NORMAL for normal subscription, AUTO for auto-subscription order, ACTIVITY for activity order, TRIAL for trial fund order, RESTAKE for restake order",
    ///      "examples": [
    ///        "AUTO"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SimpleEarnLockedHistorySubscriptionRecordResponseRowsItem {
        pub amount: String,
        ///Display if sourceAccount is SPOTANDFUNDING
        #[serde(rename = "amtFromFunding")]
        pub amt_from_funding: String,
        ///Display if sourceAccount is SPOTANDFUNDING
        #[serde(rename = "amtFromSpot")]
        pub amt_from_spot: String,
        pub asset: String,
        #[serde(rename = "lockPeriod")]
        pub lock_period: String,
        #[serde(rename = "positionId")]
        pub position_id: String,
        #[serde(rename = "purchaseId")]
        pub purchase_id: i64,
        ///SPOT, FUNDING, SPOTANDFUNDING
        #[serde(rename = "sourceAccount")]
        pub source_account: String,
        ///PURCHASING/SUCCESS/FAILED
        pub status: String,
        pub time: i64,
        ///NORMAL for normal subscription, AUTO for auto-subscription order, ACTIVITY for activity order, TRIAL for trial fund order, RESTAKE for restake order
        #[serde(rename = "type")]
        pub type_: String,
    }
    impl From<&SimpleEarnLockedHistorySubscriptionRecordResponseRowsItem>
    for SimpleEarnLockedHistorySubscriptionRecordResponseRowsItem {
        fn from(
            value: &SimpleEarnLockedHistorySubscriptionRecordResponseRowsItem,
        ) -> Self {
            value.clone()
        }
    }
    ///SimpleEarnLockedListResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "rows",
    ///    "total"
    ///  ],
    ///  "properties": {
    ///    "rows": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "detail",
    ///          "projectId",
    ///          "quota"
    ///        ],
    ///        "properties": {
    ///          "detail": {
    ///            "type": "object",
    ///            "required": [
    ///              "apr",
    ///              "asset",
    ///              "duration",
    ///              "extraRewardAPR",
    ///              "extraRewardAsset",
    ///              "isSoldOut",
    ///              "renewable",
    ///              "rewardAsset",
    ///              "status",
    ///              "subscriptionStartTime"
    ///            ],
    ///            "properties": {
    ///              "apr": {
    ///                "examples": [
    ///                  "1.2069"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "asset": {
    ///                "examples": [
    ///                  "AXS"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "duration": {
    ///                "examples": [
    ///                  90
    ///                ],
    ///                "type": "integer",
    ///                "format": "int64"
    ///              },
    ///              "extraRewardAPR": {
    ///                "examples": [
    ///                  "0.23"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "extraRewardAsset": {
    ///                "examples": [
    ///                  "BNB"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "isSoldOut": {
    ///                "examples": [
    ///                  true
    ///                ],
    ///                "type": "boolean"
    ///              },
    ///              "renewable": {
    ///                "examples": [
    ///                  true
    ///                ],
    ///                "type": "boolean"
    ///              },
    ///              "rewardAsset": {
    ///                "examples": [
    ///                  "AXS"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "status": {
    ///                "examples": [
    ///                  "CREATED"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "subscriptionStartTime": {
    ///                "examples": [
    ///                  "1646182276000"
    ///                ],
    ///                "type": "string"
    ///              }
    ///            }
    ///          },
    ///          "projectId": {
    ///            "examples": [
    ///              "BNB"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "quota": {
    ///            "type": "object",
    ///            "required": [
    ///              "minimum",
    ///              "totalPersonalQuota"
    ///            ],
    ///            "properties": {
    ///              "minimum": {
    ///                "examples": [
    ///                  "0.001"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "totalPersonalQuota": {
    ///                "examples": [
    ///                  "2"
    ///                ],
    ///                "type": "string"
    ///              }
    ///            }
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "total": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SimpleEarnLockedListResponse {
        pub rows: Vec<SimpleEarnLockedListResponseRowsItem>,
        pub total: i64,
    }
    impl From<&SimpleEarnLockedListResponse> for SimpleEarnLockedListResponse {
        fn from(value: &SimpleEarnLockedListResponse) -> Self {
            value.clone()
        }
    }
    ///SimpleEarnLockedListResponseRowsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "detail",
    ///    "projectId",
    ///    "quota"
    ///  ],
    ///  "properties": {
    ///    "detail": {
    ///      "type": "object",
    ///      "required": [
    ///        "apr",
    ///        "asset",
    ///        "duration",
    ///        "extraRewardAPR",
    ///        "extraRewardAsset",
    ///        "isSoldOut",
    ///        "renewable",
    ///        "rewardAsset",
    ///        "status",
    ///        "subscriptionStartTime"
    ///      ],
    ///      "properties": {
    ///        "apr": {
    ///          "examples": [
    ///            "1.2069"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "asset": {
    ///          "examples": [
    ///            "AXS"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "duration": {
    ///          "examples": [
    ///            90
    ///          ],
    ///          "type": "integer",
    ///          "format": "int64"
    ///        },
    ///        "extraRewardAPR": {
    ///          "examples": [
    ///            "0.23"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "extraRewardAsset": {
    ///          "examples": [
    ///            "BNB"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "isSoldOut": {
    ///          "examples": [
    ///            true
    ///          ],
    ///          "type": "boolean"
    ///        },
    ///        "renewable": {
    ///          "examples": [
    ///            true
    ///          ],
    ///          "type": "boolean"
    ///        },
    ///        "rewardAsset": {
    ///          "examples": [
    ///            "AXS"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "status": {
    ///          "examples": [
    ///            "CREATED"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "subscriptionStartTime": {
    ///          "examples": [
    ///            "1646182276000"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "projectId": {
    ///      "examples": [
    ///        "BNB"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "quota": {
    ///      "type": "object",
    ///      "required": [
    ///        "minimum",
    ///        "totalPersonalQuota"
    ///      ],
    ///      "properties": {
    ///        "minimum": {
    ///          "examples": [
    ///            "0.001"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "totalPersonalQuota": {
    ///          "examples": [
    ///            "2"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SimpleEarnLockedListResponseRowsItem {
        pub detail: SimpleEarnLockedListResponseRowsItemDetail,
        #[serde(rename = "projectId")]
        pub project_id: String,
        pub quota: SimpleEarnLockedListResponseRowsItemQuota,
    }
    impl From<&SimpleEarnLockedListResponseRowsItem>
    for SimpleEarnLockedListResponseRowsItem {
        fn from(value: &SimpleEarnLockedListResponseRowsItem) -> Self {
            value.clone()
        }
    }
    ///SimpleEarnLockedListResponseRowsItemDetail
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "apr",
    ///    "asset",
    ///    "duration",
    ///    "extraRewardAPR",
    ///    "extraRewardAsset",
    ///    "isSoldOut",
    ///    "renewable",
    ///    "rewardAsset",
    ///    "status",
    ///    "subscriptionStartTime"
    ///  ],
    ///  "properties": {
    ///    "apr": {
    ///      "examples": [
    ///        "1.2069"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "asset": {
    ///      "examples": [
    ///        "AXS"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "duration": {
    ///      "examples": [
    ///        90
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "extraRewardAPR": {
    ///      "examples": [
    ///        "0.23"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "extraRewardAsset": {
    ///      "examples": [
    ///        "BNB"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "isSoldOut": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "renewable": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "rewardAsset": {
    ///      "examples": [
    ///        "AXS"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "examples": [
    ///        "CREATED"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "subscriptionStartTime": {
    ///      "examples": [
    ///        "1646182276000"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SimpleEarnLockedListResponseRowsItemDetail {
        pub apr: String,
        pub asset: String,
        pub duration: i64,
        #[serde(rename = "extraRewardAPR")]
        pub extra_reward_apr: String,
        #[serde(rename = "extraRewardAsset")]
        pub extra_reward_asset: String,
        #[serde(rename = "isSoldOut")]
        pub is_sold_out: bool,
        pub renewable: bool,
        #[serde(rename = "rewardAsset")]
        pub reward_asset: String,
        pub status: String,
        #[serde(rename = "subscriptionStartTime")]
        pub subscription_start_time: String,
    }
    impl From<&SimpleEarnLockedListResponseRowsItemDetail>
    for SimpleEarnLockedListResponseRowsItemDetail {
        fn from(value: &SimpleEarnLockedListResponseRowsItemDetail) -> Self {
            value.clone()
        }
    }
    ///SimpleEarnLockedListResponseRowsItemQuota
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "minimum",
    ///    "totalPersonalQuota"
    ///  ],
    ///  "properties": {
    ///    "minimum": {
    ///      "examples": [
    ///        "0.001"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalPersonalQuota": {
    ///      "examples": [
    ///        "2"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SimpleEarnLockedListResponseRowsItemQuota {
        pub minimum: String,
        #[serde(rename = "totalPersonalQuota")]
        pub total_personal_quota: String,
    }
    impl From<&SimpleEarnLockedListResponseRowsItemQuota>
    for SimpleEarnLockedListResponseRowsItemQuota {
        fn from(value: &SimpleEarnLockedListResponseRowsItemQuota) -> Self {
            value.clone()
        }
    }
    ///SimpleEarnLockedPersonalLeftQuotaResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "leftPersonalQuota"
    ///  ],
    ///  "properties": {
    ///    "leftPersonalQuota": {
    ///      "examples": [
    ///        "1000"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SimpleEarnLockedPersonalLeftQuotaResponse {
        #[serde(rename = "leftPersonalQuota")]
        pub left_personal_quota: String,
    }
    impl From<&SimpleEarnLockedPersonalLeftQuotaResponse>
    for SimpleEarnLockedPersonalLeftQuotaResponse {
        fn from(value: &SimpleEarnLockedPersonalLeftQuotaResponse) -> Self {
            value.clone()
        }
    }
    ///SimpleEarnLockedPositionResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "rows",
    ///    "total"
    ///  ],
    ///  "properties": {
    ///    "rows": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "APY",
    ///          "accrualDays",
    ///          "amount",
    ///          "asset",
    ///          "duration",
    ///          "isAutoRenew",
    ///          "isRenewable",
    ///          "positionId",
    ///          "projectId",
    ///          "purchaseTime",
    ///          "redeemDate",
    ///          "rewardAsset"
    ///        ],
    ///        "properties": {
    ///          "APY": {
    ///            "examples": [
    ///              "0.23"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "accrualDays": {
    ///            "examples": [
    ///              "4"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "amount": {
    ///            "examples": [
    ///              "122.09202928"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "asset": {
    ///            "examples": [
    ///              "AXS"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "duration": {
    ///            "examples": [
    ///              "60"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "isAutoRenew": {
    ///            "examples": [
    ///              true
    ///            ],
    ///            "type": "boolean"
    ///          },
    ///          "isRenewable": {
    ///            "examples": [
    ///              true
    ///            ],
    ///            "type": "boolean"
    ///          },
    ///          "positionId": {
    ///            "examples": [
    ///              "123123"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "projectId": {
    ///            "examples": [
    ///              "Axs*90"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "purchaseTime": {
    ///            "examples": [
    ///              "1646182276000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "redeemDate": {
    ///            "examples": [
    ///              "1732182276000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "rewardAsset": {
    ///            "examples": [
    ///              "AXS"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "total": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SimpleEarnLockedPositionResponse {
        pub rows: Vec<SimpleEarnLockedPositionResponseRowsItem>,
        pub total: i64,
    }
    impl From<&SimpleEarnLockedPositionResponse> for SimpleEarnLockedPositionResponse {
        fn from(value: &SimpleEarnLockedPositionResponse) -> Self {
            value.clone()
        }
    }
    ///SimpleEarnLockedPositionResponseRowsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "APY",
    ///    "accrualDays",
    ///    "amount",
    ///    "asset",
    ///    "duration",
    ///    "isAutoRenew",
    ///    "isRenewable",
    ///    "positionId",
    ///    "projectId",
    ///    "purchaseTime",
    ///    "redeemDate",
    ///    "rewardAsset"
    ///  ],
    ///  "properties": {
    ///    "APY": {
    ///      "examples": [
    ///        "0.23"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "accrualDays": {
    ///      "examples": [
    ///        "4"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "amount": {
    ///      "examples": [
    ///        "122.09202928"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "asset": {
    ///      "examples": [
    ///        "AXS"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "duration": {
    ///      "examples": [
    ///        "60"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "isAutoRenew": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "isRenewable": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "positionId": {
    ///      "examples": [
    ///        "123123"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "projectId": {
    ///      "examples": [
    ///        "Axs*90"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "purchaseTime": {
    ///      "examples": [
    ///        "1646182276000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "redeemDate": {
    ///      "examples": [
    ///        "1732182276000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "rewardAsset": {
    ///      "examples": [
    ///        "AXS"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SimpleEarnLockedPositionResponseRowsItem {
        #[serde(rename = "accrualDays")]
        pub accrual_days: String,
        pub amount: String,
        #[serde(rename = "APY")]
        pub apy: String,
        pub asset: String,
        pub duration: String,
        #[serde(rename = "isAutoRenew")]
        pub is_auto_renew: bool,
        #[serde(rename = "isRenewable")]
        pub is_renewable: bool,
        #[serde(rename = "positionId")]
        pub position_id: String,
        #[serde(rename = "projectId")]
        pub project_id: String,
        #[serde(rename = "purchaseTime")]
        pub purchase_time: String,
        #[serde(rename = "redeemDate")]
        pub redeem_date: String,
        #[serde(rename = "rewardAsset")]
        pub reward_asset: String,
    }
    impl From<&SimpleEarnLockedPositionResponseRowsItem>
    for SimpleEarnLockedPositionResponseRowsItem {
        fn from(value: &SimpleEarnLockedPositionResponseRowsItem) -> Self {
            value.clone()
        }
    }
    ///SimpleEarnLockedRedeemResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "redeemId",
    ///    "success"
    ///  ],
    ///  "properties": {
    ///    "redeemId": {
    ///      "examples": [
    ///        40607
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "success": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SimpleEarnLockedRedeemResponse {
        #[serde(rename = "redeemId")]
        pub redeem_id: i64,
        pub success: bool,
    }
    impl From<&SimpleEarnLockedRedeemResponse> for SimpleEarnLockedRedeemResponse {
        fn from(value: &SimpleEarnLockedRedeemResponse) -> Self {
            value.clone()
        }
    }
    ///SimpleEarnLockedSetAutoSubscribeResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "success"
    ///  ],
    ///  "properties": {
    ///    "success": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SimpleEarnLockedSetAutoSubscribeResponse {
        pub success: bool,
    }
    impl From<&SimpleEarnLockedSetAutoSubscribeResponse>
    for SimpleEarnLockedSetAutoSubscribeResponse {
        fn from(value: &SimpleEarnLockedSetAutoSubscribeResponse) -> Self {
            value.clone()
        }
    }
    ///SimpleEarnLockedSubscribeResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "positionId",
    ///    "purchaseId",
    ///    "success"
    ///  ],
    ///  "properties": {
    ///    "positionId": {
    ///      "examples": [
    ///        "12345"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "purchaseId": {
    ///      "examples": [
    ///        40607
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "success": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SimpleEarnLockedSubscribeResponse {
        #[serde(rename = "positionId")]
        pub position_id: String,
        #[serde(rename = "purchaseId")]
        pub purchase_id: i64,
        pub success: bool,
    }
    impl From<&SimpleEarnLockedSubscribeResponse> for SimpleEarnLockedSubscribeResponse {
        fn from(value: &SimpleEarnLockedSubscribeResponse) -> Self {
            value.clone()
        }
    }
    ///SimpleEarnLockedSubscriptionPreviewResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "deliverDate",
    ///    "estTotalExtraRewardAmt",
    ///    "extraRewardAsset",
    ///    "nextPay",
    ///    "nextPayDate",
    ///    "nextSubscriptionDate",
    ///    "rewardAsset",
    ///    "rewardsEndDate",
    ///    "totalRewardAmt",
    ///    "valueDate"
    ///  ],
    ///  "properties": {
    ///    "deliverDate": {
    ///      "examples": [
    ///        "1651536000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "estTotalExtraRewardAmt": {
    ///      "examples": [
    ///        "5.17181528"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "extraRewardAsset": {
    ///      "examples": [
    ///        "BNB"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "nextPay": {
    ///      "examples": [
    ///        "1.29295383"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "nextPayDate": {
    ///      "examples": [
    ///        "1646697600000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "nextSubscriptionDate": {
    ///      "examples": [
    ///        "1651536000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "rewardAsset": {
    ///      "examples": [
    ///        "AXS"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "rewardsEndDate": {
    ///      "examples": [
    ///        "1651449600000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalRewardAmt": {
    ///      "examples": [
    ///        "5.17181528"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "valueDate": {
    ///      "examples": [
    ///        "1646697600000"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SimpleEarnLockedSubscriptionPreviewResponseItem {
        #[serde(rename = "deliverDate")]
        pub deliver_date: String,
        #[serde(rename = "estTotalExtraRewardAmt")]
        pub est_total_extra_reward_amt: String,
        #[serde(rename = "extraRewardAsset")]
        pub extra_reward_asset: String,
        #[serde(rename = "nextPay")]
        pub next_pay: String,
        #[serde(rename = "nextPayDate")]
        pub next_pay_date: String,
        #[serde(rename = "nextSubscriptionDate")]
        pub next_subscription_date: String,
        #[serde(rename = "rewardAsset")]
        pub reward_asset: String,
        #[serde(rename = "rewardsEndDate")]
        pub rewards_end_date: String,
        #[serde(rename = "totalRewardAmt")]
        pub total_reward_amt: String,
        #[serde(rename = "valueDate")]
        pub value_date: String,
    }
    impl From<&SimpleEarnLockedSubscriptionPreviewResponseItem>
    for SimpleEarnLockedSubscriptionPreviewResponseItem {
        fn from(value: &SimpleEarnLockedSubscriptionPreviewResponseItem) -> Self {
            value.clone()
        }
    }
    ///SnapshotFutures
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "code",
    ///    "msg",
    ///    "snapshotVos"
    ///  ],
    ///  "properties": {
    ///    "code": {
    ///      "examples": [
    ///        200
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "msg": {
    ///      "examples": [
    ///        ""
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "snapshotVos": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "data",
    ///          "type",
    ///          "updateTime"
    ///        ],
    ///        "properties": {
    ///          "data": {
    ///            "type": "object",
    ///            "required": [
    ///              "assets",
    ///              "position"
    ///            ],
    ///            "properties": {
    ///              "assets": {
    ///                "type": "array",
    ///                "items": {
    ///                  "type": "object",
    ///                  "required": [
    ///                    "asset",
    ///                    "marginBalance",
    ///                    "walletBalance"
    ///                  ],
    ///                  "properties": {
    ///                    "asset": {
    ///                      "examples": [
    ///                        "USDT"
    ///                      ],
    ///                      "type": "string"
    ///                    },
    ///                    "marginBalance": {
    ///                      "examples": [
    ///                        "118.99782335"
    ///                      ],
    ///                      "type": "string"
    ///                    },
    ///                    "walletBalance": {
    ///                      "examples": [
    ///                        "120.23811389"
    ///                      ],
    ///                      "type": "string"
    ///                    }
    ///                  }
    ///                }
    ///              },
    ///              "position": {
    ///                "type": "array",
    ///                "items": {
    ///                  "type": "object",
    ///                  "required": [
    ///                    "entryPrice",
    ///                    "markPrice",
    ///                    "positionAmt",
    ///                    "symbol",
    ///                    "unRealizedProfit"
    ///                  ],
    ///                  "properties": {
    ///                    "entryPrice": {
    ///                      "examples": [
    ///                        "7130.41000000"
    ///                      ],
    ///                      "type": "string"
    ///                    },
    ///                    "markPrice": {
    ///                      "examples": [
    ///                        "7257.66239673"
    ///                      ],
    ///                      "type": "string"
    ///                    },
    ///                    "positionAmt": {
    ///                      "examples": [
    ///                        "0.01000000"
    ///                      ],
    ///                      "type": "string"
    ///                    },
    ///                    "symbol": {
    ///                      "examples": [
    ///                        "BTCUSDT"
    ///                      ],
    ///                      "type": "string"
    ///                    },
    ///                    "unRealizedProfit": {
    ///                      "examples": [
    ///                        "1.24029054"
    ///                      ],
    ///                      "type": "string"
    ///                    }
    ///                  }
    ///                }
    ///              }
    ///            }
    ///          },
    ///          "type": {
    ///            "examples": [
    ///              "futures"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "updateTime": {
    ///            "examples": [
    ///              1576281599000
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SnapshotFutures {
        pub code: i64,
        pub msg: String,
        #[serde(rename = "snapshotVos")]
        pub snapshot_vos: Vec<SnapshotFuturesSnapshotVosItem>,
    }
    impl From<&SnapshotFutures> for SnapshotFutures {
        fn from(value: &SnapshotFutures) -> Self {
            value.clone()
        }
    }
    ///SnapshotFuturesSnapshotVosItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "data",
    ///    "type",
    ///    "updateTime"
    ///  ],
    ///  "properties": {
    ///    "data": {
    ///      "type": "object",
    ///      "required": [
    ///        "assets",
    ///        "position"
    ///      ],
    ///      "properties": {
    ///        "assets": {
    ///          "type": "array",
    ///          "items": {
    ///            "type": "object",
    ///            "required": [
    ///              "asset",
    ///              "marginBalance",
    ///              "walletBalance"
    ///            ],
    ///            "properties": {
    ///              "asset": {
    ///                "examples": [
    ///                  "USDT"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "marginBalance": {
    ///                "examples": [
    ///                  "118.99782335"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "walletBalance": {
    ///                "examples": [
    ///                  "120.23811389"
    ///                ],
    ///                "type": "string"
    ///              }
    ///            }
    ///          }
    ///        },
    ///        "position": {
    ///          "type": "array",
    ///          "items": {
    ///            "type": "object",
    ///            "required": [
    ///              "entryPrice",
    ///              "markPrice",
    ///              "positionAmt",
    ///              "symbol",
    ///              "unRealizedProfit"
    ///            ],
    ///            "properties": {
    ///              "entryPrice": {
    ///                "examples": [
    ///                  "7130.41000000"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "markPrice": {
    ///                "examples": [
    ///                  "7257.66239673"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "positionAmt": {
    ///                "examples": [
    ///                  "0.01000000"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "symbol": {
    ///                "examples": [
    ///                  "BTCUSDT"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "unRealizedProfit": {
    ///                "examples": [
    ///                  "1.24029054"
    ///                ],
    ///                "type": "string"
    ///              }
    ///            }
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "type": {
    ///      "examples": [
    ///        "futures"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "updateTime": {
    ///      "examples": [
    ///        1576281599000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SnapshotFuturesSnapshotVosItem {
        pub data: SnapshotFuturesSnapshotVosItemData,
        #[serde(rename = "type")]
        pub type_: String,
        #[serde(rename = "updateTime")]
        pub update_time: i64,
    }
    impl From<&SnapshotFuturesSnapshotVosItem> for SnapshotFuturesSnapshotVosItem {
        fn from(value: &SnapshotFuturesSnapshotVosItem) -> Self {
            value.clone()
        }
    }
    ///SnapshotFuturesSnapshotVosItemData
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "assets",
    ///    "position"
    ///  ],
    ///  "properties": {
    ///    "assets": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "asset",
    ///          "marginBalance",
    ///          "walletBalance"
    ///        ],
    ///        "properties": {
    ///          "asset": {
    ///            "examples": [
    ///              "USDT"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "marginBalance": {
    ///            "examples": [
    ///              "118.99782335"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "walletBalance": {
    ///            "examples": [
    ///              "120.23811389"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "position": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "entryPrice",
    ///          "markPrice",
    ///          "positionAmt",
    ///          "symbol",
    ///          "unRealizedProfit"
    ///        ],
    ///        "properties": {
    ///          "entryPrice": {
    ///            "examples": [
    ///              "7130.41000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "markPrice": {
    ///            "examples": [
    ///              "7257.66239673"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "positionAmt": {
    ///            "examples": [
    ///              "0.01000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "symbol": {
    ///            "examples": [
    ///              "BTCUSDT"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "unRealizedProfit": {
    ///            "examples": [
    ///              "1.24029054"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SnapshotFuturesSnapshotVosItemData {
        pub assets: Vec<SnapshotFuturesSnapshotVosItemDataAssetsItem>,
        pub position: Vec<SnapshotFuturesSnapshotVosItemDataPositionItem>,
    }
    impl From<&SnapshotFuturesSnapshotVosItemData>
    for SnapshotFuturesSnapshotVosItemData {
        fn from(value: &SnapshotFuturesSnapshotVosItemData) -> Self {
            value.clone()
        }
    }
    ///SnapshotFuturesSnapshotVosItemDataAssetsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "asset",
    ///    "marginBalance",
    ///    "walletBalance"
    ///  ],
    ///  "properties": {
    ///    "asset": {
    ///      "examples": [
    ///        "USDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "marginBalance": {
    ///      "examples": [
    ///        "118.99782335"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "walletBalance": {
    ///      "examples": [
    ///        "120.23811389"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SnapshotFuturesSnapshotVosItemDataAssetsItem {
        pub asset: String,
        #[serde(rename = "marginBalance")]
        pub margin_balance: String,
        #[serde(rename = "walletBalance")]
        pub wallet_balance: String,
    }
    impl From<&SnapshotFuturesSnapshotVosItemDataAssetsItem>
    for SnapshotFuturesSnapshotVosItemDataAssetsItem {
        fn from(value: &SnapshotFuturesSnapshotVosItemDataAssetsItem) -> Self {
            value.clone()
        }
    }
    ///SnapshotFuturesSnapshotVosItemDataPositionItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "entryPrice",
    ///    "markPrice",
    ///    "positionAmt",
    ///    "symbol",
    ///    "unRealizedProfit"
    ///  ],
    ///  "properties": {
    ///    "entryPrice": {
    ///      "examples": [
    ///        "7130.41000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "markPrice": {
    ///      "examples": [
    ///        "7257.66239673"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "positionAmt": {
    ///      "examples": [
    ///        "0.01000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "symbol": {
    ///      "examples": [
    ///        "BTCUSDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "unRealizedProfit": {
    ///      "examples": [
    ///        "1.24029054"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SnapshotFuturesSnapshotVosItemDataPositionItem {
        #[serde(rename = "entryPrice")]
        pub entry_price: String,
        #[serde(rename = "markPrice")]
        pub mark_price: String,
        #[serde(rename = "positionAmt")]
        pub position_amt: String,
        pub symbol: String,
        #[serde(rename = "unRealizedProfit")]
        pub un_realized_profit: String,
    }
    impl From<&SnapshotFuturesSnapshotVosItemDataPositionItem>
    for SnapshotFuturesSnapshotVosItemDataPositionItem {
        fn from(value: &SnapshotFuturesSnapshotVosItemDataPositionItem) -> Self {
            value.clone()
        }
    }
    ///SnapshotMargin
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "code",
    ///    "msg",
    ///    "snapshotVos"
    ///  ],
    ///  "properties": {
    ///    "code": {
    ///      "examples": [
    ///        200
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "msg": {
    ///      "examples": [
    ///        ""
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "snapshotVos": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "data",
    ///          "type",
    ///          "updateTime"
    ///        ],
    ///        "properties": {
    ///          "data": {
    ///            "type": "object",
    ///            "required": [
    ///              "marginLevel",
    ///              "totalAssetOfBtc",
    ///              "totalLiabilityOfBtc",
    ///              "totalNetAssetOfBtc",
    ///              "userAssets"
    ///            ],
    ///            "properties": {
    ///              "marginLevel": {
    ///                "examples": [
    ///                  "2748.02909813"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "totalAssetOfBtc": {
    ///                "examples": [
    ///                  "0.00274803"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "totalLiabilityOfBtc": {
    ///                "examples": [
    ///                  "0.00000100"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "totalNetAssetOfBtc": {
    ///                "examples": [
    ///                  "0.00274750"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "userAssets": {
    ///                "type": "array",
    ///                "items": {
    ///                  "type": "object",
    ///                  "required": [
    ///                    "asset",
    ///                    "borrowed",
    ///                    "free",
    ///                    "interest",
    ///                    "locked",
    ///                    "netAsset"
    ///                  ],
    ///                  "properties": {
    ///                    "asset": {
    ///                      "examples": [
    ///                        "XRP"
    ///                      ],
    ///                      "type": "string"
    ///                    },
    ///                    "borrowed": {
    ///                      "examples": [
    ///                        "0.00000000"
    ///                      ],
    ///                      "type": "string"
    ///                    },
    ///                    "free": {
    ///                      "examples": [
    ///                        "1.00000000"
    ///                      ],
    ///                      "type": "string"
    ///                    },
    ///                    "interest": {
    ///                      "examples": [
    ///                        "0.00000000"
    ///                      ],
    ///                      "type": "string"
    ///                    },
    ///                    "locked": {
    ///                      "examples": [
    ///                        "0.00000000"
    ///                      ],
    ///                      "type": "string"
    ///                    },
    ///                    "netAsset": {
    ///                      "examples": [
    ///                        "1.00000000"
    ///                      ],
    ///                      "type": "string"
    ///                    }
    ///                  }
    ///                }
    ///              }
    ///            }
    ///          },
    ///          "type": {
    ///            "examples": [
    ///              "margin"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "updateTime": {
    ///            "examples": [
    ///              1576281599000
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SnapshotMargin {
        pub code: i64,
        pub msg: String,
        #[serde(rename = "snapshotVos")]
        pub snapshot_vos: Vec<SnapshotMarginSnapshotVosItem>,
    }
    impl From<&SnapshotMargin> for SnapshotMargin {
        fn from(value: &SnapshotMargin) -> Self {
            value.clone()
        }
    }
    ///SnapshotMarginSnapshotVosItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "data",
    ///    "type",
    ///    "updateTime"
    ///  ],
    ///  "properties": {
    ///    "data": {
    ///      "type": "object",
    ///      "required": [
    ///        "marginLevel",
    ///        "totalAssetOfBtc",
    ///        "totalLiabilityOfBtc",
    ///        "totalNetAssetOfBtc",
    ///        "userAssets"
    ///      ],
    ///      "properties": {
    ///        "marginLevel": {
    ///          "examples": [
    ///            "2748.02909813"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "totalAssetOfBtc": {
    ///          "examples": [
    ///            "0.00274803"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "totalLiabilityOfBtc": {
    ///          "examples": [
    ///            "0.00000100"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "totalNetAssetOfBtc": {
    ///          "examples": [
    ///            "0.00274750"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "userAssets": {
    ///          "type": "array",
    ///          "items": {
    ///            "type": "object",
    ///            "required": [
    ///              "asset",
    ///              "borrowed",
    ///              "free",
    ///              "interest",
    ///              "locked",
    ///              "netAsset"
    ///            ],
    ///            "properties": {
    ///              "asset": {
    ///                "examples": [
    ///                  "XRP"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "borrowed": {
    ///                "examples": [
    ///                  "0.00000000"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "free": {
    ///                "examples": [
    ///                  "1.00000000"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "interest": {
    ///                "examples": [
    ///                  "0.00000000"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "locked": {
    ///                "examples": [
    ///                  "0.00000000"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "netAsset": {
    ///                "examples": [
    ///                  "1.00000000"
    ///                ],
    ///                "type": "string"
    ///              }
    ///            }
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "type": {
    ///      "examples": [
    ///        "margin"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "updateTime": {
    ///      "examples": [
    ///        1576281599000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SnapshotMarginSnapshotVosItem {
        pub data: SnapshotMarginSnapshotVosItemData,
        #[serde(rename = "type")]
        pub type_: String,
        #[serde(rename = "updateTime")]
        pub update_time: i64,
    }
    impl From<&SnapshotMarginSnapshotVosItem> for SnapshotMarginSnapshotVosItem {
        fn from(value: &SnapshotMarginSnapshotVosItem) -> Self {
            value.clone()
        }
    }
    ///SnapshotMarginSnapshotVosItemData
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "marginLevel",
    ///    "totalAssetOfBtc",
    ///    "totalLiabilityOfBtc",
    ///    "totalNetAssetOfBtc",
    ///    "userAssets"
    ///  ],
    ///  "properties": {
    ///    "marginLevel": {
    ///      "examples": [
    ///        "2748.02909813"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalAssetOfBtc": {
    ///      "examples": [
    ///        "0.00274803"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalLiabilityOfBtc": {
    ///      "examples": [
    ///        "0.00000100"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalNetAssetOfBtc": {
    ///      "examples": [
    ///        "0.00274750"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "userAssets": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "asset",
    ///          "borrowed",
    ///          "free",
    ///          "interest",
    ///          "locked",
    ///          "netAsset"
    ///        ],
    ///        "properties": {
    ///          "asset": {
    ///            "examples": [
    ///              "XRP"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "borrowed": {
    ///            "examples": [
    ///              "0.00000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "free": {
    ///            "examples": [
    ///              "1.00000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "interest": {
    ///            "examples": [
    ///              "0.00000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "locked": {
    ///            "examples": [
    ///              "0.00000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "netAsset": {
    ///            "examples": [
    ///              "1.00000000"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SnapshotMarginSnapshotVosItemData {
        #[serde(rename = "marginLevel")]
        pub margin_level: String,
        #[serde(rename = "totalAssetOfBtc")]
        pub total_asset_of_btc: String,
        #[serde(rename = "totalLiabilityOfBtc")]
        pub total_liability_of_btc: String,
        #[serde(rename = "totalNetAssetOfBtc")]
        pub total_net_asset_of_btc: String,
        #[serde(rename = "userAssets")]
        pub user_assets: Vec<SnapshotMarginSnapshotVosItemDataUserAssetsItem>,
    }
    impl From<&SnapshotMarginSnapshotVosItemData> for SnapshotMarginSnapshotVosItemData {
        fn from(value: &SnapshotMarginSnapshotVosItemData) -> Self {
            value.clone()
        }
    }
    ///SnapshotMarginSnapshotVosItemDataUserAssetsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "asset",
    ///    "borrowed",
    ///    "free",
    ///    "interest",
    ///    "locked",
    ///    "netAsset"
    ///  ],
    ///  "properties": {
    ///    "asset": {
    ///      "examples": [
    ///        "XRP"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "borrowed": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "free": {
    ///      "examples": [
    ///        "1.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "interest": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "locked": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "netAsset": {
    ///      "examples": [
    ///        "1.00000000"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SnapshotMarginSnapshotVosItemDataUserAssetsItem {
        pub asset: String,
        pub borrowed: String,
        pub free: String,
        pub interest: String,
        pub locked: String,
        #[serde(rename = "netAsset")]
        pub net_asset: String,
    }
    impl From<&SnapshotMarginSnapshotVosItemDataUserAssetsItem>
    for SnapshotMarginSnapshotVosItemDataUserAssetsItem {
        fn from(value: &SnapshotMarginSnapshotVosItemDataUserAssetsItem) -> Self {
            value.clone()
        }
    }
    ///SnapshotSpot
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "code",
    ///    "msg",
    ///    "snapshotVos"
    ///  ],
    ///  "properties": {
    ///    "code": {
    ///      "examples": [
    ///        200
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "msg": {
    ///      "examples": [
    ///        ""
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "snapshotVos": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "data",
    ///          "type",
    ///          "updateTime"
    ///        ],
    ///        "properties": {
    ///          "data": {
    ///            "type": "object",
    ///            "required": [
    ///              "balances",
    ///              "totalAssetOfBtc"
    ///            ],
    ///            "properties": {
    ///              "balances": {
    ///                "type": "array",
    ///                "items": {
    ///                  "type": "object",
    ///                  "required": [
    ///                    "asset",
    ///                    "free",
    ///                    "locked"
    ///                  ],
    ///                  "properties": {
    ///                    "asset": {
    ///                      "examples": [
    ///                        "BTC"
    ///                      ],
    ///                      "type": "string"
    ///                    },
    ///                    "free": {
    ///                      "examples": [
    ///                        "0.2"
    ///                      ],
    ///                      "type": "string"
    ///                    },
    ///                    "locked": {
    ///                      "examples": [
    ///                        "0.001"
    ///                      ],
    ///                      "type": "string"
    ///                    }
    ///                  }
    ///                }
    ///              },
    ///              "totalAssetOfBtc": {
    ///                "examples": [
    ///                  "0.09905021"
    ///                ],
    ///                "type": "string"
    ///              }
    ///            }
    ///          },
    ///          "type": {
    ///            "examples": [
    ///              "spot"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "updateTime": {
    ///            "examples": [
    ///              1576281599000
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SnapshotSpot {
        pub code: i64,
        pub msg: String,
        #[serde(rename = "snapshotVos")]
        pub snapshot_vos: Vec<SnapshotSpotSnapshotVosItem>,
    }
    impl From<&SnapshotSpot> for SnapshotSpot {
        fn from(value: &SnapshotSpot) -> Self {
            value.clone()
        }
    }
    ///SnapshotSpotSnapshotVosItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "data",
    ///    "type",
    ///    "updateTime"
    ///  ],
    ///  "properties": {
    ///    "data": {
    ///      "type": "object",
    ///      "required": [
    ///        "balances",
    ///        "totalAssetOfBtc"
    ///      ],
    ///      "properties": {
    ///        "balances": {
    ///          "type": "array",
    ///          "items": {
    ///            "type": "object",
    ///            "required": [
    ///              "asset",
    ///              "free",
    ///              "locked"
    ///            ],
    ///            "properties": {
    ///              "asset": {
    ///                "examples": [
    ///                  "BTC"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "free": {
    ///                "examples": [
    ///                  "0.2"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "locked": {
    ///                "examples": [
    ///                  "0.001"
    ///                ],
    ///                "type": "string"
    ///              }
    ///            }
    ///          }
    ///        },
    ///        "totalAssetOfBtc": {
    ///          "examples": [
    ///            "0.09905021"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "type": {
    ///      "examples": [
    ///        "spot"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "updateTime": {
    ///      "examples": [
    ///        1576281599000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SnapshotSpotSnapshotVosItem {
        pub data: SnapshotSpotSnapshotVosItemData,
        #[serde(rename = "type")]
        pub type_: String,
        #[serde(rename = "updateTime")]
        pub update_time: i64,
    }
    impl From<&SnapshotSpotSnapshotVosItem> for SnapshotSpotSnapshotVosItem {
        fn from(value: &SnapshotSpotSnapshotVosItem) -> Self {
            value.clone()
        }
    }
    ///SnapshotSpotSnapshotVosItemData
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "balances",
    ///    "totalAssetOfBtc"
    ///  ],
    ///  "properties": {
    ///    "balances": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "asset",
    ///          "free",
    ///          "locked"
    ///        ],
    ///        "properties": {
    ///          "asset": {
    ///            "examples": [
    ///              "BTC"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "free": {
    ///            "examples": [
    ///              "0.2"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "locked": {
    ///            "examples": [
    ///              "0.001"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "totalAssetOfBtc": {
    ///      "examples": [
    ///        "0.09905021"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SnapshotSpotSnapshotVosItemData {
        pub balances: Vec<SnapshotSpotSnapshotVosItemDataBalancesItem>,
        #[serde(rename = "totalAssetOfBtc")]
        pub total_asset_of_btc: String,
    }
    impl From<&SnapshotSpotSnapshotVosItemData> for SnapshotSpotSnapshotVosItemData {
        fn from(value: &SnapshotSpotSnapshotVosItemData) -> Self {
            value.clone()
        }
    }
    ///SnapshotSpotSnapshotVosItemDataBalancesItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "asset",
    ///    "free",
    ///    "locked"
    ///  ],
    ///  "properties": {
    ///    "asset": {
    ///      "examples": [
    ///        "BTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "free": {
    ///      "examples": [
    ///        "0.2"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "locked": {
    ///      "examples": [
    ///        "0.001"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SnapshotSpotSnapshotVosItemDataBalancesItem {
        pub asset: String,
        pub free: String,
        pub locked: String,
    }
    impl From<&SnapshotSpotSnapshotVosItemDataBalancesItem>
    for SnapshotSpotSnapshotVosItemDataBalancesItem {
        fn from(value: &SnapshotSpotSnapshotVosItemDataBalancesItem) -> Self {
            value.clone()
        }
    }
    ///SorOrderNewOrderRespType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "ACK",
    ///    "RESULT",
    ///    "FULL"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum SorOrderNewOrderRespType {
        #[serde(rename = "ACK")]
        Ack,
        #[serde(rename = "RESULT")]
        Result,
        #[serde(rename = "FULL")]
        Full,
    }
    impl From<&SorOrderNewOrderRespType> for SorOrderNewOrderRespType {
        fn from(value: &SorOrderNewOrderRespType) -> Self {
            value.clone()
        }
    }
    impl ToString for SorOrderNewOrderRespType {
        fn to_string(&self) -> String {
            match *self {
                Self::Ack => "ACK".to_string(),
                Self::Result => "RESULT".to_string(),
                Self::Full => "FULL".to_string(),
            }
        }
    }
    impl std::str::FromStr for SorOrderNewOrderRespType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "ACK" => Ok(Self::Ack),
                "RESULT" => Ok(Self::Result),
                "FULL" => Ok(Self::Full),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for SorOrderNewOrderRespType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for SorOrderNewOrderRespType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for SorOrderNewOrderRespType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///SorOrderResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "clientOrderId",
    ///    "cummulativeQuoteQty",
    ///    "executedQty",
    ///    "fills",
    ///    "orderId",
    ///    "orderListId",
    ///    "origQty",
    ///    "price",
    ///    "selfTradePreventionMode",
    ///    "side",
    ///    "status",
    ///    "symbol",
    ///    "timeInForce",
    ///    "transactTime",
    ///    "type",
    ///    "usedSor",
    ///    "workingFloor",
    ///    "workingTime"
    ///  ],
    ///  "properties": {
    ///    "clientOrderId": {
    ///      "examples": [
    ///        "sBI1KM6nNtOfj5tccZSKly"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "cummulativeQuoteQty": {
    ///      "examples": [
    ///        "14000.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "executedQty": {
    ///      "examples": [
    ///        "0.50000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "fills": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "allocId",
    ///          "commission",
    ///          "commissionAsset",
    ///          "matchType",
    ///          "price",
    ///          "qty",
    ///          "tradeId"
    ///        ],
    ///        "properties": {
    ///          "allocId": {
    ///            "examples": [
    ///              0
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "commission": {
    ///            "examples": [
    ///              "0.00000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "commissionAsset": {
    ///            "examples": [
    ///              "BTC"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "matchType": {
    ///            "examples": [
    ///              "ONE_PARTY_TRADE_REPORT"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "price": {
    ///            "examples": [
    ///              "28000.00000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "qty": {
    ///            "examples": [
    ///              "0.50000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "tradeId": {
    ///            "examples": [
    ///              -1
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "orderId": {
    ///      "examples": [
    ///        2
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "orderListId": {
    ///      "examples": [
    ///        -1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "origQty": {
    ///      "examples": [
    ///        "0.50000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "price": {
    ///      "examples": [
    ///        "31000.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "selfTradePreventionMode": {
    ///      "examples": [
    ///        "NONE"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "side": {
    ///      "examples": [
    ///        "BUY"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "examples": [
    ///        "FILLED"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "symbol": {
    ///      "examples": [
    ///        "BTCUSDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "timeInForce": {
    ///      "examples": [
    ///        "GTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "transactTime": {
    ///      "examples": [
    ///        1689149087774
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "type": {
    ///      "examples": [
    ///        "LIMIT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "usedSor": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "workingFloor": {
    ///      "examples": [
    ///        "SOR"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "workingTime": {
    ///      "examples": [
    ///        1689149087774
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SorOrderResponse {
        #[serde(rename = "clientOrderId")]
        pub client_order_id: String,
        #[serde(rename = "cummulativeQuoteQty")]
        pub cummulative_quote_qty: String,
        #[serde(rename = "executedQty")]
        pub executed_qty: String,
        pub fills: Vec<SorOrderResponseFillsItem>,
        #[serde(rename = "orderId")]
        pub order_id: i64,
        #[serde(rename = "orderListId")]
        pub order_list_id: i64,
        #[serde(rename = "origQty")]
        pub orig_qty: String,
        pub price: String,
        #[serde(rename = "selfTradePreventionMode")]
        pub self_trade_prevention_mode: String,
        pub side: String,
        pub status: String,
        pub symbol: String,
        #[serde(rename = "timeInForce")]
        pub time_in_force: String,
        #[serde(rename = "transactTime")]
        pub transact_time: i64,
        #[serde(rename = "type")]
        pub type_: String,
        #[serde(rename = "usedSor")]
        pub used_sor: bool,
        #[serde(rename = "workingFloor")]
        pub working_floor: String,
        #[serde(rename = "workingTime")]
        pub working_time: i64,
    }
    impl From<&SorOrderResponse> for SorOrderResponse {
        fn from(value: &SorOrderResponse) -> Self {
            value.clone()
        }
    }
    ///SorOrderResponseFillsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "allocId",
    ///    "commission",
    ///    "commissionAsset",
    ///    "matchType",
    ///    "price",
    ///    "qty",
    ///    "tradeId"
    ///  ],
    ///  "properties": {
    ///    "allocId": {
    ///      "examples": [
    ///        0
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "commission": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "commissionAsset": {
    ///      "examples": [
    ///        "BTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "matchType": {
    ///      "examples": [
    ///        "ONE_PARTY_TRADE_REPORT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "price": {
    ///      "examples": [
    ///        "28000.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "qty": {
    ///      "examples": [
    ///        "0.50000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "tradeId": {
    ///      "examples": [
    ///        -1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SorOrderResponseFillsItem {
        #[serde(rename = "allocId")]
        pub alloc_id: i64,
        pub commission: String,
        #[serde(rename = "commissionAsset")]
        pub commission_asset: String,
        #[serde(rename = "matchType")]
        pub match_type: String,
        pub price: String,
        pub qty: String,
        #[serde(rename = "tradeId")]
        pub trade_id: i64,
    }
    impl From<&SorOrderResponseFillsItem> for SorOrderResponseFillsItem {
        fn from(value: &SorOrderResponseFillsItem) -> Self {
            value.clone()
        }
    }
    ///SorOrderSelfTradePreventionMode
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "EXPIRE_TAKER"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "EXPIRE_TAKER",
    ///    "EXPIRE_MAKER",
    ///    "EXPIRE_BOTH",
    ///    "NONE"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum SorOrderSelfTradePreventionMode {
        #[serde(rename = "EXPIRE_TAKER")]
        ExpireTaker,
        #[serde(rename = "EXPIRE_MAKER")]
        ExpireMaker,
        #[serde(rename = "EXPIRE_BOTH")]
        ExpireBoth,
        #[serde(rename = "NONE")]
        None,
    }
    impl From<&SorOrderSelfTradePreventionMode> for SorOrderSelfTradePreventionMode {
        fn from(value: &SorOrderSelfTradePreventionMode) -> Self {
            value.clone()
        }
    }
    impl ToString for SorOrderSelfTradePreventionMode {
        fn to_string(&self) -> String {
            match *self {
                Self::ExpireTaker => "EXPIRE_TAKER".to_string(),
                Self::ExpireMaker => "EXPIRE_MAKER".to_string(),
                Self::ExpireBoth => "EXPIRE_BOTH".to_string(),
                Self::None => "NONE".to_string(),
            }
        }
    }
    impl std::str::FromStr for SorOrderSelfTradePreventionMode {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "EXPIRE_TAKER" => Ok(Self::ExpireTaker),
                "EXPIRE_MAKER" => Ok(Self::ExpireMaker),
                "EXPIRE_BOTH" => Ok(Self::ExpireBoth),
                "NONE" => Ok(Self::None),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for SorOrderSelfTradePreventionMode {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for SorOrderSelfTradePreventionMode {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for SorOrderSelfTradePreventionMode {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///SorOrderSide
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "SELL"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "SELL",
    ///    "BUY"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum SorOrderSide {
        #[serde(rename = "SELL")]
        Sell,
        #[serde(rename = "BUY")]
        Buy,
    }
    impl From<&SorOrderSide> for SorOrderSide {
        fn from(value: &SorOrderSide) -> Self {
            value.clone()
        }
    }
    impl ToString for SorOrderSide {
        fn to_string(&self) -> String {
            match *self {
                Self::Sell => "SELL".to_string(),
                Self::Buy => "BUY".to_string(),
            }
        }
    }
    impl std::str::FromStr for SorOrderSide {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "SELL" => Ok(Self::Sell),
                "BUY" => Ok(Self::Buy),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for SorOrderSide {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for SorOrderSide {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for SorOrderSide {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///SorOrderTestNewOrderRespType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "ACK",
    ///    "RESULT",
    ///    "FULL"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum SorOrderTestNewOrderRespType {
        #[serde(rename = "ACK")]
        Ack,
        #[serde(rename = "RESULT")]
        Result,
        #[serde(rename = "FULL")]
        Full,
    }
    impl From<&SorOrderTestNewOrderRespType> for SorOrderTestNewOrderRespType {
        fn from(value: &SorOrderTestNewOrderRespType) -> Self {
            value.clone()
        }
    }
    impl ToString for SorOrderTestNewOrderRespType {
        fn to_string(&self) -> String {
            match *self {
                Self::Ack => "ACK".to_string(),
                Self::Result => "RESULT".to_string(),
                Self::Full => "FULL".to_string(),
            }
        }
    }
    impl std::str::FromStr for SorOrderTestNewOrderRespType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "ACK" => Ok(Self::Ack),
                "RESULT" => Ok(Self::Result),
                "FULL" => Ok(Self::Full),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for SorOrderTestNewOrderRespType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for SorOrderTestNewOrderRespType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for SorOrderTestNewOrderRespType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///SorOrderTestSelfTradePreventionMode
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "EXPIRE_TAKER"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "EXPIRE_TAKER",
    ///    "EXPIRE_MAKER",
    ///    "EXPIRE_BOTH",
    ///    "NONE"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum SorOrderTestSelfTradePreventionMode {
        #[serde(rename = "EXPIRE_TAKER")]
        ExpireTaker,
        #[serde(rename = "EXPIRE_MAKER")]
        ExpireMaker,
        #[serde(rename = "EXPIRE_BOTH")]
        ExpireBoth,
        #[serde(rename = "NONE")]
        None,
    }
    impl From<&SorOrderTestSelfTradePreventionMode>
    for SorOrderTestSelfTradePreventionMode {
        fn from(value: &SorOrderTestSelfTradePreventionMode) -> Self {
            value.clone()
        }
    }
    impl ToString for SorOrderTestSelfTradePreventionMode {
        fn to_string(&self) -> String {
            match *self {
                Self::ExpireTaker => "EXPIRE_TAKER".to_string(),
                Self::ExpireMaker => "EXPIRE_MAKER".to_string(),
                Self::ExpireBoth => "EXPIRE_BOTH".to_string(),
                Self::None => "NONE".to_string(),
            }
        }
    }
    impl std::str::FromStr for SorOrderTestSelfTradePreventionMode {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "EXPIRE_TAKER" => Ok(Self::ExpireTaker),
                "EXPIRE_MAKER" => Ok(Self::ExpireMaker),
                "EXPIRE_BOTH" => Ok(Self::ExpireBoth),
                "NONE" => Ok(Self::None),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for SorOrderTestSelfTradePreventionMode {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for SorOrderTestSelfTradePreventionMode {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for SorOrderTestSelfTradePreventionMode {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///SorOrderTestSide
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "SELL"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "SELL",
    ///    "BUY"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum SorOrderTestSide {
        #[serde(rename = "SELL")]
        Sell,
        #[serde(rename = "BUY")]
        Buy,
    }
    impl From<&SorOrderTestSide> for SorOrderTestSide {
        fn from(value: &SorOrderTestSide) -> Self {
            value.clone()
        }
    }
    impl ToString for SorOrderTestSide {
        fn to_string(&self) -> String {
            match *self {
                Self::Sell => "SELL".to_string(),
                Self::Buy => "BUY".to_string(),
            }
        }
    }
    impl std::str::FromStr for SorOrderTestSide {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "SELL" => Ok(Self::Sell),
                "BUY" => Ok(Self::Buy),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for SorOrderTestSide {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for SorOrderTestSide {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for SorOrderTestSide {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///SorOrderTestTimeInForce
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "GTC"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "GTC",
    ///    "IOC",
    ///    "FOK"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum SorOrderTestTimeInForce {
        #[serde(rename = "GTC")]
        Gtc,
        #[serde(rename = "IOC")]
        Ioc,
        #[serde(rename = "FOK")]
        Fok,
    }
    impl From<&SorOrderTestTimeInForce> for SorOrderTestTimeInForce {
        fn from(value: &SorOrderTestTimeInForce) -> Self {
            value.clone()
        }
    }
    impl ToString for SorOrderTestTimeInForce {
        fn to_string(&self) -> String {
            match *self {
                Self::Gtc => "GTC".to_string(),
                Self::Ioc => "IOC".to_string(),
                Self::Fok => "FOK".to_string(),
            }
        }
    }
    impl std::str::FromStr for SorOrderTestTimeInForce {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "GTC" => Ok(Self::Gtc),
                "IOC" => Ok(Self::Ioc),
                "FOK" => Ok(Self::Fok),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for SorOrderTestTimeInForce {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for SorOrderTestTimeInForce {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for SorOrderTestTimeInForce {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///SorOrderTestType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "LIMIT"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "LIMIT",
    ///    "MARKET",
    ///    "STOP_LOSS",
    ///    "STOP_LOSS_LIMIT",
    ///    "TAKE_PROFIT",
    ///    "TAKE_PROFIT_LIMIT",
    ///    "LIMIT_MAKER"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum SorOrderTestType {
        #[serde(rename = "LIMIT")]
        Limit,
        #[serde(rename = "MARKET")]
        Market,
        #[serde(rename = "STOP_LOSS")]
        StopLoss,
        #[serde(rename = "STOP_LOSS_LIMIT")]
        StopLossLimit,
        #[serde(rename = "TAKE_PROFIT")]
        TakeProfit,
        #[serde(rename = "TAKE_PROFIT_LIMIT")]
        TakeProfitLimit,
        #[serde(rename = "LIMIT_MAKER")]
        LimitMaker,
    }
    impl From<&SorOrderTestType> for SorOrderTestType {
        fn from(value: &SorOrderTestType) -> Self {
            value.clone()
        }
    }
    impl ToString for SorOrderTestType {
        fn to_string(&self) -> String {
            match *self {
                Self::Limit => "LIMIT".to_string(),
                Self::Market => "MARKET".to_string(),
                Self::StopLoss => "STOP_LOSS".to_string(),
                Self::StopLossLimit => "STOP_LOSS_LIMIT".to_string(),
                Self::TakeProfit => "TAKE_PROFIT".to_string(),
                Self::TakeProfitLimit => "TAKE_PROFIT_LIMIT".to_string(),
                Self::LimitMaker => "LIMIT_MAKER".to_string(),
            }
        }
    }
    impl std::str::FromStr for SorOrderTestType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "LIMIT" => Ok(Self::Limit),
                "MARKET" => Ok(Self::Market),
                "STOP_LOSS" => Ok(Self::StopLoss),
                "STOP_LOSS_LIMIT" => Ok(Self::StopLossLimit),
                "TAKE_PROFIT" => Ok(Self::TakeProfit),
                "TAKE_PROFIT_LIMIT" => Ok(Self::TakeProfitLimit),
                "LIMIT_MAKER" => Ok(Self::LimitMaker),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for SorOrderTestType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for SorOrderTestType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for SorOrderTestType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///SorOrderTimeInForce
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "GTC"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "GTC",
    ///    "IOC",
    ///    "FOK"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum SorOrderTimeInForce {
        #[serde(rename = "GTC")]
        Gtc,
        #[serde(rename = "IOC")]
        Ioc,
        #[serde(rename = "FOK")]
        Fok,
    }
    impl From<&SorOrderTimeInForce> for SorOrderTimeInForce {
        fn from(value: &SorOrderTimeInForce) -> Self {
            value.clone()
        }
    }
    impl ToString for SorOrderTimeInForce {
        fn to_string(&self) -> String {
            match *self {
                Self::Gtc => "GTC".to_string(),
                Self::Ioc => "IOC".to_string(),
                Self::Fok => "FOK".to_string(),
            }
        }
    }
    impl std::str::FromStr for SorOrderTimeInForce {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "GTC" => Ok(Self::Gtc),
                "IOC" => Ok(Self::Ioc),
                "FOK" => Ok(Self::Fok),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for SorOrderTimeInForce {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for SorOrderTimeInForce {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for SorOrderTimeInForce {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///SorOrderType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "LIMIT"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "LIMIT",
    ///    "MARKET",
    ///    "STOP_LOSS",
    ///    "STOP_LOSS_LIMIT",
    ///    "TAKE_PROFIT",
    ///    "TAKE_PROFIT_LIMIT",
    ///    "LIMIT_MAKER"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum SorOrderType {
        #[serde(rename = "LIMIT")]
        Limit,
        #[serde(rename = "MARKET")]
        Market,
        #[serde(rename = "STOP_LOSS")]
        StopLoss,
        #[serde(rename = "STOP_LOSS_LIMIT")]
        StopLossLimit,
        #[serde(rename = "TAKE_PROFIT")]
        TakeProfit,
        #[serde(rename = "TAKE_PROFIT_LIMIT")]
        TakeProfitLimit,
        #[serde(rename = "LIMIT_MAKER")]
        LimitMaker,
    }
    impl From<&SorOrderType> for SorOrderType {
        fn from(value: &SorOrderType) -> Self {
            value.clone()
        }
    }
    impl ToString for SorOrderType {
        fn to_string(&self) -> String {
            match *self {
                Self::Limit => "LIMIT".to_string(),
                Self::Market => "MARKET".to_string(),
                Self::StopLoss => "STOP_LOSS".to_string(),
                Self::StopLossLimit => "STOP_LOSS_LIMIT".to_string(),
                Self::TakeProfit => "TAKE_PROFIT".to_string(),
                Self::TakeProfitLimit => "TAKE_PROFIT_LIMIT".to_string(),
                Self::LimitMaker => "LIMIT_MAKER".to_string(),
            }
        }
    }
    impl std::str::FromStr for SorOrderType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "LIMIT" => Ok(Self::Limit),
                "MARKET" => Ok(Self::Market),
                "STOP_LOSS" => Ok(Self::StopLoss),
                "STOP_LOSS_LIMIT" => Ok(Self::StopLossLimit),
                "TAKE_PROFIT" => Ok(Self::TakeProfit),
                "TAKE_PROFIT_LIMIT" => Ok(Self::TakeProfitLimit),
                "LIMIT_MAKER" => Ok(Self::LimitMaker),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for SorOrderType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for SorOrderType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for SorOrderType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///StakingPersonalLeftQuotaResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "leftPersonalQuota"
    ///  ],
    ///  "properties": {
    ///    "leftPersonalQuota": {
    ///      "examples": [
    ///        "1000"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct StakingPersonalLeftQuotaResponseItem {
        #[serde(rename = "leftPersonalQuota")]
        pub left_personal_quota: String,
    }
    impl From<&StakingPersonalLeftQuotaResponseItem>
    for StakingPersonalLeftQuotaResponseItem {
        fn from(value: &StakingPersonalLeftQuotaResponseItem) -> Self {
            value.clone()
        }
    }
    ///StakingPositionResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "APY",
    ///    "accrualDays",
    ///    "amount",
    ///    "asset",
    ///    "canRedeemEarly",
    ///    "deliverDate",
    ///    "duration",
    ///    "estExtraRewardAmt",
    ///    "extraRewardAPY",
    ///    "extraRewardAsset",
    ///    "interestEndDate",
    ///    "nextInterestPay",
    ///    "nextInterestPayDate",
    ///    "partialAmtDeliverDate",
    ///    "payInterestPeriod",
    ///    "positionId",
    ///    "projectId",
    ///    "purchaseTime",
    ///    "redeemAmountEarly",
    ///    "redeemPeriod",
    ///    "redeemingAmt",
    ///    "renewable",
    ///    "rewardAmt",
    ///    "rewardAsset",
    ///    "status",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "APY": {
    ///      "examples": [
    ///        "0.2032"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "accrualDays": {
    ///      "examples": [
    ///        "4"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "amount": {
    ///      "examples": [
    ///        "122.09202928"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "asset": {
    ///      "examples": [
    ///        "AXS"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "canRedeemEarly": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "deliverDate": {
    ///      "examples": [
    ///        "1651536000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "duration": {
    ///      "examples": [
    ///        "60"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "estExtraRewardAmt": {
    ///      "examples": [
    ///        "5.17181528"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "extraRewardAPY": {
    ///      "examples": [
    ///        "0.0203"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "extraRewardAsset": {
    ///      "examples": [
    ///        "BNB"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "interestEndDate": {
    ///      "examples": [
    ///        "1651449600000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "nextInterestPay": {
    ///      "examples": [
    ///        "1.29295383"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "nextInterestPayDate": {
    ///      "examples": [
    ///        "1646697600000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "partialAmtDeliverDate": {
    ///      "examples": [
    ///        "1651536000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "payInterestPeriod": {
    ///      "examples": [
    ///        "1"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "positionId": {
    ///      "examples": [
    ///        "123123"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "projectId": {
    ///      "examples": [
    ///        "Axs*90"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "purchaseTime": {
    ///      "examples": [
    ///        "1646182276000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "redeemAmountEarly": {
    ///      "examples": [
    ///        "2802.24068892"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "redeemPeriod": {
    ///      "examples": [
    ///        "1"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "redeemingAmt": {
    ///      "examples": [
    ///        "232.2323"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "renewable": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "rewardAmt": {
    ///      "examples": [
    ///        "5.17181528"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "rewardAsset": {
    ///      "examples": [
    ///        "AXS"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "examples": [
    ///        "HOLDING"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "examples": [
    ///        "AUTO"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct StakingPositionResponseItem {
        #[serde(rename = "accrualDays")]
        pub accrual_days: String,
        pub amount: String,
        #[serde(rename = "APY")]
        pub apy: String,
        pub asset: String,
        #[serde(rename = "canRedeemEarly")]
        pub can_redeem_early: bool,
        #[serde(rename = "deliverDate")]
        pub deliver_date: String,
        pub duration: String,
        #[serde(rename = "estExtraRewardAmt")]
        pub est_extra_reward_amt: String,
        #[serde(rename = "extraRewardAPY")]
        pub extra_reward_apy: String,
        #[serde(rename = "extraRewardAsset")]
        pub extra_reward_asset: String,
        #[serde(rename = "interestEndDate")]
        pub interest_end_date: String,
        #[serde(rename = "nextInterestPay")]
        pub next_interest_pay: String,
        #[serde(rename = "nextInterestPayDate")]
        pub next_interest_pay_date: String,
        #[serde(rename = "partialAmtDeliverDate")]
        pub partial_amt_deliver_date: String,
        #[serde(rename = "payInterestPeriod")]
        pub pay_interest_period: String,
        #[serde(rename = "positionId")]
        pub position_id: String,
        #[serde(rename = "projectId")]
        pub project_id: String,
        #[serde(rename = "purchaseTime")]
        pub purchase_time: String,
        #[serde(rename = "redeemAmountEarly")]
        pub redeem_amount_early: String,
        #[serde(rename = "redeemPeriod")]
        pub redeem_period: String,
        #[serde(rename = "redeemingAmt")]
        pub redeeming_amt: String,
        pub renewable: bool,
        #[serde(rename = "rewardAmt")]
        pub reward_amt: String,
        #[serde(rename = "rewardAsset")]
        pub reward_asset: String,
        pub status: String,
        #[serde(rename = "type")]
        pub type_: String,
    }
    impl From<&StakingPositionResponseItem> for StakingPositionResponseItem {
        fn from(value: &StakingPositionResponseItem) -> Self {
            value.clone()
        }
    }
    ///StakingProductListResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "detail",
    ///    "projectId",
    ///    "quota"
    ///  ],
    ///  "properties": {
    ///    "detail": {
    ///      "type": "object",
    ///      "required": [
    ///        "apy",
    ///        "asset",
    ///        "duration",
    ///        "renewable",
    ///        "rewardAsset"
    ///      ],
    ///      "properties": {
    ///        "apy": {
    ///          "examples": [
    ///            "1.2069"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "asset": {
    ///          "examples": [
    ///            "AXS"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "duration": {
    ///          "examples": [
    ///            90
    ///          ],
    ///          "type": "integer",
    ///          "format": "int64"
    ///        },
    ///        "renewable": {
    ///          "examples": [
    ///            true
    ///          ],
    ///          "type": "boolean"
    ///        },
    ///        "rewardAsset": {
    ///          "examples": [
    ///            "AXS"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "projectId": {
    ///      "examples": [
    ///        "Axs*90"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "quota": {
    ///      "type": "object",
    ///      "required": [
    ///        "minimum",
    ///        "totalPersonalQuota"
    ///      ],
    ///      "properties": {
    ///        "minimum": {
    ///          "examples": [
    ///            "0.001"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "totalPersonalQuota": {
    ///          "examples": [
    ///            "2"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct StakingProductListResponseItem {
        pub detail: StakingProductListResponseItemDetail,
        #[serde(rename = "projectId")]
        pub project_id: String,
        pub quota: StakingProductListResponseItemQuota,
    }
    impl From<&StakingProductListResponseItem> for StakingProductListResponseItem {
        fn from(value: &StakingProductListResponseItem) -> Self {
            value.clone()
        }
    }
    ///StakingProductListResponseItemDetail
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "apy",
    ///    "asset",
    ///    "duration",
    ///    "renewable",
    ///    "rewardAsset"
    ///  ],
    ///  "properties": {
    ///    "apy": {
    ///      "examples": [
    ///        "1.2069"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "asset": {
    ///      "examples": [
    ///        "AXS"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "duration": {
    ///      "examples": [
    ///        90
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "renewable": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "rewardAsset": {
    ///      "examples": [
    ///        "AXS"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct StakingProductListResponseItemDetail {
        pub apy: String,
        pub asset: String,
        pub duration: i64,
        pub renewable: bool,
        #[serde(rename = "rewardAsset")]
        pub reward_asset: String,
    }
    impl From<&StakingProductListResponseItemDetail>
    for StakingProductListResponseItemDetail {
        fn from(value: &StakingProductListResponseItemDetail) -> Self {
            value.clone()
        }
    }
    ///StakingProductListResponseItemQuota
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "minimum",
    ///    "totalPersonalQuota"
    ///  ],
    ///  "properties": {
    ///    "minimum": {
    ///      "examples": [
    ///        "0.001"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalPersonalQuota": {
    ///      "examples": [
    ///        "2"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct StakingProductListResponseItemQuota {
        pub minimum: String,
        #[serde(rename = "totalPersonalQuota")]
        pub total_personal_quota: String,
    }
    impl From<&StakingProductListResponseItemQuota>
    for StakingProductListResponseItemQuota {
        fn from(value: &StakingProductListResponseItemQuota) -> Self {
            value.clone()
        }
    }
    ///StakingPurchaseResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "positionId",
    ///    "success"
    ///  ],
    ///  "properties": {
    ///    "positionId": {
    ///      "examples": [
    ///        "12345"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "success": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct StakingPurchaseResponse {
        #[serde(rename = "positionId")]
        pub position_id: String,
        pub success: bool,
    }
    impl From<&StakingPurchaseResponse> for StakingPurchaseResponse {
        fn from(value: &StakingPurchaseResponse) -> Self {
            value.clone()
        }
    }
    ///StakingRedeemResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "success"
    ///  ],
    ///  "properties": {
    ///    "success": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct StakingRedeemResponse {
        pub success: bool,
    }
    impl From<&StakingRedeemResponse> for StakingRedeemResponse {
        fn from(value: &StakingRedeemResponse) -> Self {
            value.clone()
        }
    }
    ///StakingSetAutoStakingResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "success"
    ///  ],
    ///  "properties": {
    ///    "success": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct StakingSetAutoStakingResponse {
        pub success: bool,
    }
    impl From<&StakingSetAutoStakingResponse> for StakingSetAutoStakingResponse {
        fn from(value: &StakingSetAutoStakingResponse) -> Self {
            value.clone()
        }
    }
    ///StakingStakingRecordResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "asset",
    ///    "deliverDate",
    ///    "lockPeriod",
    ///    "positionId",
    ///    "project",
    ///    "status",
    ///    "time",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "examples": [
    ///        "21312.23223"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "asset": {
    ///      "examples": [
    ///        "BNB"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "deliverDate": {
    ///      "examples": [
    ///        "1575018510000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "lockPeriod": {
    ///      "examples": [
    ///        "30"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "positionId": {
    ///      "examples": [
    ///        "123123"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "project": {
    ///      "examples": [
    ///        "BSC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "examples": [
    ///        "success"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "time": {
    ///      "examples": [
    ///        1575018510000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "type": {
    ///      "examples": [
    ///        "AUTO"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct StakingStakingRecordResponseItem {
        pub amount: String,
        pub asset: String,
        #[serde(rename = "deliverDate")]
        pub deliver_date: String,
        #[serde(rename = "lockPeriod")]
        pub lock_period: String,
        #[serde(rename = "positionId")]
        pub position_id: String,
        pub project: String,
        pub status: String,
        pub time: i64,
        #[serde(rename = "type")]
        pub type_: String,
    }
    impl From<&StakingStakingRecordResponseItem> for StakingStakingRecordResponseItem {
        fn from(value: &StakingStakingRecordResponseItem) -> Self {
            value.clone()
        }
    }
    ///SubAccountBlvtEnableResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "email",
    ///    "enableBlvt"
    ///  ],
    ///  "properties": {
    ///    "email": {
    ///      "examples": [
    ///        "123@test.com"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "enableBlvt": {
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SubAccountBlvtEnableResponse {
        pub email: String,
        #[serde(rename = "enableBlvt")]
        pub enable_blvt: bool,
    }
    impl From<&SubAccountBlvtEnableResponse> for SubAccountBlvtEnableResponse {
        fn from(value: &SubAccountBlvtEnableResponse) -> Self {
            value.clone()
        }
    }
    ///SubAccountCoinFuturesDetails
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "assets",
    ///    "canDeposit",
    ///    "canTrade",
    ///    "canWithdraw",
    ///    "email",
    ///    "feeTier",
    ///    "updateTime"
    ///  ],
    ///  "properties": {
    ///    "assets": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "asset",
    ///          "initialMargin",
    ///          "maintenanceMargin",
    ///          "marginBalance",
    ///          "maxWithdrawAmount",
    ///          "openOrderInitialMargin",
    ///          "positionInitialMargin",
    ///          "unrealizedProfit",
    ///          "walletBalance"
    ///        ],
    ///        "properties": {
    ///          "asset": {
    ///            "examples": [
    ///              "BTC"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "initialMargin": {
    ///            "examples": [
    ///              "0.00000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "maintenanceMargin": {
    ///            "examples": [
    ///              "0.00000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "marginBalance": {
    ///            "examples": [
    ///              "0.88308000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "maxWithdrawAmount": {
    ///            "examples": [
    ///              "0.88308000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "openOrderInitialMargin": {
    ///            "examples": [
    ///              "0.00000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "positionInitialMargin": {
    ///            "examples": [
    ///              "0.00000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "unrealizedProfit": {
    ///            "examples": [
    ///              "0.00000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "walletBalance": {
    ///            "examples": [
    ///              "0.88308000"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "canDeposit": {
    ///      "type": "boolean"
    ///    },
    ///    "canTrade": {
    ///      "type": "boolean"
    ///    },
    ///    "canWithdraw": {
    ///      "type": "boolean"
    ///    },
    ///    "email": {
    ///      "examples": [
    ///        "abc@test.com"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "feeTier": {
    ///      "examples": [
    ///        2
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "updateTime": {
    ///      "examples": [
    ///        1598959682001
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SubAccountCoinFuturesDetails {
        pub assets: Vec<SubAccountCoinFuturesDetailsAssetsItem>,
        #[serde(rename = "canDeposit")]
        pub can_deposit: bool,
        #[serde(rename = "canTrade")]
        pub can_trade: bool,
        #[serde(rename = "canWithdraw")]
        pub can_withdraw: bool,
        pub email: String,
        #[serde(rename = "feeTier")]
        pub fee_tier: i64,
        #[serde(rename = "updateTime")]
        pub update_time: i64,
    }
    impl From<&SubAccountCoinFuturesDetails> for SubAccountCoinFuturesDetails {
        fn from(value: &SubAccountCoinFuturesDetails) -> Self {
            value.clone()
        }
    }
    ///SubAccountCoinFuturesDetailsAssetsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "asset",
    ///    "initialMargin",
    ///    "maintenanceMargin",
    ///    "marginBalance",
    ///    "maxWithdrawAmount",
    ///    "openOrderInitialMargin",
    ///    "positionInitialMargin",
    ///    "unrealizedProfit",
    ///    "walletBalance"
    ///  ],
    ///  "properties": {
    ///    "asset": {
    ///      "examples": [
    ///        "BTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "initialMargin": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "maintenanceMargin": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "marginBalance": {
    ///      "examples": [
    ///        "0.88308000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "maxWithdrawAmount": {
    ///      "examples": [
    ///        "0.88308000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "openOrderInitialMargin": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "positionInitialMargin": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "unrealizedProfit": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "walletBalance": {
    ///      "examples": [
    ///        "0.88308000"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SubAccountCoinFuturesDetailsAssetsItem {
        pub asset: String,
        #[serde(rename = "initialMargin")]
        pub initial_margin: String,
        #[serde(rename = "maintenanceMargin")]
        pub maintenance_margin: String,
        #[serde(rename = "marginBalance")]
        pub margin_balance: String,
        #[serde(rename = "maxWithdrawAmount")]
        pub max_withdraw_amount: String,
        #[serde(rename = "openOrderInitialMargin")]
        pub open_order_initial_margin: String,
        #[serde(rename = "positionInitialMargin")]
        pub position_initial_margin: String,
        #[serde(rename = "unrealizedProfit")]
        pub unrealized_profit: String,
        #[serde(rename = "walletBalance")]
        pub wallet_balance: String,
    }
    impl From<&SubAccountCoinFuturesDetailsAssetsItem>
    for SubAccountCoinFuturesDetailsAssetsItem {
        fn from(value: &SubAccountCoinFuturesDetailsAssetsItem) -> Self {
            value.clone()
        }
    }
    ///SubAccountCoinFuturesPositionRisk
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "deliveryPositionRiskVos"
    ///  ],
    ///  "properties": {
    ///    "deliveryPositionRiskVos": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "entryPrice",
    ///          "isAutoAddMargin",
    ///          "isolated",
    ///          "isolatedMargin",
    ///          "isolatedWallet",
    ///          "leverage",
    ///          "markPrice",
    ///          "positionAmount",
    ///          "positionSide",
    ///          "symbol",
    ///          "unrealizedProfit"
    ///        ],
    ///        "properties": {
    ///          "entryPrice": {
    ///            "examples": [
    ///              "9975.12000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "isAutoAddMargin": {
    ///            "examples": [
    ///              "false"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "isolated": {
    ///            "examples": [
    ///              false
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "isolatedMargin": {
    ///            "examples": [
    ///              "0.00000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "isolatedWallet": {
    ///            "examples": [
    ///              "9973.50770517"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "leverage": {
    ///            "examples": [
    ///              "20"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "markPrice": {
    ///            "examples": [
    ///              "9973.50770517"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "positionAmount": {
    ///            "examples": [
    ///              "1.230"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "positionSide": {
    ///            "examples": [
    ///              "BOTH"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "symbol": {
    ///            "examples": [
    ///              "BTCUSD_201225"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "unrealizedProfit": {
    ///            "examples": [
    ///              "-0.01612295"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SubAccountCoinFuturesPositionRisk {
        #[serde(rename = "deliveryPositionRiskVos")]
        pub delivery_position_risk_vos: Vec<
            SubAccountCoinFuturesPositionRiskDeliveryPositionRiskVosItem,
        >,
    }
    impl From<&SubAccountCoinFuturesPositionRisk> for SubAccountCoinFuturesPositionRisk {
        fn from(value: &SubAccountCoinFuturesPositionRisk) -> Self {
            value.clone()
        }
    }
    ///SubAccountCoinFuturesPositionRiskDeliveryPositionRiskVosItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "entryPrice",
    ///    "isAutoAddMargin",
    ///    "isolated",
    ///    "isolatedMargin",
    ///    "isolatedWallet",
    ///    "leverage",
    ///    "markPrice",
    ///    "positionAmount",
    ///    "positionSide",
    ///    "symbol",
    ///    "unrealizedProfit"
    ///  ],
    ///  "properties": {
    ///    "entryPrice": {
    ///      "examples": [
    ///        "9975.12000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "isAutoAddMargin": {
    ///      "examples": [
    ///        "false"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "isolated": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "isolatedMargin": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "isolatedWallet": {
    ///      "examples": [
    ///        "9973.50770517"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "leverage": {
    ///      "examples": [
    ///        "20"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "markPrice": {
    ///      "examples": [
    ///        "9973.50770517"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "positionAmount": {
    ///      "examples": [
    ///        "1.230"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "positionSide": {
    ///      "examples": [
    ///        "BOTH"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "symbol": {
    ///      "examples": [
    ///        "BTCUSD_201225"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "unrealizedProfit": {
    ///      "examples": [
    ///        "-0.01612295"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SubAccountCoinFuturesPositionRiskDeliveryPositionRiskVosItem {
        #[serde(rename = "entryPrice")]
        pub entry_price: String,
        #[serde(rename = "isAutoAddMargin")]
        pub is_auto_add_margin: String,
        pub isolated: String,
        #[serde(rename = "isolatedMargin")]
        pub isolated_margin: String,
        #[serde(rename = "isolatedWallet")]
        pub isolated_wallet: String,
        pub leverage: String,
        #[serde(rename = "markPrice")]
        pub mark_price: String,
        #[serde(rename = "positionAmount")]
        pub position_amount: String,
        #[serde(rename = "positionSide")]
        pub position_side: String,
        pub symbol: String,
        #[serde(rename = "unrealizedProfit")]
        pub unrealized_profit: String,
    }
    impl From<&SubAccountCoinFuturesPositionRiskDeliveryPositionRiskVosItem>
    for SubAccountCoinFuturesPositionRiskDeliveryPositionRiskVosItem {
        fn from(
            value: &SubAccountCoinFuturesPositionRiskDeliveryPositionRiskVosItem,
        ) -> Self {
            value.clone()
        }
    }
    ///SubAccountCoinFuturesSummary
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "deliveryAccountSummaryResp"
    ///  ],
    ///  "properties": {
    ///    "deliveryAccountSummaryResp": {
    ///      "type": "object",
    ///      "required": [
    ///        "asset",
    ///        "subAccountList",
    ///        "totalMarginBalanceOfBTC",
    ///        "totalUnrealizedProfitOfBTC",
    ///        "totalWalletBalanceOfBTC"
    ///      ],
    ///      "properties": {
    ///        "asset": {
    ///          "examples": [
    ///            "BTC"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "subAccountList": {
    ///          "type": "array",
    ///          "items": {
    ///            "type": "object",
    ///            "required": [
    ///              "asset",
    ///              "email",
    ///              "totalMarginBalance",
    ///              "totalUnrealizedProfit",
    ///              "totalWalletBalance"
    ///            ],
    ///            "properties": {
    ///              "asset": {
    ///                "examples": [
    ///                  "BTC"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "email": {
    ///                "examples": [
    ///                  "123@test.com"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "totalMarginBalance": {
    ///                "examples": [
    ///                  22.12659734
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "totalUnrealizedProfit": {
    ///                "examples": [
    ///                  0.0
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "totalWalletBalance": {
    ///                "examples": [
    ///                  22.12659734
    ///                ],
    ///                "type": "string"
    ///              }
    ///            }
    ///          }
    ///        },
    ///        "totalMarginBalanceOfBTC": {
    ///          "examples": [
    ///            25.03221121
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "totalUnrealizedProfitOfBTC": {
    ///          "examples": [
    ///            0.1223341
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "totalWalletBalanceOfBTC": {
    ///          "examples": [
    ///            22.15879444
    ///          ],
    ///          "type": "string"
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SubAccountCoinFuturesSummary {
        #[serde(rename = "deliveryAccountSummaryResp")]
        pub delivery_account_summary_resp: SubAccountCoinFuturesSummaryDeliveryAccountSummaryResp,
    }
    impl From<&SubAccountCoinFuturesSummary> for SubAccountCoinFuturesSummary {
        fn from(value: &SubAccountCoinFuturesSummary) -> Self {
            value.clone()
        }
    }
    ///SubAccountCoinFuturesSummaryDeliveryAccountSummaryResp
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "asset",
    ///    "subAccountList",
    ///    "totalMarginBalanceOfBTC",
    ///    "totalUnrealizedProfitOfBTC",
    ///    "totalWalletBalanceOfBTC"
    ///  ],
    ///  "properties": {
    ///    "asset": {
    ///      "examples": [
    ///        "BTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "subAccountList": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "asset",
    ///          "email",
    ///          "totalMarginBalance",
    ///          "totalUnrealizedProfit",
    ///          "totalWalletBalance"
    ///        ],
    ///        "properties": {
    ///          "asset": {
    ///            "examples": [
    ///              "BTC"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "email": {
    ///            "examples": [
    ///              "123@test.com"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "totalMarginBalance": {
    ///            "examples": [
    ///              22.12659734
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "totalUnrealizedProfit": {
    ///            "examples": [
    ///              0.0
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "totalWalletBalance": {
    ///            "examples": [
    ///              22.12659734
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "totalMarginBalanceOfBTC": {
    ///      "examples": [
    ///        25.03221121
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalUnrealizedProfitOfBTC": {
    ///      "examples": [
    ///        0.1223341
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalWalletBalanceOfBTC": {
    ///      "examples": [
    ///        22.15879444
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SubAccountCoinFuturesSummaryDeliveryAccountSummaryResp {
        pub asset: String,
        #[serde(rename = "subAccountList")]
        pub sub_account_list: Vec<
            SubAccountCoinFuturesSummaryDeliveryAccountSummaryRespSubAccountListItem,
        >,
        #[serde(rename = "totalMarginBalanceOfBTC")]
        pub total_margin_balance_of_btc: String,
        #[serde(rename = "totalUnrealizedProfitOfBTC")]
        pub total_unrealized_profit_of_btc: String,
        #[serde(rename = "totalWalletBalanceOfBTC")]
        pub total_wallet_balance_of_btc: String,
    }
    impl From<&SubAccountCoinFuturesSummaryDeliveryAccountSummaryResp>
    for SubAccountCoinFuturesSummaryDeliveryAccountSummaryResp {
        fn from(value: &SubAccountCoinFuturesSummaryDeliveryAccountSummaryResp) -> Self {
            value.clone()
        }
    }
    ///SubAccountCoinFuturesSummaryDeliveryAccountSummaryRespSubAccountListItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "asset",
    ///    "email",
    ///    "totalMarginBalance",
    ///    "totalUnrealizedProfit",
    ///    "totalWalletBalance"
    ///  ],
    ///  "properties": {
    ///    "asset": {
    ///      "examples": [
    ///        "BTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "email": {
    ///      "examples": [
    ///        "123@test.com"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalMarginBalance": {
    ///      "examples": [
    ///        22.12659734
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalUnrealizedProfit": {
    ///      "examples": [
    ///        0.0
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalWalletBalance": {
    ///      "examples": [
    ///        22.12659734
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SubAccountCoinFuturesSummaryDeliveryAccountSummaryRespSubAccountListItem {
        pub asset: String,
        pub email: String,
        #[serde(rename = "totalMarginBalance")]
        pub total_margin_balance: String,
        #[serde(rename = "totalUnrealizedProfit")]
        pub total_unrealized_profit: String,
        #[serde(rename = "totalWalletBalance")]
        pub total_wallet_balance: String,
    }
    impl From<&SubAccountCoinFuturesSummaryDeliveryAccountSummaryRespSubAccountListItem>
    for SubAccountCoinFuturesSummaryDeliveryAccountSummaryRespSubAccountListItem {
        fn from(
            value: &SubAccountCoinFuturesSummaryDeliveryAccountSummaryRespSubAccountListItem,
        ) -> Self {
            value.clone()
        }
    }
    ///SubAccountDeleteIpListResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "apiKey",
    ///    "ipList",
    ///    "ipRestrict",
    ///    "updateTime"
    ///  ],
    ///  "properties": {
    ///    "apiKey": {
    ///      "examples": [
    ///        "k5V49ldtn4tszj6W3hystegdfvmGbqDzjmkCtpTvC0G74WhK7yd4rfCTo4lShf"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "ipList": {
    ///      "examples": [
    ///        [
    ///          "69.210.67.14",
    ///          "thirdPartyName"
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string"
    ///      }
    ///    },
    ///    "ipRestrict": {
    ///      "examples": [
    ///        "true"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "updateTime": {
    ///      "examples": [
    ///        1636369557189
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SubAccountDeleteIpListResponse {
        #[serde(rename = "apiKey")]
        pub api_key: String,
        #[serde(rename = "ipList")]
        pub ip_list: Vec<String>,
        #[serde(rename = "ipRestrict")]
        pub ip_restrict: String,
        #[serde(rename = "updateTime")]
        pub update_time: i64,
    }
    impl From<&SubAccountDeleteIpListResponse> for SubAccountDeleteIpListResponse {
        fn from(value: &SubAccountDeleteIpListResponse) -> Self {
            value.clone()
        }
    }
    ///SubAccountEoptionsEnableResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "email",
    ///    "isEOptionsEnabled"
    ///  ],
    ///  "properties": {
    ///    "email": {
    ///      "examples": [
    ///        "alice@test.com"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "isEOptionsEnabled": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SubAccountEoptionsEnableResponse {
        pub email: String,
        #[serde(rename = "isEOptionsEnabled")]
        pub is_e_options_enabled: bool,
    }
    impl From<&SubAccountEoptionsEnableResponse> for SubAccountEoptionsEnableResponse {
        fn from(value: &SubAccountEoptionsEnableResponse) -> Self {
            value.clone()
        }
    }
    ///SubAccountFuturesAccountSummaryResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "asset",
    ///    "subAccountList",
    ///    "totalInitialMargin",
    ///    "totalMaintenanceMargin",
    ///    "totalMarginBalance",
    ///    "totalOpenOrderInitialMargin",
    ///    "totalPositionInitialMargin",
    ///    "totalUnrealizedProfit",
    ///    "totalWalletBalance"
    ///  ],
    ///  "properties": {
    ///    "asset": {
    ///      "examples": [
    ///        "USD"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "subAccountList": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "asset",
    ///          "email",
    ///          "totalInitialMargin",
    ///          "totalMaintenanceMargin",
    ///          "totalMarginBalance",
    ///          "totalOpenOrderInitialMargin",
    ///          "totalPositionInitialMargin",
    ///          "totalUnrealizedProfit",
    ///          "totalWalletBalance"
    ///        ],
    ///        "properties": {
    ///          "asset": {
    ///            "examples": [
    ///              "USD"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "email": {
    ///            "examples": [
    ///              "123@test.com"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "totalInitialMargin": {
    ///            "examples": [
    ///              "9.00000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "totalMaintenanceMargin": {
    ///            "examples": [
    ///              "0.00000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "totalMarginBalance": {
    ///            "examples": [
    ///              "22.12659734"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "totalOpenOrderInitialMargin": {
    ///            "examples": [
    ///              "9.00000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "totalPositionInitialMargin": {
    ///            "examples": [
    ///              "0.00000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "totalUnrealizedProfit": {
    ///            "examples": [
    ///              "0.00000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "totalWalletBalance": {
    ///            "examples": [
    ///              "22.12659734"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "totalInitialMargin": {
    ///      "examples": [
    ///        "9.83137400"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalMaintenanceMargin": {
    ///      "examples": [
    ///        "0.41568700"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalMarginBalance": {
    ///      "examples": [
    ///        "23.03235621"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalOpenOrderInitialMargin": {
    ///      "examples": [
    ///        "9.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalPositionInitialMargin": {
    ///      "examples": [
    ///        "0.83137400"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalUnrealizedProfit": {
    ///      "examples": [
    ///        "0.03219710"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalWalletBalance": {
    ///      "examples": [
    ///        "22.15879444"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SubAccountFuturesAccountSummaryResponse {
        pub asset: String,
        #[serde(rename = "subAccountList")]
        pub sub_account_list: Vec<
            SubAccountFuturesAccountSummaryResponseSubAccountListItem,
        >,
        #[serde(rename = "totalInitialMargin")]
        pub total_initial_margin: String,
        #[serde(rename = "totalMaintenanceMargin")]
        pub total_maintenance_margin: String,
        #[serde(rename = "totalMarginBalance")]
        pub total_margin_balance: String,
        #[serde(rename = "totalOpenOrderInitialMargin")]
        pub total_open_order_initial_margin: String,
        #[serde(rename = "totalPositionInitialMargin")]
        pub total_position_initial_margin: String,
        #[serde(rename = "totalUnrealizedProfit")]
        pub total_unrealized_profit: String,
        #[serde(rename = "totalWalletBalance")]
        pub total_wallet_balance: String,
    }
    impl From<&SubAccountFuturesAccountSummaryResponse>
    for SubAccountFuturesAccountSummaryResponse {
        fn from(value: &SubAccountFuturesAccountSummaryResponse) -> Self {
            value.clone()
        }
    }
    ///SubAccountFuturesAccountSummaryResponseSubAccountListItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "asset",
    ///    "email",
    ///    "totalInitialMargin",
    ///    "totalMaintenanceMargin",
    ///    "totalMarginBalance",
    ///    "totalOpenOrderInitialMargin",
    ///    "totalPositionInitialMargin",
    ///    "totalUnrealizedProfit",
    ///    "totalWalletBalance"
    ///  ],
    ///  "properties": {
    ///    "asset": {
    ///      "examples": [
    ///        "USD"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "email": {
    ///      "examples": [
    ///        "123@test.com"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalInitialMargin": {
    ///      "examples": [
    ///        "9.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalMaintenanceMargin": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalMarginBalance": {
    ///      "examples": [
    ///        "22.12659734"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalOpenOrderInitialMargin": {
    ///      "examples": [
    ///        "9.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalPositionInitialMargin": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalUnrealizedProfit": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalWalletBalance": {
    ///      "examples": [
    ///        "22.12659734"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SubAccountFuturesAccountSummaryResponseSubAccountListItem {
        pub asset: String,
        pub email: String,
        #[serde(rename = "totalInitialMargin")]
        pub total_initial_margin: String,
        #[serde(rename = "totalMaintenanceMargin")]
        pub total_maintenance_margin: String,
        #[serde(rename = "totalMarginBalance")]
        pub total_margin_balance: String,
        #[serde(rename = "totalOpenOrderInitialMargin")]
        pub total_open_order_initial_margin: String,
        #[serde(rename = "totalPositionInitialMargin")]
        pub total_position_initial_margin: String,
        #[serde(rename = "totalUnrealizedProfit")]
        pub total_unrealized_profit: String,
        #[serde(rename = "totalWalletBalance")]
        pub total_wallet_balance: String,
    }
    impl From<&SubAccountFuturesAccountSummaryResponseSubAccountListItem>
    for SubAccountFuturesAccountSummaryResponseSubAccountListItem {
        fn from(
            value: &SubAccountFuturesAccountSummaryResponseSubAccountListItem,
        ) -> Self {
            value.clone()
        }
    }
    ///SubAccountFuturesEnableResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "email",
    ///    "isFuturesEnabled"
    ///  ],
    ///  "properties": {
    ///    "email": {
    ///      "examples": [
    ///        "123@test.com"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "isFuturesEnabled": {
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SubAccountFuturesEnableResponse {
        pub email: String,
        #[serde(rename = "isFuturesEnabled")]
        pub is_futures_enabled: bool,
    }
    impl From<&SubAccountFuturesEnableResponse> for SubAccountFuturesEnableResponse {
        fn from(value: &SubAccountFuturesEnableResponse) -> Self {
            value.clone()
        }
    }
    ///SubAccountFuturesInternalTransferResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "futuresType",
    ///    "success",
    ///    "transfers"
    ///  ],
    ///  "properties": {
    ///    "futuresType": {
    ///      "examples": [
    ///        2
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    },
    ///    "success": {
    ///      "type": "boolean"
    ///    },
    ///    "transfers": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "asset",
    ///          "from",
    ///          "qty",
    ///          "time",
    ///          "to",
    ///          "tranId"
    ///        ],
    ///        "properties": {
    ///          "asset": {
    ///            "examples": [
    ///              "BTC"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "from": {
    ///            "examples": [
    ///              "aaa@test.com"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "qty": {
    ///            "examples": [
    ///              "1"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "time": {
    ///            "examples": [
    ///              1544433328000
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "to": {
    ///            "examples": [
    ///              "bbb@test.com"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "tranId": {
    ///            "examples": [
    ///              11897001102
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SubAccountFuturesInternalTransferResponse {
        #[serde(rename = "futuresType")]
        pub futures_type: i32,
        pub success: bool,
        pub transfers: Vec<SubAccountFuturesInternalTransferResponseTransfersItem>,
    }
    impl From<&SubAccountFuturesInternalTransferResponse>
    for SubAccountFuturesInternalTransferResponse {
        fn from(value: &SubAccountFuturesInternalTransferResponse) -> Self {
            value.clone()
        }
    }
    ///SubAccountFuturesInternalTransferResponseTransfersItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "asset",
    ///    "from",
    ///    "qty",
    ///    "time",
    ///    "to",
    ///    "tranId"
    ///  ],
    ///  "properties": {
    ///    "asset": {
    ///      "examples": [
    ///        "BTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "from": {
    ///      "examples": [
    ///        "aaa@test.com"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "qty": {
    ///      "examples": [
    ///        "1"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "time": {
    ///      "examples": [
    ///        1544433328000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "to": {
    ///      "examples": [
    ///        "bbb@test.com"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "tranId": {
    ///      "examples": [
    ///        11897001102
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SubAccountFuturesInternalTransferResponseTransfersItem {
        pub asset: String,
        pub from: String,
        pub qty: String,
        pub time: i64,
        pub to: String,
        #[serde(rename = "tranId")]
        pub tran_id: i64,
    }
    impl From<&SubAccountFuturesInternalTransferResponseTransfersItem>
    for SubAccountFuturesInternalTransferResponseTransfersItem {
        fn from(value: &SubAccountFuturesInternalTransferResponseTransfersItem) -> Self {
            value.clone()
        }
    }
    ///SubAccountFuturesPositionRiskResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "entryPrice",
    ///    "leverage",
    ///    "liquidationPrice",
    ///    "markPrice",
    ///    "maxNotional",
    ///    "positionAmount",
    ///    "symbol",
    ///    "unrealizedProfit"
    ///  ],
    ///  "properties": {
    ///    "entryPrice": {
    ///      "examples": [
    ///        "9975.12000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "leverage": {
    ///      "description": "current initial leverage",
    ///      "examples": [
    ///        "50"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "liquidationPrice": {
    ///      "examples": [
    ///        "7963.54"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "markPrice": {
    ///      "examples": [
    ///        "9973.50770517"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "maxNotional": {
    ///      "description": "notional value limit of current initial leverage",
    ///      "examples": [
    ///        "1000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "positionAmount": {
    ///      "examples": [
    ///        "0.010"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "symbol": {
    ///      "examples": [
    ///        "BTCUSDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "unrealizedProfit": {
    ///      "examples": [
    ///        "-0.01612295"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SubAccountFuturesPositionRiskResponseItem {
        #[serde(rename = "entryPrice")]
        pub entry_price: String,
        ///current initial leverage
        pub leverage: String,
        #[serde(rename = "liquidationPrice")]
        pub liquidation_price: String,
        #[serde(rename = "markPrice")]
        pub mark_price: String,
        ///notional value limit of current initial leverage
        #[serde(rename = "maxNotional")]
        pub max_notional: String,
        #[serde(rename = "positionAmount")]
        pub position_amount: String,
        pub symbol: String,
        #[serde(rename = "unrealizedProfit")]
        pub unrealized_profit: String,
    }
    impl From<&SubAccountFuturesPositionRiskResponseItem>
    for SubAccountFuturesPositionRiskResponseItem {
        fn from(value: &SubAccountFuturesPositionRiskResponseItem) -> Self {
            value.clone()
        }
    }
    ///SubAccountFuturesTransferResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "txnId"
    ///  ],
    ///  "properties": {
    ///    "txnId": {
    ///      "examples": [
    ///        "2966662589"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SubAccountFuturesTransferResponse {
        #[serde(rename = "txnId")]
        pub txn_id: String,
    }
    impl From<&SubAccountFuturesTransferResponse> for SubAccountFuturesTransferResponse {
        fn from(value: &SubAccountFuturesTransferResponse) -> Self {
            value.clone()
        }
    }
    ///SubAccountListIsFreeze
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "true",
    ///    "false"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum SubAccountListIsFreeze {
        #[serde(rename = "true")]
        True,
        #[serde(rename = "false")]
        False,
    }
    impl From<&SubAccountListIsFreeze> for SubAccountListIsFreeze {
        fn from(value: &SubAccountListIsFreeze) -> Self {
            value.clone()
        }
    }
    impl ToString for SubAccountListIsFreeze {
        fn to_string(&self) -> String {
            match *self {
                Self::True => "true".to_string(),
                Self::False => "false".to_string(),
            }
        }
    }
    impl std::str::FromStr for SubAccountListIsFreeze {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "true" => Ok(Self::True),
                "false" => Ok(Self::False),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for SubAccountListIsFreeze {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for SubAccountListIsFreeze {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for SubAccountListIsFreeze {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///SubAccountListResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "subAccounts"
    ///  ],
    ///  "properties": {
    ///    "subAccounts": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "createTime",
    ///          "email",
    ///          "isAssetManagementSubAccount",
    ///          "isFreeze",
    ///          "isManagedSubAccount"
    ///        ],
    ///        "properties": {
    ///          "createTime": {
    ///            "examples": [
    ///              1544433328000
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "email": {
    ///            "examples": [
    ///              "testsub@gmail.com"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "isAssetManagementSubAccount": {
    ///            "examples": [
    ///              false
    ///            ],
    ///            "type": "boolean"
    ///          },
    ///          "isFreeze": {
    ///            "examples": [
    ///              false
    ///            ],
    ///            "type": "boolean"
    ///          },
    ///          "isManagedSubAccount": {
    ///            "examples": [
    ///              false
    ///            ],
    ///            "type": "boolean"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SubAccountListResponse {
        #[serde(rename = "subAccounts")]
        pub sub_accounts: Vec<SubAccountListResponseSubAccountsItem>,
    }
    impl From<&SubAccountListResponse> for SubAccountListResponse {
        fn from(value: &SubAccountListResponse) -> Self {
            value.clone()
        }
    }
    ///SubAccountListResponseSubAccountsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "createTime",
    ///    "email",
    ///    "isAssetManagementSubAccount",
    ///    "isFreeze",
    ///    "isManagedSubAccount"
    ///  ],
    ///  "properties": {
    ///    "createTime": {
    ///      "examples": [
    ///        1544433328000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "email": {
    ///      "examples": [
    ///        "testsub@gmail.com"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "isAssetManagementSubAccount": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "isFreeze": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "isManagedSubAccount": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SubAccountListResponseSubAccountsItem {
        #[serde(rename = "createTime")]
        pub create_time: i64,
        pub email: String,
        #[serde(rename = "isAssetManagementSubAccount")]
        pub is_asset_management_sub_account: bool,
        #[serde(rename = "isFreeze")]
        pub is_freeze: bool,
        #[serde(rename = "isManagedSubAccount")]
        pub is_managed_sub_account: bool,
    }
    impl From<&SubAccountListResponseSubAccountsItem>
    for SubAccountListResponseSubAccountsItem {
        fn from(value: &SubAccountListResponseSubAccountsItem) -> Self {
            value.clone()
        }
    }
    ///SubAccountMarginAccountResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "email",
    ///    "marginLevel",
    ///    "marginTradeCoeffVo",
    ///    "marginUserAssetVoList",
    ///    "totalAssetOfBtc",
    ///    "totalLiabilityOfBtc",
    ///    "totalNetAssetOfBtc"
    ///  ],
    ///  "properties": {
    ///    "email": {
    ///      "examples": [
    ///        "123@test.com"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "marginLevel": {
    ///      "examples": [
    ///        "11.64405625"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "marginTradeCoeffVo": {
    ///      "type": "object",
    ///      "required": [
    ///        "forceLiquidationBar",
    ///        "marginCallBar",
    ///        "normalBar"
    ///      ],
    ///      "properties": {
    ///        "forceLiquidationBar": {
    ///          "description": "Liquidation margin ratio",
    ///          "examples": [
    ///            "1.10000000"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "marginCallBar": {
    ///          "description": "Margin call margin ratio",
    ///          "examples": [
    ///            "1.50000000"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "normalBar": {
    ///          "description": "Initial margin ratio",
    ///          "examples": [
    ///            "2.00000000"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "marginUserAssetVoList": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "asset",
    ///          "borrowed",
    ///          "free",
    ///          "interest",
    ///          "locked",
    ///          "netAsset"
    ///        ],
    ///        "properties": {
    ///          "asset": {
    ///            "examples": [
    ///              "BTC"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "borrowed": {
    ///            "examples": [
    ///              "0.00000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "free": {
    ///            "examples": [
    ///              "0.00499500"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "interest": {
    ///            "examples": [
    ///              "0.00000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "locked": {
    ///            "examples": [
    ///              "0.00000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "netAsset": {
    ///            "examples": [
    ///              "0.00499500"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "totalAssetOfBtc": {
    ///      "examples": [
    ///        "6.82728457"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalLiabilityOfBtc": {
    ///      "examples": [
    ///        "0.58633215"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalNetAssetOfBtc": {
    ///      "examples": [
    ///        "6.24095242"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SubAccountMarginAccountResponse {
        pub email: String,
        #[serde(rename = "marginLevel")]
        pub margin_level: String,
        #[serde(rename = "marginTradeCoeffVo")]
        pub margin_trade_coeff_vo: SubAccountMarginAccountResponseMarginTradeCoeffVo,
        #[serde(rename = "marginUserAssetVoList")]
        pub margin_user_asset_vo_list: Vec<
            SubAccountMarginAccountResponseMarginUserAssetVoListItem,
        >,
        #[serde(rename = "totalAssetOfBtc")]
        pub total_asset_of_btc: String,
        #[serde(rename = "totalLiabilityOfBtc")]
        pub total_liability_of_btc: String,
        #[serde(rename = "totalNetAssetOfBtc")]
        pub total_net_asset_of_btc: String,
    }
    impl From<&SubAccountMarginAccountResponse> for SubAccountMarginAccountResponse {
        fn from(value: &SubAccountMarginAccountResponse) -> Self {
            value.clone()
        }
    }
    ///SubAccountMarginAccountResponseMarginTradeCoeffVo
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "forceLiquidationBar",
    ///    "marginCallBar",
    ///    "normalBar"
    ///  ],
    ///  "properties": {
    ///    "forceLiquidationBar": {
    ///      "description": "Liquidation margin ratio",
    ///      "examples": [
    ///        "1.10000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "marginCallBar": {
    ///      "description": "Margin call margin ratio",
    ///      "examples": [
    ///        "1.50000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "normalBar": {
    ///      "description": "Initial margin ratio",
    ///      "examples": [
    ///        "2.00000000"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SubAccountMarginAccountResponseMarginTradeCoeffVo {
        ///Liquidation margin ratio
        #[serde(rename = "forceLiquidationBar")]
        pub force_liquidation_bar: String,
        ///Margin call margin ratio
        #[serde(rename = "marginCallBar")]
        pub margin_call_bar: String,
        ///Initial margin ratio
        #[serde(rename = "normalBar")]
        pub normal_bar: String,
    }
    impl From<&SubAccountMarginAccountResponseMarginTradeCoeffVo>
    for SubAccountMarginAccountResponseMarginTradeCoeffVo {
        fn from(value: &SubAccountMarginAccountResponseMarginTradeCoeffVo) -> Self {
            value.clone()
        }
    }
    ///SubAccountMarginAccountResponseMarginUserAssetVoListItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "asset",
    ///    "borrowed",
    ///    "free",
    ///    "interest",
    ///    "locked",
    ///    "netAsset"
    ///  ],
    ///  "properties": {
    ///    "asset": {
    ///      "examples": [
    ///        "BTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "borrowed": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "free": {
    ///      "examples": [
    ///        "0.00499500"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "interest": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "locked": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "netAsset": {
    ///      "examples": [
    ///        "0.00499500"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SubAccountMarginAccountResponseMarginUserAssetVoListItem {
        pub asset: String,
        pub borrowed: String,
        pub free: String,
        pub interest: String,
        pub locked: String,
        #[serde(rename = "netAsset")]
        pub net_asset: String,
    }
    impl From<&SubAccountMarginAccountResponseMarginUserAssetVoListItem>
    for SubAccountMarginAccountResponseMarginUserAssetVoListItem {
        fn from(
            value: &SubAccountMarginAccountResponseMarginUserAssetVoListItem,
        ) -> Self {
            value.clone()
        }
    }
    ///SubAccountMarginAccountSummaryResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "subAccountList",
    ///    "totalAssetOfBtc",
    ///    "totalLiabilityOfBtc",
    ///    "totalNetAssetOfBtc"
    ///  ],
    ///  "properties": {
    ///    "subAccountList": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "email",
    ///          "totalAssetOfBtc",
    ///          "totalLiabilityOfBtc",
    ///          "totalNetAssetOfBtc"
    ///        ],
    ///        "properties": {
    ///          "email": {
    ///            "examples": [
    ///              "123@test.com"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "totalAssetOfBtc": {
    ///            "examples": [
    ///              "2.11111111"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "totalLiabilityOfBtc": {
    ///            "examples": [
    ///              "1.11111111"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "totalNetAssetOfBtc": {
    ///            "examples": [
    ///              "1.00000000"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "totalAssetOfBtc": {
    ///      "examples": [
    ///        "4.33333333"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalLiabilityOfBtc": {
    ///      "examples": [
    ///        "2.11111112"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalNetAssetOfBtc": {
    ///      "examples": [
    ///        "2.22222221"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SubAccountMarginAccountSummaryResponse {
        #[serde(rename = "subAccountList")]
        pub sub_account_list: Vec<
            SubAccountMarginAccountSummaryResponseSubAccountListItem,
        >,
        #[serde(rename = "totalAssetOfBtc")]
        pub total_asset_of_btc: String,
        #[serde(rename = "totalLiabilityOfBtc")]
        pub total_liability_of_btc: String,
        #[serde(rename = "totalNetAssetOfBtc")]
        pub total_net_asset_of_btc: String,
    }
    impl From<&SubAccountMarginAccountSummaryResponse>
    for SubAccountMarginAccountSummaryResponse {
        fn from(value: &SubAccountMarginAccountSummaryResponse) -> Self {
            value.clone()
        }
    }
    ///SubAccountMarginAccountSummaryResponseSubAccountListItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "email",
    ///    "totalAssetOfBtc",
    ///    "totalLiabilityOfBtc",
    ///    "totalNetAssetOfBtc"
    ///  ],
    ///  "properties": {
    ///    "email": {
    ///      "examples": [
    ///        "123@test.com"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalAssetOfBtc": {
    ///      "examples": [
    ///        "2.11111111"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalLiabilityOfBtc": {
    ///      "examples": [
    ///        "1.11111111"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalNetAssetOfBtc": {
    ///      "examples": [
    ///        "1.00000000"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SubAccountMarginAccountSummaryResponseSubAccountListItem {
        pub email: String,
        #[serde(rename = "totalAssetOfBtc")]
        pub total_asset_of_btc: String,
        #[serde(rename = "totalLiabilityOfBtc")]
        pub total_liability_of_btc: String,
        #[serde(rename = "totalNetAssetOfBtc")]
        pub total_net_asset_of_btc: String,
    }
    impl From<&SubAccountMarginAccountSummaryResponseSubAccountListItem>
    for SubAccountMarginAccountSummaryResponseSubAccountListItem {
        fn from(
            value: &SubAccountMarginAccountSummaryResponseSubAccountListItem,
        ) -> Self {
            value.clone()
        }
    }
    ///SubAccountMarginEnableResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "email",
    ///    "isMarginEnabled"
    ///  ],
    ///  "properties": {
    ///    "email": {
    ///      "examples": [
    ///        "123@test.com"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "isMarginEnabled": {
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SubAccountMarginEnableResponse {
        pub email: String,
        #[serde(rename = "isMarginEnabled")]
        pub is_margin_enabled: bool,
    }
    impl From<&SubAccountMarginEnableResponse> for SubAccountMarginEnableResponse {
        fn from(value: &SubAccountMarginEnableResponse) -> Self {
            value.clone()
        }
    }
    ///SubAccountMarginTransferResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "txnId"
    ///  ],
    ///  "properties": {
    ///    "txnId": {
    ///      "examples": [
    ///        "2966662589"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SubAccountMarginTransferResponse {
        #[serde(rename = "txnId")]
        pub txn_id: String,
    }
    impl From<&SubAccountMarginTransferResponse> for SubAccountMarginTransferResponse {
        fn from(value: &SubAccountMarginTransferResponse) -> Self {
            value.clone()
        }
    }
    ///SubAccountSpotSummaryResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "masterAccountTotalAsset",
    ///    "spotSubUserAssetBtcVoList",
    ///    "totalCount"
    ///  ],
    ///  "properties": {
    ///    "masterAccountTotalAsset": {
    ///      "examples": [
    ///        "0.23231201"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "spotSubUserAssetBtcVoList": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "email",
    ///          "totalAsset"
    ///        ],
    ///        "properties": {
    ///          "email": {
    ///            "examples": [
    ///              "sub123@test.com"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "totalAsset": {
    ///            "examples": [
    ///              "9999.00000000"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "totalCount": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SubAccountSpotSummaryResponse {
        #[serde(rename = "masterAccountTotalAsset")]
        pub master_account_total_asset: String,
        #[serde(rename = "spotSubUserAssetBtcVoList")]
        pub spot_sub_user_asset_btc_vo_list: Vec<
            SubAccountSpotSummaryResponseSpotSubUserAssetBtcVoListItem,
        >,
        #[serde(rename = "totalCount")]
        pub total_count: i64,
    }
    impl From<&SubAccountSpotSummaryResponse> for SubAccountSpotSummaryResponse {
        fn from(value: &SubAccountSpotSummaryResponse) -> Self {
            value.clone()
        }
    }
    ///SubAccountSpotSummaryResponseSpotSubUserAssetBtcVoListItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "email",
    ///    "totalAsset"
    ///  ],
    ///  "properties": {
    ///    "email": {
    ///      "examples": [
    ///        "sub123@test.com"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalAsset": {
    ///      "examples": [
    ///        "9999.00000000"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SubAccountSpotSummaryResponseSpotSubUserAssetBtcVoListItem {
        pub email: String,
        #[serde(rename = "totalAsset")]
        pub total_asset: String,
    }
    impl From<&SubAccountSpotSummaryResponseSpotSubUserAssetBtcVoListItem>
    for SubAccountSpotSummaryResponseSpotSubUserAssetBtcVoListItem {
        fn from(
            value: &SubAccountSpotSummaryResponseSpotSubUserAssetBtcVoListItem,
        ) -> Self {
            value.clone()
        }
    }
    ///SubAccountStatusResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "email",
    ///    "insertTime",
    ///    "isFutureEnabled",
    ///    "isMarginEnabled",
    ///    "isSubUserEnabled",
    ///    "isUserActive",
    ///    "mobile"
    ///  ],
    ///  "properties": {
    ///    "email": {
    ///      "examples": [
    ///        "123@test.com"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "insertTime": {
    ///      "description": "sub account create time",
    ///      "examples": [
    ///        1570791523523
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "isFutureEnabled": {
    ///      "type": "boolean"
    ///    },
    ///    "isMarginEnabled": {
    ///      "type": "boolean"
    ///    },
    ///    "isSubUserEnabled": {
    ///      "type": "boolean"
    ///    },
    ///    "isUserActive": {
    ///      "type": "boolean"
    ///    },
    ///    "mobile": {
    ///      "description": "user mobile number",
    ///      "examples": [
    ///        1570791523523
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SubAccountStatusResponseItem {
        pub email: String,
        ///sub account create time
        #[serde(rename = "insertTime")]
        pub insert_time: i64,
        #[serde(rename = "isFutureEnabled")]
        pub is_future_enabled: bool,
        #[serde(rename = "isMarginEnabled")]
        pub is_margin_enabled: bool,
        #[serde(rename = "isSubUserEnabled")]
        pub is_sub_user_enabled: bool,
        #[serde(rename = "isUserActive")]
        pub is_user_active: bool,
        ///user mobile number
        pub mobile: i64,
    }
    impl From<&SubAccountStatusResponseItem> for SubAccountStatusResponseItem {
        fn from(value: &SubAccountStatusResponseItem) -> Self {
            value.clone()
        }
    }
    ///SubAccountSubTransferHistoryResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "asset",
    ///    "from",
    ///    "qty",
    ///    "status",
    ///    "time",
    ///    "to",
    ///    "tranId"
    ///  ],
    ///  "properties": {
    ///    "asset": {
    ///      "examples": [
    ///        "BTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "from": {
    ///      "examples": [
    ///        "aaa@test.com"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "qty": {
    ///      "examples": [
    ///        10
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "examples": [
    ///        "SUCCESS"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "time": {
    ///      "examples": [
    ///        1544433328000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "to": {
    ///      "examples": [
    ///        "bbb@test.com"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "tranId": {
    ///      "examples": [
    ///        6489943656
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SubAccountSubTransferHistoryResponseItem {
        pub asset: String,
        pub from: String,
        pub qty: String,
        pub status: String,
        pub time: i64,
        pub to: String,
        #[serde(rename = "tranId")]
        pub tran_id: i64,
    }
    impl From<&SubAccountSubTransferHistoryResponseItem>
    for SubAccountSubTransferHistoryResponseItem {
        fn from(value: &SubAccountSubTransferHistoryResponseItem) -> Self {
            value.clone()
        }
    }
    ///SubAccountTransactionStatisticsResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "recent30BtcFuturesTotal",
    ///    "recent30BtcMarginTotal",
    ///    "recent30BtcTotal",
    ///    "recent30BusdFuturesTotal",
    ///    "recent30BusdMarginTotal",
    ///    "recent30BusdTotal",
    ///    "tradeInfoVos"
    ///  ],
    ///  "properties": {
    ///    "recent30BtcFuturesTotal": {
    ///      "examples": [
    ///        "0"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "recent30BtcMarginTotal": {
    ///      "examples": [
    ///        "0"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "recent30BtcTotal": {
    ///      "examples": [
    ///        "0"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "recent30BusdFuturesTotal": {
    ///      "examples": [
    ///        "0"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "recent30BusdMarginTotal": {
    ///      "examples": [
    ///        "0"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "recent30BusdTotal": {
    ///      "examples": [
    ///        "0"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "tradeInfoVos": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "properties": {
    ///          "btc": {
    ///            "examples": [
    ///              0
    ///            ],
    ///            "type": "number",
    ///            "format": "float"
    ///          },
    ///          "btcFutures": {
    ///            "examples": [
    ///              0
    ///            ],
    ///            "type": "number",
    ///            "format": "float"
    ///          },
    ///          "btcMargin": {
    ///            "examples": [
    ///              0
    ///            ],
    ///            "type": "number",
    ///            "format": "float"
    ///          },
    ///          "busd": {
    ///            "examples": [
    ///              0
    ///            ],
    ///            "type": "number",
    ///            "format": "float"
    ///          },
    ///          "busdFutures": {
    ///            "examples": [
    ///              0
    ///            ],
    ///            "type": "number",
    ///            "format": "float"
    ///          },
    ///          "busdMargin": {
    ///            "examples": [
    ///              0
    ///            ],
    ///            "type": "number",
    ///            "format": "float"
    ///          },
    ///          "date": {
    ///            "examples": [
    ///              1676851200000
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          },
    ///          "userId": {
    ///            "examples": [
    ///              1000138138384
    ///            ],
    ///            "type": "integer",
    ///            "format": "int64"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SubAccountTransactionStatisticsResponse {
        #[serde(rename = "recent30BtcFuturesTotal")]
        pub recent30_btc_futures_total: String,
        #[serde(rename = "recent30BtcMarginTotal")]
        pub recent30_btc_margin_total: String,
        #[serde(rename = "recent30BtcTotal")]
        pub recent30_btc_total: String,
        #[serde(rename = "recent30BusdFuturesTotal")]
        pub recent30_busd_futures_total: String,
        #[serde(rename = "recent30BusdMarginTotal")]
        pub recent30_busd_margin_total: String,
        #[serde(rename = "recent30BusdTotal")]
        pub recent30_busd_total: String,
        #[serde(rename = "tradeInfoVos")]
        pub trade_info_vos: Vec<SubAccountTransactionStatisticsResponseTradeInfoVosItem>,
    }
    impl From<&SubAccountTransactionStatisticsResponse>
    for SubAccountTransactionStatisticsResponse {
        fn from(value: &SubAccountTransactionStatisticsResponse) -> Self {
            value.clone()
        }
    }
    ///SubAccountTransactionStatisticsResponseTradeInfoVosItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "btc": {
    ///      "examples": [
    ///        0
    ///      ],
    ///      "type": "number",
    ///      "format": "float"
    ///    },
    ///    "btcFutures": {
    ///      "examples": [
    ///        0
    ///      ],
    ///      "type": "number",
    ///      "format": "float"
    ///    },
    ///    "btcMargin": {
    ///      "examples": [
    ///        0
    ///      ],
    ///      "type": "number",
    ///      "format": "float"
    ///    },
    ///    "busd": {
    ///      "examples": [
    ///        0
    ///      ],
    ///      "type": "number",
    ///      "format": "float"
    ///    },
    ///    "busdFutures": {
    ///      "examples": [
    ///        0
    ///      ],
    ///      "type": "number",
    ///      "format": "float"
    ///    },
    ///    "busdMargin": {
    ///      "examples": [
    ///        0
    ///      ],
    ///      "type": "number",
    ///      "format": "float"
    ///    },
    ///    "date": {
    ///      "examples": [
    ///        1676851200000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "userId": {
    ///      "examples": [
    ///        1000138138384
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SubAccountTransactionStatisticsResponseTradeInfoVosItem {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub btc: Option<f32>,
        #[serde(rename = "btcFutures", default, skip_serializing_if = "Option::is_none")]
        pub btc_futures: Option<f32>,
        #[serde(rename = "btcMargin", default, skip_serializing_if = "Option::is_none")]
        pub btc_margin: Option<f32>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub busd: Option<f32>,
        #[serde(
            rename = "busdFutures",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub busd_futures: Option<f32>,
        #[serde(rename = "busdMargin", default, skip_serializing_if = "Option::is_none")]
        pub busd_margin: Option<f32>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub date: Option<i64>,
        #[serde(rename = "userId", default, skip_serializing_if = "Option::is_none")]
        pub user_id: Option<i64>,
    }
    impl From<&SubAccountTransactionStatisticsResponseTradeInfoVosItem>
    for SubAccountTransactionStatisticsResponseTradeInfoVosItem {
        fn from(
            value: &SubAccountTransactionStatisticsResponseTradeInfoVosItem,
        ) -> Self {
            value.clone()
        }
    }
    ///SubAccountTransferSubToMasterResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "txnId"
    ///  ],
    ///  "properties": {
    ///    "txnId": {
    ///      "examples": [
    ///        "2966662589"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SubAccountTransferSubToMasterResponse {
        #[serde(rename = "txnId")]
        pub txn_id: String,
    }
    impl From<&SubAccountTransferSubToMasterResponse>
    for SubAccountTransferSubToMasterResponse {
        fn from(value: &SubAccountTransferSubToMasterResponse) -> Self {
            value.clone()
        }
    }
    ///SubAccountTransferSubToSubResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "txnId"
    ///  ],
    ///  "properties": {
    ///    "txnId": {
    ///      "examples": [
    ///        "2966662589"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SubAccountTransferSubToSubResponse {
        #[serde(rename = "txnId")]
        pub txn_id: String,
    }
    impl From<&SubAccountTransferSubToSubResponse>
    for SubAccountTransferSubToSubResponse {
        fn from(value: &SubAccountTransferSubToSubResponse) -> Self {
            value.clone()
        }
    }
    ///SubAccountTransferSubUserHistoryResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "asset",
    ///    "counterParty",
    ///    "email",
    ///    "fromAccountType",
    ///    "qty",
    ///    "status",
    ///    "time",
    ///    "toAccountType",
    ///    "tranId",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "asset": {
    ///      "examples": [
    ///        "BTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "counterParty": {
    ///      "examples": [
    ///        "master"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "email": {
    ///      "examples": [
    ///        "master@test.com"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "fromAccountType": {
    ///      "examples": [
    ///        "SPOT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "qty": {
    ///      "examples": [
    ///        "1"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "examples": [
    ///        "SUCCESS"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "time": {
    ///      "examples": [
    ///        1544433325000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "toAccountType": {
    ///      "examples": [
    ///        "SPOT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "tranId": {
    ///      "examples": [
    ///        11798835829
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "type": {
    ///      "description": "1 for transfer in, 2 for transfer out",
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SubAccountTransferSubUserHistoryResponseItem {
        pub asset: String,
        #[serde(rename = "counterParty")]
        pub counter_party: String,
        pub email: String,
        #[serde(rename = "fromAccountType")]
        pub from_account_type: String,
        pub qty: String,
        pub status: String,
        pub time: i64,
        #[serde(rename = "toAccountType")]
        pub to_account_type: String,
        #[serde(rename = "tranId")]
        pub tran_id: i64,
        ///1 for transfer in, 2 for transfer out
        #[serde(rename = "type")]
        pub type_: i32,
    }
    impl From<&SubAccountTransferSubUserHistoryResponseItem>
    for SubAccountTransferSubUserHistoryResponseItem {
        fn from(value: &SubAccountTransferSubUserHistoryResponseItem) -> Self {
            value.clone()
        }
    }
    ///SubAccountUniversalTransferResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "asset",
    ///    "clientTranId",
    ///    "createTimeStamp",
    ///    "fromAccountType",
    ///    "fromEmail",
    ///    "status",
    ///    "toAccountType",
    ///    "toEmail",
    ///    "tranId"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "examples": [
    ///        "0.1"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "asset": {
    ///      "examples": [
    ///        "BTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "clientTranId": {
    ///      "examples": [
    ///        "11945860694"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "createTimeStamp": {
    ///      "examples": [
    ///        1544433325000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "fromAccountType": {
    ///      "examples": [
    ///        "SPOT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "fromEmail": {
    ///      "examples": [
    ///        "master@test.com"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "examples": [
    ///        "SUCCESS"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "toAccountType": {
    ///      "examples": [
    ///        "COIN_FUTURE"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "toEmail": {
    ///      "examples": [
    ///        "subaccount1@test.com"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "tranId": {
    ///      "examples": [
    ///        11945860693
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SubAccountUniversalTransferResponseItem {
        pub amount: String,
        pub asset: String,
        #[serde(rename = "clientTranId")]
        pub client_tran_id: String,
        #[serde(rename = "createTimeStamp")]
        pub create_time_stamp: i64,
        #[serde(rename = "fromAccountType")]
        pub from_account_type: String,
        #[serde(rename = "fromEmail")]
        pub from_email: String,
        pub status: String,
        #[serde(rename = "toAccountType")]
        pub to_account_type: String,
        #[serde(rename = "toEmail")]
        pub to_email: String,
        #[serde(rename = "tranId")]
        pub tran_id: i64,
    }
    impl From<&SubAccountUniversalTransferResponseItem>
    for SubAccountUniversalTransferResponseItem {
        fn from(value: &SubAccountUniversalTransferResponseItem) -> Self {
            value.clone()
        }
    }
    ///SubAccountUsdtFuturesDetails
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "futureAccountResp"
    ///  ],
    ///  "properties": {
    ///    "futureAccountResp": {
    ///      "type": "object",
    ///      "required": [
    ///        "assets",
    ///        "canDeposit",
    ///        "canTrade",
    ///        "canWithdraw",
    ///        "email",
    ///        "feeTier",
    ///        "maxWithdrawAmount",
    ///        "totalInitialMargin",
    ///        "totalMaintenanceMargin",
    ///        "totalMarginBalance",
    ///        "totalOpenOrderInitialMargin",
    ///        "totalPositionInitialMargin",
    ///        "totalUnrealizedProfit",
    ///        "totalWalletBalance",
    ///        "updateTime"
    ///      ],
    ///      "properties": {
    ///        "assets": {
    ///          "type": "array",
    ///          "items": {
    ///            "type": "object",
    ///            "required": [
    ///              "asset",
    ///              "initialMargin",
    ///              "maintenanceMargin",
    ///              "marginBalance",
    ///              "maxWithdrawAmount",
    ///              "openOrderInitialMargin",
    ///              "positionInitialMargin",
    ///              "unrealizedProfit",
    ///              "walletBalance"
    ///            ],
    ///            "properties": {
    ///              "asset": {
    ///                "examples": [
    ///                  "USDT"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "initialMargin": {
    ///                "examples": [
    ///                  "0.00000000"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "maintenanceMargin": {
    ///                "examples": [
    ///                  "0.00000000"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "marginBalance": {
    ///                "examples": [
    ///                  "0.88308000"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "maxWithdrawAmount": {
    ///                "examples": [
    ///                  "0.88308000"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "openOrderInitialMargin": {
    ///                "examples": [
    ///                  "0.00000000"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "positionInitialMargin": {
    ///                "examples": [
    ///                  "0.00000000"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "unrealizedProfit": {
    ///                "examples": [
    ///                  "0.00000000"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "walletBalance": {
    ///                "examples": [
    ///                  "0.88308000"
    ///                ],
    ///                "type": "string"
    ///              }
    ///            }
    ///          }
    ///        },
    ///        "canDeposit": {
    ///          "type": "boolean"
    ///        },
    ///        "canTrade": {
    ///          "type": "boolean"
    ///        },
    ///        "canWithdraw": {
    ///          "type": "boolean"
    ///        },
    ///        "email": {
    ///          "examples": [
    ///            "abc@test.com"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "feeTier": {
    ///          "examples": [
    ///            2
    ///          ],
    ///          "type": "integer",
    ///          "format": "int64"
    ///        },
    ///        "maxWithdrawAmount": {
    ///          "examples": [
    ///            "0.88308000"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "totalInitialMargin": {
    ///          "examples": [
    ///            "0.00000000"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "totalMaintenanceMargin": {
    ///          "examples": [
    ///            "0.00000000"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "totalMarginBalance": {
    ///          "examples": [
    ///            "0.88308000"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "totalOpenOrderInitialMargin": {
    ///          "examples": [
    ///            "0.00000000"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "totalPositionInitialMargin": {
    ///          "examples": [
    ///            "0.00000000"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "totalUnrealizedProfit": {
    ///          "examples": [
    ///            "0.00000000"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "totalWalletBalance": {
    ///          "examples": [
    ///            "0.88308000"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "updateTime": {
    ///          "examples": [
    ///            1576756674610
    ///          ],
    ///          "type": "integer",
    ///          "format": "int64"
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SubAccountUsdtFuturesDetails {
        #[serde(rename = "futureAccountResp")]
        pub future_account_resp: SubAccountUsdtFuturesDetailsFutureAccountResp,
    }
    impl From<&SubAccountUsdtFuturesDetails> for SubAccountUsdtFuturesDetails {
        fn from(value: &SubAccountUsdtFuturesDetails) -> Self {
            value.clone()
        }
    }
    ///SubAccountUsdtFuturesDetailsFutureAccountResp
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "assets",
    ///    "canDeposit",
    ///    "canTrade",
    ///    "canWithdraw",
    ///    "email",
    ///    "feeTier",
    ///    "maxWithdrawAmount",
    ///    "totalInitialMargin",
    ///    "totalMaintenanceMargin",
    ///    "totalMarginBalance",
    ///    "totalOpenOrderInitialMargin",
    ///    "totalPositionInitialMargin",
    ///    "totalUnrealizedProfit",
    ///    "totalWalletBalance",
    ///    "updateTime"
    ///  ],
    ///  "properties": {
    ///    "assets": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "asset",
    ///          "initialMargin",
    ///          "maintenanceMargin",
    ///          "marginBalance",
    ///          "maxWithdrawAmount",
    ///          "openOrderInitialMargin",
    ///          "positionInitialMargin",
    ///          "unrealizedProfit",
    ///          "walletBalance"
    ///        ],
    ///        "properties": {
    ///          "asset": {
    ///            "examples": [
    ///              "USDT"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "initialMargin": {
    ///            "examples": [
    ///              "0.00000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "maintenanceMargin": {
    ///            "examples": [
    ///              "0.00000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "marginBalance": {
    ///            "examples": [
    ///              "0.88308000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "maxWithdrawAmount": {
    ///            "examples": [
    ///              "0.88308000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "openOrderInitialMargin": {
    ///            "examples": [
    ///              "0.00000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "positionInitialMargin": {
    ///            "examples": [
    ///              "0.00000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "unrealizedProfit": {
    ///            "examples": [
    ///              "0.00000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "walletBalance": {
    ///            "examples": [
    ///              "0.88308000"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "canDeposit": {
    ///      "type": "boolean"
    ///    },
    ///    "canTrade": {
    ///      "type": "boolean"
    ///    },
    ///    "canWithdraw": {
    ///      "type": "boolean"
    ///    },
    ///    "email": {
    ///      "examples": [
    ///        "abc@test.com"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "feeTier": {
    ///      "examples": [
    ///        2
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "maxWithdrawAmount": {
    ///      "examples": [
    ///        "0.88308000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalInitialMargin": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalMaintenanceMargin": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalMarginBalance": {
    ///      "examples": [
    ///        "0.88308000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalOpenOrderInitialMargin": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalPositionInitialMargin": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalUnrealizedProfit": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalWalletBalance": {
    ///      "examples": [
    ///        "0.88308000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "updateTime": {
    ///      "examples": [
    ///        1576756674610
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SubAccountUsdtFuturesDetailsFutureAccountResp {
        pub assets: Vec<SubAccountUsdtFuturesDetailsFutureAccountRespAssetsItem>,
        #[serde(rename = "canDeposit")]
        pub can_deposit: bool,
        #[serde(rename = "canTrade")]
        pub can_trade: bool,
        #[serde(rename = "canWithdraw")]
        pub can_withdraw: bool,
        pub email: String,
        #[serde(rename = "feeTier")]
        pub fee_tier: i64,
        #[serde(rename = "maxWithdrawAmount")]
        pub max_withdraw_amount: String,
        #[serde(rename = "totalInitialMargin")]
        pub total_initial_margin: String,
        #[serde(rename = "totalMaintenanceMargin")]
        pub total_maintenance_margin: String,
        #[serde(rename = "totalMarginBalance")]
        pub total_margin_balance: String,
        #[serde(rename = "totalOpenOrderInitialMargin")]
        pub total_open_order_initial_margin: String,
        #[serde(rename = "totalPositionInitialMargin")]
        pub total_position_initial_margin: String,
        #[serde(rename = "totalUnrealizedProfit")]
        pub total_unrealized_profit: String,
        #[serde(rename = "totalWalletBalance")]
        pub total_wallet_balance: String,
        #[serde(rename = "updateTime")]
        pub update_time: i64,
    }
    impl From<&SubAccountUsdtFuturesDetailsFutureAccountResp>
    for SubAccountUsdtFuturesDetailsFutureAccountResp {
        fn from(value: &SubAccountUsdtFuturesDetailsFutureAccountResp) -> Self {
            value.clone()
        }
    }
    ///SubAccountUsdtFuturesDetailsFutureAccountRespAssetsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "asset",
    ///    "initialMargin",
    ///    "maintenanceMargin",
    ///    "marginBalance",
    ///    "maxWithdrawAmount",
    ///    "openOrderInitialMargin",
    ///    "positionInitialMargin",
    ///    "unrealizedProfit",
    ///    "walletBalance"
    ///  ],
    ///  "properties": {
    ///    "asset": {
    ///      "examples": [
    ///        "USDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "initialMargin": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "maintenanceMargin": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "marginBalance": {
    ///      "examples": [
    ///        "0.88308000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "maxWithdrawAmount": {
    ///      "examples": [
    ///        "0.88308000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "openOrderInitialMargin": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "positionInitialMargin": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "unrealizedProfit": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "walletBalance": {
    ///      "examples": [
    ///        "0.88308000"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SubAccountUsdtFuturesDetailsFutureAccountRespAssetsItem {
        pub asset: String,
        #[serde(rename = "initialMargin")]
        pub initial_margin: String,
        #[serde(rename = "maintenanceMargin")]
        pub maintenance_margin: String,
        #[serde(rename = "marginBalance")]
        pub margin_balance: String,
        #[serde(rename = "maxWithdrawAmount")]
        pub max_withdraw_amount: String,
        #[serde(rename = "openOrderInitialMargin")]
        pub open_order_initial_margin: String,
        #[serde(rename = "positionInitialMargin")]
        pub position_initial_margin: String,
        #[serde(rename = "unrealizedProfit")]
        pub unrealized_profit: String,
        #[serde(rename = "walletBalance")]
        pub wallet_balance: String,
    }
    impl From<&SubAccountUsdtFuturesDetailsFutureAccountRespAssetsItem>
    for SubAccountUsdtFuturesDetailsFutureAccountRespAssetsItem {
        fn from(
            value: &SubAccountUsdtFuturesDetailsFutureAccountRespAssetsItem,
        ) -> Self {
            value.clone()
        }
    }
    ///SubAccountUsdtFuturesPositionRisk
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "futurePositionRiskVos"
    ///  ],
    ///  "properties": {
    ///    "futurePositionRiskVos": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "entryPrice",
    ///          "leverage",
    ///          "liquidationPrice",
    ///          "markPrice",
    ///          "maxNotional",
    ///          "positionAmount",
    ///          "symbol",
    ///          "unrealizedProfit"
    ///        ],
    ///        "properties": {
    ///          "entryPrice": {
    ///            "examples": [
    ///              "9975.12000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "leverage": {
    ///            "description": "current initial leverage",
    ///            "examples": [
    ///              "50"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "liquidationPrice": {
    ///            "examples": [
    ///              "7963.54"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "markPrice": {
    ///            "examples": [
    ///              "9973.50770517"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "maxNotional": {
    ///            "description": "notional value limit of current initial leverage",
    ///            "examples": [
    ///              "1000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "positionAmount": {
    ///            "examples": [
    ///              "0.010"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "symbol": {
    ///            "examples": [
    ///              "BTCUSDT"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "unrealizedProfit": {
    ///            "examples": [
    ///              "-0.01612295"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SubAccountUsdtFuturesPositionRisk {
        #[serde(rename = "futurePositionRiskVos")]
        pub future_position_risk_vos: Vec<
            SubAccountUsdtFuturesPositionRiskFuturePositionRiskVosItem,
        >,
    }
    impl From<&SubAccountUsdtFuturesPositionRisk> for SubAccountUsdtFuturesPositionRisk {
        fn from(value: &SubAccountUsdtFuturesPositionRisk) -> Self {
            value.clone()
        }
    }
    ///SubAccountUsdtFuturesPositionRiskFuturePositionRiskVosItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "entryPrice",
    ///    "leverage",
    ///    "liquidationPrice",
    ///    "markPrice",
    ///    "maxNotional",
    ///    "positionAmount",
    ///    "symbol",
    ///    "unrealizedProfit"
    ///  ],
    ///  "properties": {
    ///    "entryPrice": {
    ///      "examples": [
    ///        "9975.12000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "leverage": {
    ///      "description": "current initial leverage",
    ///      "examples": [
    ///        "50"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "liquidationPrice": {
    ///      "examples": [
    ///        "7963.54"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "markPrice": {
    ///      "examples": [
    ///        "9973.50770517"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "maxNotional": {
    ///      "description": "notional value limit of current initial leverage",
    ///      "examples": [
    ///        "1000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "positionAmount": {
    ///      "examples": [
    ///        "0.010"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "symbol": {
    ///      "examples": [
    ///        "BTCUSDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "unrealizedProfit": {
    ///      "examples": [
    ///        "-0.01612295"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SubAccountUsdtFuturesPositionRiskFuturePositionRiskVosItem {
        #[serde(rename = "entryPrice")]
        pub entry_price: String,
        ///current initial leverage
        pub leverage: String,
        #[serde(rename = "liquidationPrice")]
        pub liquidation_price: String,
        #[serde(rename = "markPrice")]
        pub mark_price: String,
        ///notional value limit of current initial leverage
        #[serde(rename = "maxNotional")]
        pub max_notional: String,
        #[serde(rename = "positionAmount")]
        pub position_amount: String,
        pub symbol: String,
        #[serde(rename = "unrealizedProfit")]
        pub unrealized_profit: String,
    }
    impl From<&SubAccountUsdtFuturesPositionRiskFuturePositionRiskVosItem>
    for SubAccountUsdtFuturesPositionRiskFuturePositionRiskVosItem {
        fn from(
            value: &SubAccountUsdtFuturesPositionRiskFuturePositionRiskVosItem,
        ) -> Self {
            value.clone()
        }
    }
    ///SubAccountUsdtFuturesSummary
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "futureAccountSummaryResp"
    ///  ],
    ///  "properties": {
    ///    "futureAccountSummaryResp": {
    ///      "type": "object",
    ///      "required": [
    ///        "asset",
    ///        "subAccountList",
    ///        "totalInitialMargin",
    ///        "totalMaintenanceMargin",
    ///        "totalMarginBalance",
    ///        "totalOpenOrderInitialMargin",
    ///        "totalPositionInitialMargin",
    ///        "totalUnrealizedProfit",
    ///        "totalWalletBalance"
    ///      ],
    ///      "properties": {
    ///        "asset": {
    ///          "description": "The sum of BUSD and USDT",
    ///          "examples": [
    ///            "USD"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "subAccountList": {
    ///          "type": "array",
    ///          "items": {
    ///            "type": "object",
    ///            "required": [
    ///              "asset",
    ///              "email",
    ///              "totalInitialMargin",
    ///              "totalMaintenanceMargin",
    ///              "totalMarginBalance",
    ///              "totalOpenOrderInitialMargin",
    ///              "totalPositionInitialMargin",
    ///              "totalUnrealizedProfit",
    ///              "totalWalletBalance"
    ///            ],
    ///            "properties": {
    ///              "asset": {
    ///                "description": "The sum of BUSD and USDT",
    ///                "examples": [
    ///                  "USD"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "email": {
    ///                "examples": [
    ///                  "123@test.com"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "totalInitialMargin": {
    ///                "examples": [
    ///                  "9.00000000"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "totalMaintenanceMargin": {
    ///                "examples": [
    ///                  "0.00000000"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "totalMarginBalance": {
    ///                "examples": [
    ///                  "22.12659734"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "totalOpenOrderInitialMargin": {
    ///                "examples": [
    ///                  "9.00000000"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "totalPositionInitialMargin": {
    ///                "examples": [
    ///                  "0.00000000"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "totalUnrealizedProfit": {
    ///                "examples": [
    ///                  "0.00000000"
    ///                ],
    ///                "type": "string"
    ///              },
    ///              "totalWalletBalance": {
    ///                "examples": [
    ///                  "22.12659734"
    ///                ],
    ///                "type": "string"
    ///              }
    ///            }
    ///          }
    ///        },
    ///        "totalInitialMargin": {
    ///          "examples": [
    ///            "9.83137400"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "totalMaintenanceMargin": {
    ///          "examples": [
    ///            "0.41568700"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "totalMarginBalance": {
    ///          "examples": [
    ///            "23.03235621"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "totalOpenOrderInitialMargin": {
    ///          "examples": [
    ///            "9.00000000"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "totalPositionInitialMargin": {
    ///          "examples": [
    ///            "0.83137400"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "totalUnrealizedProfit": {
    ///          "examples": [
    ///            "0.03219710"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "totalWalletBalance": {
    ///          "examples": [
    ///            "22.15879444"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SubAccountUsdtFuturesSummary {
        #[serde(rename = "futureAccountSummaryResp")]
        pub future_account_summary_resp: SubAccountUsdtFuturesSummaryFutureAccountSummaryResp,
    }
    impl From<&SubAccountUsdtFuturesSummary> for SubAccountUsdtFuturesSummary {
        fn from(value: &SubAccountUsdtFuturesSummary) -> Self {
            value.clone()
        }
    }
    ///SubAccountUsdtFuturesSummaryFutureAccountSummaryResp
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "asset",
    ///    "subAccountList",
    ///    "totalInitialMargin",
    ///    "totalMaintenanceMargin",
    ///    "totalMarginBalance",
    ///    "totalOpenOrderInitialMargin",
    ///    "totalPositionInitialMargin",
    ///    "totalUnrealizedProfit",
    ///    "totalWalletBalance"
    ///  ],
    ///  "properties": {
    ///    "asset": {
    ///      "description": "The sum of BUSD and USDT",
    ///      "examples": [
    ///        "USD"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "subAccountList": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "asset",
    ///          "email",
    ///          "totalInitialMargin",
    ///          "totalMaintenanceMargin",
    ///          "totalMarginBalance",
    ///          "totalOpenOrderInitialMargin",
    ///          "totalPositionInitialMargin",
    ///          "totalUnrealizedProfit",
    ///          "totalWalletBalance"
    ///        ],
    ///        "properties": {
    ///          "asset": {
    ///            "description": "The sum of BUSD and USDT",
    ///            "examples": [
    ///              "USD"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "email": {
    ///            "examples": [
    ///              "123@test.com"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "totalInitialMargin": {
    ///            "examples": [
    ///              "9.00000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "totalMaintenanceMargin": {
    ///            "examples": [
    ///              "0.00000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "totalMarginBalance": {
    ///            "examples": [
    ///              "22.12659734"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "totalOpenOrderInitialMargin": {
    ///            "examples": [
    ///              "9.00000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "totalPositionInitialMargin": {
    ///            "examples": [
    ///              "0.00000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "totalUnrealizedProfit": {
    ///            "examples": [
    ///              "0.00000000"
    ///            ],
    ///            "type": "string"
    ///          },
    ///          "totalWalletBalance": {
    ///            "examples": [
    ///              "22.12659734"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "totalInitialMargin": {
    ///      "examples": [
    ///        "9.83137400"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalMaintenanceMargin": {
    ///      "examples": [
    ///        "0.41568700"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalMarginBalance": {
    ///      "examples": [
    ///        "23.03235621"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalOpenOrderInitialMargin": {
    ///      "examples": [
    ///        "9.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalPositionInitialMargin": {
    ///      "examples": [
    ///        "0.83137400"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalUnrealizedProfit": {
    ///      "examples": [
    ///        "0.03219710"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalWalletBalance": {
    ///      "examples": [
    ///        "22.15879444"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SubAccountUsdtFuturesSummaryFutureAccountSummaryResp {
        ///The sum of BUSD and USDT
        pub asset: String,
        #[serde(rename = "subAccountList")]
        pub sub_account_list: Vec<
            SubAccountUsdtFuturesSummaryFutureAccountSummaryRespSubAccountListItem,
        >,
        #[serde(rename = "totalInitialMargin")]
        pub total_initial_margin: String,
        #[serde(rename = "totalMaintenanceMargin")]
        pub total_maintenance_margin: String,
        #[serde(rename = "totalMarginBalance")]
        pub total_margin_balance: String,
        #[serde(rename = "totalOpenOrderInitialMargin")]
        pub total_open_order_initial_margin: String,
        #[serde(rename = "totalPositionInitialMargin")]
        pub total_position_initial_margin: String,
        #[serde(rename = "totalUnrealizedProfit")]
        pub total_unrealized_profit: String,
        #[serde(rename = "totalWalletBalance")]
        pub total_wallet_balance: String,
    }
    impl From<&SubAccountUsdtFuturesSummaryFutureAccountSummaryResp>
    for SubAccountUsdtFuturesSummaryFutureAccountSummaryResp {
        fn from(value: &SubAccountUsdtFuturesSummaryFutureAccountSummaryResp) -> Self {
            value.clone()
        }
    }
    ///SubAccountUsdtFuturesSummaryFutureAccountSummaryRespSubAccountListItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "asset",
    ///    "email",
    ///    "totalInitialMargin",
    ///    "totalMaintenanceMargin",
    ///    "totalMarginBalance",
    ///    "totalOpenOrderInitialMargin",
    ///    "totalPositionInitialMargin",
    ///    "totalUnrealizedProfit",
    ///    "totalWalletBalance"
    ///  ],
    ///  "properties": {
    ///    "asset": {
    ///      "description": "The sum of BUSD and USDT",
    ///      "examples": [
    ///        "USD"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "email": {
    ///      "examples": [
    ///        "123@test.com"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalInitialMargin": {
    ///      "examples": [
    ///        "9.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalMaintenanceMargin": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalMarginBalance": {
    ///      "examples": [
    ///        "22.12659734"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalOpenOrderInitialMargin": {
    ///      "examples": [
    ///        "9.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalPositionInitialMargin": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalUnrealizedProfit": {
    ///      "examples": [
    ///        "0.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "totalWalletBalance": {
    ///      "examples": [
    ///        "22.12659734"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SubAccountUsdtFuturesSummaryFutureAccountSummaryRespSubAccountListItem {
        ///The sum of BUSD and USDT
        pub asset: String,
        pub email: String,
        #[serde(rename = "totalInitialMargin")]
        pub total_initial_margin: String,
        #[serde(rename = "totalMaintenanceMargin")]
        pub total_maintenance_margin: String,
        #[serde(rename = "totalMarginBalance")]
        pub total_margin_balance: String,
        #[serde(rename = "totalOpenOrderInitialMargin")]
        pub total_open_order_initial_margin: String,
        #[serde(rename = "totalPositionInitialMargin")]
        pub total_position_initial_margin: String,
        #[serde(rename = "totalUnrealizedProfit")]
        pub total_unrealized_profit: String,
        #[serde(rename = "totalWalletBalance")]
        pub total_wallet_balance: String,
    }
    impl From<&SubAccountUsdtFuturesSummaryFutureAccountSummaryRespSubAccountListItem>
    for SubAccountUsdtFuturesSummaryFutureAccountSummaryRespSubAccountListItem {
        fn from(
            value: &SubAccountUsdtFuturesSummaryFutureAccountSummaryRespSubAccountListItem,
        ) -> Self {
            value.clone()
        }
    }
    ///SubAccountVirtualSubAccountResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "email"
    ///  ],
    ///  "properties": {
    ///    "email": {
    ///      "examples": [
    ///        "addsdd_virtual@aasaixwqnoemail.com"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SubAccountVirtualSubAccountResponse {
        pub email: String,
    }
    impl From<&SubAccountVirtualSubAccountResponse>
    for SubAccountVirtualSubAccountResponse {
        fn from(value: &SubAccountVirtualSubAccountResponse) -> Self {
            value.clone()
        }
    }
    ///SwapHistoryResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "baseAsset",
    ///    "baseQty",
    ///    "fee",
    ///    "price",
    ///    "quoteAsset",
    ///    "quoteQty",
    ///    "status",
    ///    "swapId",
    ///    "swapTime"
    ///  ],
    ///  "properties": {
    ///    "baseAsset": {
    ///      "examples": [
    ///        "BUSD"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "baseQty": {
    ///      "examples": [
    ///        299975
    ///      ],
    ///      "type": "number",
    ///      "format": "double"
    ///    },
    ///    "fee": {
    ///      "examples": [
    ///        120
    ///      ],
    ///      "type": "number",
    ///      "format": "double"
    ///    },
    ///    "price": {
    ///      "examples": [
    ///        1.00008334
    ///      ],
    ///      "type": "number",
    ///      "format": "double"
    ///    },
    ///    "quoteAsset": {
    ///      "examples": [
    ///        "USDT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "quoteQty": {
    ///      "examples": [
    ///        300000
    ///      ],
    ///      "type": "number",
    ///      "format": "double"
    ///    },
    ///    "status": {
    ///      "description": "0: pending, 1: success, 2: failed",
    ///      "examples": [
    ///        0
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    },
    ///    "swapId": {
    ///      "examples": [
    ///        2314
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "swapTime": {
    ///      "examples": [
    ///        1565770342148
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SwapHistoryResponseItem {
        #[serde(rename = "baseAsset")]
        pub base_asset: String,
        #[serde(rename = "baseQty")]
        pub base_qty: f64,
        pub fee: f64,
        pub price: f64,
        #[serde(rename = "quoteAsset")]
        pub quote_asset: String,
        #[serde(rename = "quoteQty")]
        pub quote_qty: f64,
        ///0: pending, 1: success, 2: failed
        pub status: i32,
        #[serde(rename = "swapId")]
        pub swap_id: i64,
        #[serde(rename = "swapTime")]
        pub swap_time: i64,
    }
    impl From<&SwapHistoryResponseItem> for SwapHistoryResponseItem {
        fn from(value: &SwapHistoryResponseItem) -> Self {
            value.clone()
        }
    }
    ///SystemStatusResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "msg",
    ///    "status"
    ///  ],
    ///  "properties": {
    ///    "msg": {
    ///      "description": "\"normal\", \"system_maintenance\"",
    ///      "examples": [
    ///        "normal"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "description": "0: normal, 1system maintenance",
    ///      "examples": [
    ///        0
    ///      ],
    ///      "type": "integer",
    ///      "format": "int32"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SystemStatusResponse {
        ///"normal", "system_maintenance"
        pub msg: String,
        ///0: normal, 1system maintenance
        pub status: i32,
    }
    impl From<&SystemStatusResponse> for SystemStatusResponse {
        fn from(value: &SystemStatusResponse) -> Self {
            value.clone()
        }
    }
    ///Ticker
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "askPrice",
    ///    "askQty",
    ///    "bidPrice",
    ///    "bidQty",
    ///    "closeTime",
    ///    "count",
    ///    "firstId",
    ///    "highPrice",
    ///    "lastId",
    ///    "lastPrice",
    ///    "lowPrice",
    ///    "openPrice",
    ///    "openTime",
    ///    "prevClosePrice",
    ///    "priceChange",
    ///    "priceChangePercent",
    ///    "quoteVolume",
    ///    "symbol",
    ///    "volume"
    ///  ],
    ///  "properties": {
    ///    "askPrice": {
    ///      "examples": [
    ///        "16.35920000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "askQty": {
    ///      "examples": [
    ///        "25.06000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "bidPrice": {
    ///      "examples": [
    ///        "16.34488284"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "bidQty": {
    ///      "examples": [
    ///        "16.34488284"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "closeTime": {
    ///      "examples": [
    ///        1592895188637
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "count": {
    ///      "examples": [
    ///        55958
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "firstId": {
    ///      "examples": [
    ///        62683296
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "highPrice": {
    ///      "examples": [
    ///        "16.55000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "lastId": {
    ///      "examples": [
    ///        62739253
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "lastPrice": {
    ///      "examples": [
    ///        "27.84000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "lowPrice": {
    ///      "examples": [
    ///        "16.16940000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "openPrice": {
    ///      "examples": [
    ///        "16.18760000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "openTime": {
    ///      "examples": [
    ///        1592808788637
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "prevClosePrice": {
    ///      "examples": [
    ///        "16.35920000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "priceChange": {
    ///      "examples": [
    ///        "0.17160000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "priceChangePercent": {
    ///      "examples": [
    ///        "1.060"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "quoteVolume": {
    ///      "examples": [
    ///        "27431289.14792300"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "symbol": {
    ///      "examples": [
    ///        "BNBBTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "volume": {
    ///      "examples": [
    ///        "1678279.95000000"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct Ticker {
        #[serde(rename = "askPrice")]
        pub ask_price: String,
        #[serde(rename = "askQty")]
        pub ask_qty: String,
        #[serde(rename = "bidPrice")]
        pub bid_price: String,
        #[serde(rename = "bidQty")]
        pub bid_qty: String,
        #[serde(rename = "closeTime")]
        pub close_time: i64,
        pub count: i64,
        #[serde(rename = "firstId")]
        pub first_id: i64,
        #[serde(rename = "highPrice")]
        pub high_price: String,
        #[serde(rename = "lastId")]
        pub last_id: i64,
        #[serde(rename = "lastPrice")]
        pub last_price: String,
        #[serde(rename = "lowPrice")]
        pub low_price: String,
        #[serde(rename = "openPrice")]
        pub open_price: String,
        #[serde(rename = "openTime")]
        pub open_time: i64,
        #[serde(rename = "prevClosePrice")]
        pub prev_close_price: String,
        #[serde(rename = "priceChange")]
        pub price_change: String,
        #[serde(rename = "priceChangePercent")]
        pub price_change_percent: String,
        #[serde(rename = "quoteVolume")]
        pub quote_volume: String,
        pub symbol: String,
        pub volume: String,
    }
    impl From<&Ticker> for Ticker {
        fn from(value: &Ticker) -> Self {
            value.clone()
        }
    }
    ///Ticker24hrResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/ticker"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/tickerList"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    #[serde(untagged)]
    pub enum Ticker24hrResponse {
        Variant0(Ticker),
        Variant1(TickerList),
    }
    impl From<&Ticker24hrResponse> for Ticker24hrResponse {
        fn from(value: &Ticker24hrResponse) -> Self {
            value.clone()
        }
    }
    impl From<Ticker> for Ticker24hrResponse {
        fn from(value: Ticker) -> Self {
            Self::Variant0(value)
        }
    }
    impl From<TickerList> for Ticker24hrResponse {
        fn from(value: TickerList) -> Self {
            Self::Variant1(value)
        }
    }
    ///TickerList
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "array",
    ///  "items": {
    ///    "$ref": "#/components/schemas/ticker"
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct TickerList(pub Vec<Ticker>);
    impl std::ops::Deref for TickerList {
        type Target = Vec<Ticker>;
        fn deref(&self) -> &Vec<Ticker> {
            &self.0
        }
    }
    impl From<TickerList> for Vec<Ticker> {
        fn from(value: TickerList) -> Self {
            value.0
        }
    }
    impl From<&TickerList> for TickerList {
        fn from(value: &TickerList) -> Self {
            value.clone()
        }
    }
    impl From<Vec<Ticker>> for TickerList {
        fn from(value: Vec<Ticker>) -> Self {
            Self(value)
        }
    }
    ///TickerOrderBookResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/bookTicker"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/bookTickerList"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    #[serde(untagged)]
    pub enum TickerOrderBookResponse {
        Variant0(BookTicker),
        Variant1(BookTickerList),
    }
    impl From<&TickerOrderBookResponse> for TickerOrderBookResponse {
        fn from(value: &TickerOrderBookResponse) -> Self {
            value.clone()
        }
    }
    impl From<BookTicker> for TickerOrderBookResponse {
        fn from(value: BookTicker) -> Self {
            Self::Variant0(value)
        }
    }
    impl From<BookTickerList> for TickerOrderBookResponse {
        fn from(value: BookTickerList) -> Self {
            Self::Variant1(value)
        }
    }
    ///TickerPriceResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/priceTicker"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/priceTickerList"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    #[serde(untagged)]
    pub enum TickerPriceResponse {
        Variant0(PriceTicker),
        Variant1(PriceTickerList),
    }
    impl From<&TickerPriceResponse> for TickerPriceResponse {
        fn from(value: &TickerPriceResponse) -> Self {
            value.clone()
        }
    }
    impl From<PriceTicker> for TickerPriceResponse {
        fn from(value: PriceTicker) -> Self {
            Self::Variant0(value)
        }
    }
    impl From<PriceTickerList> for TickerPriceResponse {
        fn from(value: PriceTickerList) -> Self {
            Self::Variant1(value)
        }
    }
    ///TickerResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "closeTime",
    ///    "count",
    ///    "firstId",
    ///    "highPrice",
    ///    "lastId",
    ///    "lastPrice",
    ///    "lowPrice",
    ///    "openPrice",
    ///    "openTime",
    ///    "priceChange",
    ///    "priceChangePercent",
    ///    "quoteVolume",
    ///    "symbol",
    ///    "volume",
    ///    "weightedAvgPrice"
    ///  ],
    ///  "properties": {
    ///    "closeTime": {
    ///      "examples": [
    ///        1642031999999
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "count": {
    ///      "examples": [
    ///        61
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "firstId": {
    ///      "examples": [
    ///        0
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "highPrice": {
    ///      "examples": [
    ///        "9.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "lastId": {
    ///      "examples": [
    ///        60
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "lastPrice": {
    ///      "examples": [
    ///        "1.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "lowPrice": {
    ///      "examples": [
    ///        "1.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "openPrice": {
    ///      "examples": [
    ///        "9.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "openTime": {
    ///      "examples": [
    ///        1641859200000
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "priceChange": {
    ///      "examples": [
    ///        "-8.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "priceChangePercent": {
    ///      "examples": [
    ///        "-88.889"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "quoteVolume": {
    ///      "examples": [
    ///        "487.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "symbol": {
    ///      "examples": [
    ///        "BNBBTC"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "volume": {
    ///      "examples": [
    ///        "187.00000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "weightedAvgPrice": {
    ///      "examples": [
    ///        "2.60427807"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct TickerResponse {
        #[serde(rename = "closeTime")]
        pub close_time: i64,
        pub count: i64,
        #[serde(rename = "firstId")]
        pub first_id: i64,
        #[serde(rename = "highPrice")]
        pub high_price: String,
        #[serde(rename = "lastId")]
        pub last_id: i64,
        #[serde(rename = "lastPrice")]
        pub last_price: String,
        #[serde(rename = "lowPrice")]
        pub low_price: String,
        #[serde(rename = "openPrice")]
        pub open_price: String,
        #[serde(rename = "openTime")]
        pub open_time: i64,
        #[serde(rename = "priceChange")]
        pub price_change: String,
        #[serde(rename = "priceChangePercent")]
        pub price_change_percent: String,
        #[serde(rename = "quoteVolume")]
        pub quote_volume: String,
        pub symbol: String,
        pub volume: String,
        #[serde(rename = "weightedAvgPrice")]
        pub weighted_avg_price: String,
    }
    impl From<&TickerResponse> for TickerResponse {
        fn from(value: &TickerResponse) -> Self {
            value.clone()
        }
    }
    ///TimeResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "serverTime"
    ///  ],
    ///  "properties": {
    ///    "serverTime": {
    ///      "examples": [
    ///        1499827319559
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct TimeResponse {
        #[serde(rename = "serverTime")]
        pub server_time: i64,
    }
    impl From<&TimeResponse> for TimeResponse {
        fn from(value: &TimeResponse) -> Self {
            value.clone()
        }
    }
    ///ToggleBnbBurnInterestBnbBurn
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "false"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "true",
    ///    "false"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum ToggleBnbBurnInterestBnbBurn {
        #[serde(rename = "true")]
        True,
        #[serde(rename = "false")]
        False,
    }
    impl From<&ToggleBnbBurnInterestBnbBurn> for ToggleBnbBurnInterestBnbBurn {
        fn from(value: &ToggleBnbBurnInterestBnbBurn) -> Self {
            value.clone()
        }
    }
    impl ToString for ToggleBnbBurnInterestBnbBurn {
        fn to_string(&self) -> String {
            match *self {
                Self::True => "true".to_string(),
                Self::False => "false".to_string(),
            }
        }
    }
    impl std::str::FromStr for ToggleBnbBurnInterestBnbBurn {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "true" => Ok(Self::True),
                "false" => Ok(Self::False),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for ToggleBnbBurnInterestBnbBurn {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for ToggleBnbBurnInterestBnbBurn {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for ToggleBnbBurnInterestBnbBurn {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///ToggleBnbBurnSpotBnbBurn
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "true"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "true",
    ///    "false"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum ToggleBnbBurnSpotBnbBurn {
        #[serde(rename = "true")]
        True,
        #[serde(rename = "false")]
        False,
    }
    impl From<&ToggleBnbBurnSpotBnbBurn> for ToggleBnbBurnSpotBnbBurn {
        fn from(value: &ToggleBnbBurnSpotBnbBurn) -> Self {
            value.clone()
        }
    }
    impl ToString for ToggleBnbBurnSpotBnbBurn {
        fn to_string(&self) -> String {
            match *self {
                Self::True => "true".to_string(),
                Self::False => "false".to_string(),
            }
        }
    }
    impl std::str::FromStr for ToggleBnbBurnSpotBnbBurn {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "true" => Ok(Self::True),
                "false" => Ok(Self::False),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for ToggleBnbBurnSpotBnbBurn {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for ToggleBnbBurnSpotBnbBurn {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for ToggleBnbBurnSpotBnbBurn {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///Trade
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "isBestMatch",
    ///    "isBuyerMaker",
    ///    "price",
    ///    "qty",
    ///    "quoteQty",
    ///    "time"
    ///  ],
    ///  "properties": {
    ///    "id": {
    ///      "description": "trade id",
    ///      "examples": [
    ///        345196462
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "isBestMatch": {
    ///      "type": "boolean"
    ///    },
    ///    "isBuyerMaker": {
    ///      "type": "boolean"
    ///    },
    ///    "price": {
    ///      "description": "price",
    ///      "examples": [
    ///        "9638.99000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "qty": {
    ///      "description": "amount of base asset",
    ///      "examples": [
    ///        "0.02077200"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "quoteQty": {
    ///      "description": "amount of quote asset",
    ///      "examples": [
    ///        "0.02077200"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "time": {
    ///      "description": "Trade executed timestamp, as same as `T` in the stream",
    ///      "examples": [
    ///        1592887772684
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct Trade {
        ///trade id
        pub id: i64,
        #[serde(rename = "isBestMatch")]
        pub is_best_match: bool,
        #[serde(rename = "isBuyerMaker")]
        pub is_buyer_maker: bool,
        ///price
        pub price: String,
        ///amount of base asset
        pub qty: String,
        ///amount of quote asset
        #[serde(rename = "quoteQty")]
        pub quote_qty: String,
        ///Trade executed timestamp, as same as `T` in the stream
        pub time: i64,
    }
    impl From<&Trade> for Trade {
        fn from(value: &Trade) -> Self {
            value.clone()
        }
    }
    ///Transaction
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "tranId"
    ///  ],
    ///  "properties": {
    ///    "tranId": {
    ///      "description": "transaction id",
    ///      "examples": [
    ///        345196462
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct Transaction {
        ///transaction id
        #[serde(rename = "tranId")]
        pub tran_id: i64,
    }
    impl From<&Transaction> for Transaction {
        fn from(value: &Transaction) -> Self {
            value.clone()
        }
    }
    ///UiKlinesInterval
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "\"1m\""
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "1s",
    ///    "1m",
    ///    "3m",
    ///    "5m",
    ///    "15m",
    ///    "30m",
    ///    "1h",
    ///    "2h",
    ///    "4h",
    ///    "6h",
    ///    "8h",
    ///    "12h",
    ///    "1d",
    ///    "3d",
    ///    "1w"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum UiKlinesInterval {
        #[serde(rename = "1s")]
        _1s,
        #[serde(rename = "1m")]
        _1m,
        #[serde(rename = "3m")]
        _3m,
        #[serde(rename = "5m")]
        _5m,
        #[serde(rename = "15m")]
        _15m,
        #[serde(rename = "30m")]
        _30m,
        #[serde(rename = "1h")]
        _1h,
        #[serde(rename = "2h")]
        _2h,
        #[serde(rename = "4h")]
        _4h,
        #[serde(rename = "6h")]
        _6h,
        #[serde(rename = "8h")]
        _8h,
        #[serde(rename = "12h")]
        _12h,
        #[serde(rename = "1d")]
        _1d,
        #[serde(rename = "3d")]
        _3d,
        #[serde(rename = "1w")]
        _1w,
    }
    impl From<&UiKlinesInterval> for UiKlinesInterval {
        fn from(value: &UiKlinesInterval) -> Self {
            value.clone()
        }
    }
    impl ToString for UiKlinesInterval {
        fn to_string(&self) -> String {
            match *self {
                Self::_1s => "1s".to_string(),
                Self::_1m => "1m".to_string(),
                Self::_3m => "3m".to_string(),
                Self::_5m => "5m".to_string(),
                Self::_15m => "15m".to_string(),
                Self::_30m => "30m".to_string(),
                Self::_1h => "1h".to_string(),
                Self::_2h => "2h".to_string(),
                Self::_4h => "4h".to_string(),
                Self::_6h => "6h".to_string(),
                Self::_8h => "8h".to_string(),
                Self::_12h => "12h".to_string(),
                Self::_1d => "1d".to_string(),
                Self::_3d => "3d".to_string(),
                Self::_1w => "1w".to_string(),
            }
        }
    }
    impl std::str::FromStr for UiKlinesInterval {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "1s" => Ok(Self::_1s),
                "1m" => Ok(Self::_1m),
                "3m" => Ok(Self::_3m),
                "5m" => Ok(Self::_5m),
                "15m" => Ok(Self::_15m),
                "30m" => Ok(Self::_30m),
                "1h" => Ok(Self::_1h),
                "2h" => Ok(Self::_2h),
                "4h" => Ok(Self::_4h),
                "6h" => Ok(Self::_6h),
                "8h" => Ok(Self::_8h),
                "12h" => Ok(Self::_12h),
                "1d" => Ok(Self::_1d),
                "3d" => Ok(Self::_3d),
                "1w" => Ok(Self::_1w),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for UiKlinesInterval {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for UiKlinesInterval {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for UiKlinesInterval {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///UiKlinesResponseItemItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    {
    ///      "type": "string"
    ///    }
    ///  ],
    ///  "maxItems": 12,
    ///  "minItems": 12
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    #[serde(untagged)]
    pub enum UiKlinesResponseItemItem {
        Variant0(i64),
        Variant1(String),
    }
    impl From<&UiKlinesResponseItemItem> for UiKlinesResponseItemItem {
        fn from(value: &UiKlinesResponseItemItem) -> Self {
            value.clone()
        }
    }
    impl std::str::FromStr for UiKlinesResponseItemItem {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if let Ok(v) = value.parse() {
                Ok(Self::Variant0(v))
            } else if let Ok(v) = value.parse() {
                Ok(Self::Variant1(v))
            } else {
                Err("string conversion failed for all variants".into())
            }
        }
    }
    impl std::convert::TryFrom<&str> for UiKlinesResponseItemItem {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for UiKlinesResponseItemItem {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for UiKlinesResponseItemItem {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ToString for UiKlinesResponseItemItem {
        fn to_string(&self) -> String {
            match self {
                Self::Variant0(x) => x.to_string(),
                Self::Variant1(x) => x.to_string(),
            }
        }
    }
    impl From<i64> for UiKlinesResponseItemItem {
        fn from(value: i64) -> Self {
            Self::Variant0(value)
        }
    }
    ///UniversalTransferMasterAccountFromAccountType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "SPOT",
    ///    "USDT_FUTURE",
    ///    "COIN_FUTURE",
    ///    "MARGIN",
    ///    "ISOLATED_MARGIN"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum UniversalTransferMasterAccountFromAccountType {
        #[serde(rename = "SPOT")]
        Spot,
        #[serde(rename = "USDT_FUTURE")]
        UsdtFuture,
        #[serde(rename = "COIN_FUTURE")]
        CoinFuture,
        #[serde(rename = "MARGIN")]
        Margin,
        #[serde(rename = "ISOLATED_MARGIN")]
        IsolatedMargin,
    }
    impl From<&UniversalTransferMasterAccountFromAccountType>
    for UniversalTransferMasterAccountFromAccountType {
        fn from(value: &UniversalTransferMasterAccountFromAccountType) -> Self {
            value.clone()
        }
    }
    impl ToString for UniversalTransferMasterAccountFromAccountType {
        fn to_string(&self) -> String {
            match *self {
                Self::Spot => "SPOT".to_string(),
                Self::UsdtFuture => "USDT_FUTURE".to_string(),
                Self::CoinFuture => "COIN_FUTURE".to_string(),
                Self::Margin => "MARGIN".to_string(),
                Self::IsolatedMargin => "ISOLATED_MARGIN".to_string(),
            }
        }
    }
    impl std::str::FromStr for UniversalTransferMasterAccountFromAccountType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "SPOT" => Ok(Self::Spot),
                "USDT_FUTURE" => Ok(Self::UsdtFuture),
                "COIN_FUTURE" => Ok(Self::CoinFuture),
                "MARGIN" => Ok(Self::Margin),
                "ISOLATED_MARGIN" => Ok(Self::IsolatedMargin),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for UniversalTransferMasterAccountFromAccountType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String>
    for UniversalTransferMasterAccountFromAccountType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String>
    for UniversalTransferMasterAccountFromAccountType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///UniversalTransferMasterAccountResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "clientTranId",
    ///    "tranId"
    ///  ],
    ///  "properties": {
    ///    "clientTranId": {
    ///      "examples": [
    ///        "11945860694"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "tranId": {
    ///      "examples": [
    ///        11945860693
    ///      ],
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct UniversalTransferMasterAccountResponse {
        #[serde(rename = "clientTranId")]
        pub client_tran_id: String,
        #[serde(rename = "tranId")]
        pub tran_id: i64,
    }
    impl From<&UniversalTransferMasterAccountResponse>
    for UniversalTransferMasterAccountResponse {
        fn from(value: &UniversalTransferMasterAccountResponse) -> Self {
            value.clone()
        }
    }
    ///UniversalTransferMasterAccountToAccountType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "SPOT",
    ///    "USDT_FUTURE",
    ///    "COIN_FUTURE",
    ///    "MARGIN",
    ///    "ISOLATED_MARGIN"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize
    )]
    pub enum UniversalTransferMasterAccountToAccountType {
        #[serde(rename = "SPOT")]
        Spot,
        #[serde(rename = "USDT_FUTURE")]
        UsdtFuture,
        #[serde(rename = "COIN_FUTURE")]
        CoinFuture,
        #[serde(rename = "MARGIN")]
        Margin,
        #[serde(rename = "ISOLATED_MARGIN")]
        IsolatedMargin,
    }
    impl From<&UniversalTransferMasterAccountToAccountType>
    for UniversalTransferMasterAccountToAccountType {
        fn from(value: &UniversalTransferMasterAccountToAccountType) -> Self {
            value.clone()
        }
    }
    impl ToString for UniversalTransferMasterAccountToAccountType {
        fn to_string(&self) -> String {
            match *self {
                Self::Spot => "SPOT".to_string(),
                Self::UsdtFuture => "USDT_FUTURE".to_string(),
                Self::CoinFuture => "COIN_FUTURE".to_string(),
                Self::Margin => "MARGIN".to_string(),
                Self::IsolatedMargin => "ISOLATED_MARGIN".to_string(),
            }
        }
    }
    impl std::str::FromStr for UniversalTransferMasterAccountToAccountType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "SPOT" => Ok(Self::Spot),
                "USDT_FUTURE" => Ok(Self::UsdtFuture),
                "COIN_FUTURE" => Ok(Self::CoinFuture),
                "MARGIN" => Ok(Self::Margin),
                "ISOLATED_MARGIN" => Ok(Self::IsolatedMargin),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for UniversalTransferMasterAccountToAccountType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for UniversalTransferMasterAccountToAccountType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for UniversalTransferMasterAccountToAccountType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///UserDataStreamIsolatedResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "listenKey"
    ///  ],
    ///  "properties": {
    ///    "listenKey": {
    ///      "examples": [
    ///        "T3ee22BIYuWqmvne0HNq2A2WsFlEtLhvWCtItw6ffhhdmjifQ2tRbuKkTHhr"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct UserDataStreamIsolatedResponse {
        #[serde(rename = "listenKey")]
        pub listen_key: String,
    }
    impl From<&UserDataStreamIsolatedResponse> for UserDataStreamIsolatedResponse {
        fn from(value: &UserDataStreamIsolatedResponse) -> Self {
            value.clone()
        }
    }
}
#[derive(Clone, Debug)]
/**Client for Binance Public Spot API

OpenAPI Specifications for the Binance Public Spot API

API documents:
  - [https://github.com/binance/binance-spot-api-docs](https://github.com/binance/binance-spot-api-docs)
  - [https://binance-docs.github.io/apidocs/spot/en](https://binance-docs.github.io/apidocs/spot/en)

Version: 1.0*/
pub struct Client {
    pub(crate) baseurl: String,
    pub(crate) client: reqwest::Client,
    pub(crate) inner: crate::AuthProvider,
}
impl Client {
    /// Create a new client.
    ///
    /// `baseurl` is the base URL provided to the internal
    /// `reqwest::Client`, and should include a scheme and hostname,
    /// as well as port and a path stem if applicable.
    pub fn new(baseurl: &str, inner: crate::AuthProvider) -> Self {
        #[cfg(not(target_arch = "wasm32"))]
        let client = {
            let dur = std::time::Duration::from_secs(15);
            reqwest::ClientBuilder::new().connect_timeout(dur).timeout(dur)
        };
        #[cfg(target_arch = "wasm32")]
        let client = reqwest::ClientBuilder::new();
        Self::new_with_client(baseurl, client.build().unwrap(), inner)
    }
    /// Construct a new client with an existing `reqwest::Client`,
    /// allowing more control over its configuration.
    ///
    /// `baseurl` is the base URL provided to the internal
    /// `reqwest::Client`, and should include a scheme and hostname,
    /// as well as port and a path stem if applicable.
    pub fn new_with_client(
        baseurl: &str,
        client: reqwest::Client,
        inner: crate::AuthProvider,
    ) -> Self {
        Self {
            baseurl: baseurl.to_string(),
            client,
            inner,
        }
    }
    /// Get the base URL to which requests are made.
    pub fn baseurl(&self) -> &String {
        &self.baseurl
    }
    /// Get the internal `reqwest::Client` used to make requests.
    pub fn client(&self) -> &reqwest::Client {
        &self.client
    }
    /// Get the version of this API.
    ///
    /// This string is pulled directly from the source OpenAPI
    /// document and may be in any format the API selects.
    pub fn api_version(&self) -> &'static str {
        "1.0"
    }
    /// Return a reference to the inner type stored in `self`.
    pub fn inner(&self) -> &crate::AuthProvider {
        &self.inner
    }
}
#[allow(clippy::all)]
impl Client {
    /**Test Connectivity

Test connectivity to the Rest API.

Weight(IP): 1

Sends a `GET` request to `/api/v3/ping`

*/
    pub async fn ping<'a>(
        &'a self,
    ) -> Result<ResponseValue<serde_json::Map<String, serde_json::Value>>, Error<()>> {
        let url = format!("{}/api/v3/ping", self.baseurl,);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Check Server Time

Test connectivity to the Rest API and get the current server time.

Weight(IP): 1

Sends a `GET` request to `/api/v3/time`

*/
    pub async fn time<'a>(
        &'a self,
    ) -> Result<ResponseValue<types::TimeResponse>, Error<()>> {
        let url = format!("{}/api/v3/time", self.baseurl,);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Exchange Information

Current exchange trading rules and symbol information

- If any symbol provided in either symbol or symbols do not exist, the endpoint will throw an error.

Weight(IP): 10

Sends a `GET` request to `/api/v3/exchangeInfo`

Arguments:
- `permissions`
- `symbol`: Trading symbol, e.g. BNBUSDT
- `symbols`
*/
    pub async fn exchange_info<'a>(
        &'a self,
        permissions: Option<&'a str>,
        symbol: Option<&'a str>,
        symbols: Option<&'a str>,
    ) -> Result<ResponseValue<types::ExchangeInfoResponse>, Error<types::Error>> {
        let url = format!("{}/api/v3/exchangeInfo", self.baseurl,);
        let mut query = Vec::with_capacity(3usize);
        if let Some(v) = &permissions {
            query.push(("permissions", v.to_string()));
        }
        if let Some(v) = &symbol {
            query.push(("symbol", v.to_string()));
        }
        if let Some(v) = &symbols {
            query.push(("symbols", v.to_string()));
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Order Book

| Limit               | Weight(IP)  |
|---------------------|-------------|
| 1-100               | 5           |
| 101-500             | 25          |
| 501-1000            | 50          |
| 1001-5000           | 250         |

Sends a `GET` request to `/api/v3/depth`

Arguments:
- `limit`: If limit > 5000, then the response will truncate to 5000
- `symbol`: Trading symbol, e.g. BNBUSDT
*/
    pub async fn depth<'a>(
        &'a self,
        limit: Option<i64>,
        symbol: &'a str,
    ) -> Result<ResponseValue<types::DepthResponse>, Error<types::Error>> {
        let url = format!("{}/api/v3/depth", self.baseurl,);
        let mut query = Vec::with_capacity(2usize);
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }
        query.push(("symbol", symbol.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Recent Trades List

Get recent trades.

Weight(IP): 10

Sends a `GET` request to `/api/v3/trades`

Arguments:
- `limit`: Default 500; max 1000.
- `symbol`: Trading symbol, e.g. BNBUSDT
*/
    pub async fn trades<'a>(
        &'a self,
        limit: Option<i32>,
        symbol: &'a str,
    ) -> Result<ResponseValue<Vec<types::Trade>>, Error<types::Error>> {
        let url = format!("{}/api/v3/trades", self.baseurl,);
        let mut query = Vec::with_capacity(2usize);
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }
        query.push(("symbol", symbol.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Old Trade Lookup

Get older market trades.

Weight(IP): 10

Sends a `GET` request to `/api/v3/historicalTrades`

Arguments:
- `from_id`: Trade id to fetch from. Default gets most recent trades.
- `limit`: Default 500; max 1000.
- `symbol`: Trading symbol, e.g. BNBUSDT
*/
    pub async fn historical_trades<'a>(
        &'a self,
        from_id: Option<i64>,
        limit: Option<i32>,
        symbol: &'a str,
    ) -> Result<ResponseValue<Vec<types::Trade>>, Error<()>> {
        let url = format!("{}/api/v3/historicalTrades", self.baseurl,);
        let mut query = Vec::with_capacity(3usize);
        if let Some(v) = &from_id {
            query.push(("fromId", v.to_string()));
        }
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }
        query.push(("symbol", symbol.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Compressed/Aggregate Trades List

Get compressed, aggregate trades. Trades that fill at the time, from the same order, with the same price will have the quantity aggregated.
- If `fromId`, `startTime`, and `endTime` are not sent, the most recent aggregate trades will be returned.
- Note that if a trade has the following values, this was a duplicate aggregate trade and marked as invalid:

  p = '0' // price

  q = '0' // qty

  f = -1 // rst_trade_id

  l = -1 // last_trade_id

Weight(IP): 2

Sends a `GET` request to `/api/v3/aggTrades`

Arguments:
- `end_time`: UTC timestamp in ms
- `from_id`: Trade id to fetch from. Default gets most recent trades.
- `limit`: Default 500; max 1000.
- `start_time`: UTC timestamp in ms
- `symbol`: Trading symbol, e.g. BNBUSDT
*/
    pub async fn agg_trades<'a>(
        &'a self,
        end_time: Option<i64>,
        from_id: Option<i64>,
        limit: Option<i32>,
        start_time: Option<i64>,
        symbol: &'a str,
    ) -> Result<ResponseValue<Vec<types::AggTrade>>, Error<types::Error>> {
        let url = format!("{}/api/v3/aggTrades", self.baseurl,);
        let mut query = Vec::with_capacity(5usize);
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        if let Some(v) = &from_id {
            query.push(("fromId", v.to_string()));
        }
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        query.push(("symbol", symbol.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Kline/Candlestick Data

Kline/candlestick bars for a symbol.
Klines are uniquely identified by their open time.

- If `startTime` and `endTime` are not sent, the most recent klines are returned.

Weight(IP): 2

Sends a `GET` request to `/api/v3/klines`

Arguments:
- `end_time`: UTC timestamp in ms
- `interval`: kline intervals
- `limit`: Default 500; max 1000.
- `start_time`: UTC timestamp in ms
- `symbol`: Trading symbol, e.g. BNBUSDT
*/
    pub async fn kline_candlestick_data<'a>(
        &'a self,
        end_time: Option<i64>,
        interval: types::KlineCandlestickDataInterval,
        limit: Option<i32>,
        start_time: Option<i64>,
        symbol: &'a str,
    ) -> Result<
        ResponseValue<Vec<Vec<types::KlineCandlestickDataResponseItemItem>>>,
        Error<types::Error>,
    > {
        let url = format!("{}/api/v3/klines", self.baseurl,);
        let mut query = Vec::with_capacity(5usize);
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        query.push(("interval", interval.to_string()));
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        query.push(("symbol", symbol.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**UIKlines

The request is similar to klines having the same parameters and response.

uiKlines return modified kline data, optimized for presentation of candlestick charts.

Weight(IP): 2

Sends a `GET` request to `/api/v3/uiKlines`

Arguments:
- `end_time`: UTC timestamp in ms
- `interval`: kline intervals
- `limit`: Default 500; max 1000.
- `start_time`: UTC timestamp in ms
- `symbol`: Trading symbol, e.g. BNBUSDT
*/
    pub async fn ui_klines<'a>(
        &'a self,
        end_time: Option<i64>,
        interval: types::UiKlinesInterval,
        limit: Option<i32>,
        start_time: Option<i64>,
        symbol: &'a str,
    ) -> Result<
        ResponseValue<Vec<Vec<types::UiKlinesResponseItemItem>>>,
        Error<types::Error>,
    > {
        let url = format!("{}/api/v3/uiKlines", self.baseurl,);
        let mut query = Vec::with_capacity(5usize);
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        query.push(("interval", interval.to_string()));
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        query.push(("symbol", symbol.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Current Average Price

Current average price for a symbol.

Weight(IP): 2

Sends a `GET` request to `/api/v3/avgPrice`

Arguments:
- `symbol`: Trading symbol, e.g. BNBUSDT
*/
    pub async fn avg_price<'a>(
        &'a self,
        symbol: &'a str,
    ) -> Result<ResponseValue<types::AvgPriceResponse>, Error<types::Error>> {
        let url = format!("{}/api/v3/avgPrice", self.baseurl,);
        let mut query = Vec::with_capacity(1usize);
        query.push(("symbol", symbol.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**24hr Ticker Price Change Statistics

24 hour rolling window price change statistics. Careful when accessing this with no symbol.

- If the symbol is not sent, tickers for all symbols will be returned in an array.

Weight(IP):
- `2` for a single symbol;
- `80` when the symbol parameter is omitted;

Sends a `GET` request to `/api/v3/ticker/24hr`

Arguments:
- `symbol`: Trading symbol, e.g. BNBUSDT
- `symbols`
- `type_`: Supported values: FULL or MINI.
If none provided, the default is FULL
*/
    pub async fn ticker_24hr<'a>(
        &'a self,
        symbol: Option<&'a str>,
        symbols: Option<&'a str>,
        type_: Option<&'a str>,
    ) -> Result<ResponseValue<types::Ticker24hrResponse>, Error<types::Error>> {
        let url = format!("{}/api/v3/ticker/24hr", self.baseurl,);
        let mut query = Vec::with_capacity(3usize);
        if let Some(v) = &symbol {
            query.push(("symbol", v.to_string()));
        }
        if let Some(v) = &symbols {
            query.push(("symbols", v.to_string()));
        }
        if let Some(v) = &type_ {
            query.push(("type", v.to_string()));
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Symbol Price Ticker

Latest price for a symbol or symbols.

- If the symbol is not sent, prices for all symbols will be returned in an array.

Weight(IP):
- `2` for a single symbol;
- `4` when the symbol parameter is omitted;

Sends a `GET` request to `/api/v3/ticker/price`

Arguments:
- `symbol`: Trading symbol, e.g. BNBUSDT
- `symbols`
*/
    pub async fn ticker_price<'a>(
        &'a self,
        symbol: Option<&'a str>,
        symbols: Option<&'a str>,
    ) -> Result<ResponseValue<types::TickerPriceResponse>, Error<types::Error>> {
        let url = format!("{}/api/v3/ticker/price", self.baseurl,);
        let mut query = Vec::with_capacity(2usize);
        if let Some(v) = &symbol {
            query.push(("symbol", v.to_string()));
        }
        if let Some(v) = &symbols {
            query.push(("symbols", v.to_string()));
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Symbol Order Book Ticker

Best price/qty on the order book for a symbol or symbols.

- If the symbol is not sent, bookTickers for all symbols will be returned in an array.

Weight(IP):
- `2` for a single symbol;
- `4` when the symbol parameter is omitted;

Sends a `GET` request to `/api/v3/ticker/bookTicker`

Arguments:
- `symbol`: Trading symbol, e.g. BNBUSDT
- `symbols`
*/
    pub async fn ticker_order_book<'a>(
        &'a self,
        symbol: Option<&'a str>,
        symbols: Option<&'a str>,
    ) -> Result<ResponseValue<types::TickerOrderBookResponse>, Error<types::Error>> {
        let url = format!("{}/api/v3/ticker/bookTicker", self.baseurl,);
        let mut query = Vec::with_capacity(2usize);
        if let Some(v) = &symbol {
            query.push(("symbol", v.to_string()));
        }
        if let Some(v) = &symbols {
            query.push(("symbols", v.to_string()));
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Rolling window price change statistics

The window used to compute statistics is typically slightly wider than requested windowSize.

openTime for /api/v3/ticker always starts on a minute, while the closeTime is the current time of the request. As such, the effective window might be up to 1 minute wider than requested.

E.g. If the closeTime is 1641287867099 (January 04, 2022 09:17:47:099 UTC) , and the windowSize is 1d. the openTime will be: 1641201420000 (January 3, 2022, 09:17:00 UTC)

Weight(IP): 4 for each requested symbol regardless of windowSize.

The weight for this request will cap at 200 once the number of symbols in the request is more than 50.

Sends a `GET` request to `/api/v3/ticker`

Arguments:
- `symbol`: Trading symbol, e.g. BNBUSDT
- `symbols`
- `type_`: Supported values: FULL or MINI.
If none provided, the default is FULL
- `window_size`: Defaults to 1d if no parameter provided.
Supported windowSize values:
1m,2m....59m for minutes
1h, 2h....23h - for hours
1d...7d - for days.

Units cannot be combined (e.g. 1d2h is not allowed)
*/
    pub async fn ticker<'a>(
        &'a self,
        symbol: Option<&'a str>,
        symbols: Option<&'a str>,
        type_: Option<&'a str>,
        window_size: Option<&'a str>,
    ) -> Result<ResponseValue<types::TickerResponse>, Error<types::Error>> {
        let url = format!("{}/api/v3/ticker", self.baseurl,);
        let mut query = Vec::with_capacity(4usize);
        if let Some(v) = &symbol {
            query.push(("symbol", v.to_string()));
        }
        if let Some(v) = &symbols {
            query.push(("symbols", v.to_string()));
        }
        if let Some(v) = &type_ {
            query.push(("type", v.to_string()));
        }
        if let Some(v) = &window_size {
            query.push(("windowSize", v.to_string()));
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Test New Order (TRADE)

Test new order creation and signature/recvWindow long.
Creates and validates a new order but does not send it into the matching engine.

Weight(IP): 1

Sends a `POST` request to `/api/v3/order/test`

Arguments:
- `iceberg_qty`: Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
- `new_client_order_id`: Used to uniquely identify this cancel. Automatically generated by default
- `new_order_resp_type`: Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.
- `price`: Order price
- `quantity`: Order quantity
- `quote_order_qty`: Quote quantity
- `recv_window`: The value cannot be greater than 60000
- `side`
- `signature`: Signature
- `stop_price`: Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
- `strategy_id`
- `strategy_type`: The value cannot be less than 1000000.
- `symbol`: Trading symbol, e.g. BNBUSDT
- `time_in_force`: Order time in force
- `timestamp`: UTC timestamp in ms
- `trailing_delta`: Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
- `type_`: Order type
*/
    pub async fn order_test<'a>(
        &'a self,
        iceberg_qty: Option<f64>,
        new_client_order_id: Option<&'a str>,
        new_order_resp_type: Option<types::OrderTestNewOrderRespType>,
        price: Option<f64>,
        quantity: Option<f64>,
        quote_order_qty: Option<f64>,
        recv_window: Option<i64>,
        side: types::OrderTestSide,
        signature: &'a str,
        stop_price: Option<f64>,
        strategy_id: Option<i64>,
        strategy_type: Option<i64>,
        symbol: &'a str,
        time_in_force: Option<types::OrderTestTimeInForce>,
        timestamp: i64,
        trailing_delta: Option<f64>,
        type_: types::OrderTestType,
    ) -> Result<
        ResponseValue<serde_json::Map<String, serde_json::Value>>,
        Error<types::Error>,
    > {
        let url = format!("{}/api/v3/order/test", self.baseurl,);
        let mut query = Vec::with_capacity(17usize);
        if let Some(v) = &iceberg_qty {
            query.push(("icebergQty", v.to_string()));
        }
        if let Some(v) = &new_client_order_id {
            query.push(("newClientOrderId", v.to_string()));
        }
        if let Some(v) = &new_order_resp_type {
            query.push(("newOrderRespType", v.to_string()));
        }
        if let Some(v) = &price {
            query.push(("price", v.to_string()));
        }
        if let Some(v) = &quantity {
            query.push(("quantity", v.to_string()));
        }
        if let Some(v) = &quote_order_qty {
            query.push(("quoteOrderQty", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("side", side.to_string()));
        query.push(("signature", signature.to_string()));
        if let Some(v) = &stop_price {
            query.push(("stopPrice", v.to_string()));
        }
        if let Some(v) = &strategy_id {
            query.push(("strategyId", v.to_string()));
        }
        if let Some(v) = &strategy_type {
            query.push(("strategyType", v.to_string()));
        }
        query.push(("symbol", symbol.to_string()));
        if let Some(v) = &time_in_force {
            query.push(("timeInForce", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        if let Some(v) = &trailing_delta {
            query.push(("trailingDelta", v.to_string()));
        }
        query.push(("type", type_.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Query Order (USER_DATA)

Check an order's status.

- Either `orderId` or `origClientOrderId` must be sent.
- For some historical orders `cummulativeQuoteQty` will be < 0, meaning the data is not available at this time.

Weight(IP): 4

Sends a `GET` request to `/api/v3/order`

Arguments:
- `order_id`: Order id
- `orig_client_order_id`: Order id from client
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `symbol`: Trading symbol, e.g. BNBUSDT
- `timestamp`: UTC timestamp in ms
*/
    pub async fn query_order<'a>(
        &'a self,
        order_id: Option<i64>,
        orig_client_order_id: Option<&'a str>,
        recv_window: Option<i64>,
        signature: &'a str,
        symbol: &'a str,
        timestamp: i64,
    ) -> Result<ResponseValue<types::OrderDetails>, Error<types::Error>> {
        let url = format!("{}/api/v3/order", self.baseurl,);
        let mut query = Vec::with_capacity(6usize);
        if let Some(v) = &order_id {
            query.push(("orderId", v.to_string()));
        }
        if let Some(v) = &orig_client_order_id {
            query.push(("origClientOrderId", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("symbol", symbol.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**New Order (TRADE)

Send in a new order.

- `LIMIT_MAKER` are `LIMIT` orders that will be rejected if they would immediately match and trade as a taker.
- `STOP_LOSS` and `TAKE_PROFIT` will execute a `MARKET` order when the `stopPrice` is reached.
- Any `LIMIT` or `LIMIT_MAKER` type order can be made an iceberg order by sending an `icebergQty`.
- Any order with an `icebergQty` MUST have `timeInForce` set to `GTC`.
- `MARKET` orders using `quantity` specifies how much a user wants to buy or sell based on the market price.
- `MARKET` orders using `quoteOrderQty` specifies the amount the user wants to spend (when buying) or receive (when selling) of the quote asset; the correct quantity will be determined based on the market liquidity and `quoteOrderQty`.
- `MARKET` orders using `quoteOrderQty` will not break `LOT_SIZE` filter rules; the order will execute a quantity that will have the notional value as close as possible to `quoteOrderQty`.
- same `newClientOrderId` can be accepted only when the previous one is filled, otherwise the order will be rejected.

Trigger order price rules against market price for both `MARKET` and `LIMIT` versions:

- Price above market price: `STOP_LOSS` `BUY`, `TAKE_PROFIT` `SELL`
- Price below market price: `STOP_LOSS` `SELL`, `TAKE_PROFIT` `BUY`


Weight(IP): 1

Sends a `POST` request to `/api/v3/order`

Arguments:
- `iceberg_qty`: Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
- `new_client_order_id`: Used to uniquely identify this cancel. Automatically generated by default
- `new_order_resp_type`: Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.
- `price`: Order price
- `quantity`: Order quantity
- `quote_order_qty`: Quote quantity
- `recv_window`: The value cannot be greater than 60000
- `self_trade_prevention_mode`: The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
- `side`
- `signature`: Signature
- `stop_price`: Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
- `strategy_id`
- `strategy_type`: The value cannot be less than 1000000.
- `symbol`: Trading symbol, e.g. BNBUSDT
- `time_in_force`: Order time in force
- `timestamp`: UTC timestamp in ms
- `trailing_delta`: Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
- `type_`: Order type
*/
    pub async fn place_new_order<'a>(
        &'a self,
        iceberg_qty: Option<f64>,
        new_client_order_id: Option<&'a str>,
        new_order_resp_type: Option<types::PlaceNewOrderNewOrderRespType>,
        price: Option<f64>,
        quantity: Option<f64>,
        quote_order_qty: Option<f64>,
        recv_window: Option<i64>,
        self_trade_prevention_mode: Option<types::PlaceNewOrderSelfTradePreventionMode>,
        side: types::PlaceNewOrderSide,
        signature: &'a str,
        stop_price: Option<f64>,
        strategy_id: Option<i64>,
        strategy_type: Option<i64>,
        symbol: &'a str,
        time_in_force: Option<types::PlaceNewOrderTimeInForce>,
        timestamp: i64,
        trailing_delta: Option<f64>,
        type_: types::PlaceNewOrderType,
    ) -> Result<ResponseValue<types::PlaceNewOrderResponse>, Error<types::Error>> {
        let url = format!("{}/api/v3/order", self.baseurl,);
        let mut query = Vec::with_capacity(18usize);
        if let Some(v) = &iceberg_qty {
            query.push(("icebergQty", v.to_string()));
        }
        if let Some(v) = &new_client_order_id {
            query.push(("newClientOrderId", v.to_string()));
        }
        if let Some(v) = &new_order_resp_type {
            query.push(("newOrderRespType", v.to_string()));
        }
        if let Some(v) = &price {
            query.push(("price", v.to_string()));
        }
        if let Some(v) = &quantity {
            query.push(("quantity", v.to_string()));
        }
        if let Some(v) = &quote_order_qty {
            query.push(("quoteOrderQty", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        if let Some(v) = &self_trade_prevention_mode {
            query.push(("selfTradePreventionMode", v.to_string()));
        }
        query.push(("side", side.to_string()));
        query.push(("signature", signature.to_string()));
        if let Some(v) = &stop_price {
            query.push(("stopPrice", v.to_string()));
        }
        if let Some(v) = &strategy_id {
            query.push(("strategyId", v.to_string()));
        }
        if let Some(v) = &strategy_type {
            query.push(("strategyType", v.to_string()));
        }
        query.push(("symbol", symbol.to_string()));
        if let Some(v) = &time_in_force {
            query.push(("timeInForce", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        if let Some(v) = &trailing_delta {
            query.push(("trailingDelta", v.to_string()));
        }
        query.push(("type", type_.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Cancel Order (TRADE)

Cancel an active order.

Either `orderId` or `origClientOrderId` must be sent.

Weight(IP): 1

Sends a `DELETE` request to `/api/v3/order`

Arguments:
- `cancel_restrictions`
- `new_client_order_id`: Used to uniquely identify this cancel. Automatically generated by default
- `order_id`: Order id
- `orig_client_order_id`: Order id from client
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `symbol`: Trading symbol, e.g. BNBUSDT
- `timestamp`: UTC timestamp in ms
*/
    pub async fn cancel_order<'a>(
        &'a self,
        cancel_restrictions: Option<types::CancelOrderCancelRestrictions>,
        new_client_order_id: Option<&'a str>,
        order_id: Option<i64>,
        orig_client_order_id: Option<&'a str>,
        recv_window: Option<i64>,
        signature: &'a str,
        symbol: &'a str,
        timestamp: i64,
    ) -> Result<ResponseValue<types::Order>, Error<types::Error>> {
        let url = format!("{}/api/v3/order", self.baseurl,);
        let mut query = Vec::with_capacity(8usize);
        if let Some(v) = &cancel_restrictions {
            query.push(("cancelRestrictions", v.to_string()));
        }
        if let Some(v) = &new_client_order_id {
            query.push(("newClientOrderId", v.to_string()));
        }
        if let Some(v) = &order_id {
            query.push(("orderId", v.to_string()));
        }
        if let Some(v) = &orig_client_order_id {
            query.push(("origClientOrderId", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("symbol", symbol.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .delete(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Cancel an Existing Order and Send a New Order (Trade)

Cancels an existing order and places a new order on the same symbol.

Filters and Order Count are evaluated before the processing of the cancellation and order placement occurs.

A new order that was not attempted (i.e. when newOrderResult: NOT_ATTEMPTED), will still increase the order count by 1.

Weight(IP): 1

Sends a `POST` request to `/api/v3/order/cancelReplace`

Arguments:
- `cancel_new_client_order_id`: Used to uniquely identify this cancel. Automatically generated by default
- `cancel_order_id`: Either the cancelOrigClientOrderId or cancelOrderId must be provided. If both are provided, cancelOrderId takes precedence.
- `cancel_orig_client_order_id`: Either the cancelOrigClientOrderId or cancelOrderId must be provided. If both are provided, cancelOrderId takes precedence.
- `cancel_replace_mode`: - `STOP_ON_FAILURE` If the cancel request fails, the new order placement will not be attempted.
- `ALLOW_FAILURES` If new order placement will be attempted even if cancel request fails.
- `cancel_restrictions`
- `iceberg_qty`: Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
- `new_client_order_id`: Used to uniquely identify this cancel. Automatically generated by default
- `new_order_resp_type`: Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.
- `price`: Order price
- `quantity`: Order quantity
- `quote_order_qty`: Quote quantity
- `recv_window`: The value cannot be greater than 60000
- `self_trade_prevention_mode`: The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
- `side`
- `signature`: Signature
- `stop_price`: Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
- `strategy_id`
- `strategy_type`: The value cannot be less than 1000000.
- `symbol`: Trading symbol, e.g. BNBUSDT
- `time_in_force`: Order time in force
- `timestamp`: UTC timestamp in ms
- `trailing_delta`: Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
- `type_`: Order type
*/
    pub async fn replace_order<'a>(
        &'a self,
        cancel_new_client_order_id: Option<&'a str>,
        cancel_order_id: Option<i64>,
        cancel_orig_client_order_id: Option<&'a str>,
        cancel_replace_mode: &'a str,
        cancel_restrictions: Option<types::ReplaceOrderCancelRestrictions>,
        iceberg_qty: Option<f64>,
        new_client_order_id: Option<&'a str>,
        new_order_resp_type: Option<types::ReplaceOrderNewOrderRespType>,
        price: Option<f64>,
        quantity: Option<f64>,
        quote_order_qty: Option<f64>,
        recv_window: Option<i64>,
        self_trade_prevention_mode: Option<types::ReplaceOrderSelfTradePreventionMode>,
        side: types::ReplaceOrderSide,
        signature: &'a str,
        stop_price: Option<f64>,
        strategy_id: Option<i64>,
        strategy_type: Option<i64>,
        symbol: &'a str,
        time_in_force: Option<types::ReplaceOrderTimeInForce>,
        timestamp: i64,
        trailing_delta: Option<f64>,
        type_: types::ReplaceOrderType,
    ) -> Result<ResponseValue<types::ReplaceOrderResponse>, Error<types::Error>> {
        let url = format!("{}/api/v3/order/cancelReplace", self.baseurl,);
        let mut query = Vec::with_capacity(23usize);
        if let Some(v) = &cancel_new_client_order_id {
            query.push(("cancelNewClientOrderId", v.to_string()));
        }
        if let Some(v) = &cancel_order_id {
            query.push(("cancelOrderId", v.to_string()));
        }
        if let Some(v) = &cancel_orig_client_order_id {
            query.push(("cancelOrigClientOrderId", v.to_string()));
        }
        query.push(("cancelReplaceMode", cancel_replace_mode.to_string()));
        if let Some(v) = &cancel_restrictions {
            query.push(("cancelRestrictions", v.to_string()));
        }
        if let Some(v) = &iceberg_qty {
            query.push(("icebergQty", v.to_string()));
        }
        if let Some(v) = &new_client_order_id {
            query.push(("newClientOrderId", v.to_string()));
        }
        if let Some(v) = &new_order_resp_type {
            query.push(("newOrderRespType", v.to_string()));
        }
        if let Some(v) = &price {
            query.push(("price", v.to_string()));
        }
        if let Some(v) = &quantity {
            query.push(("quantity", v.to_string()));
        }
        if let Some(v) = &quote_order_qty {
            query.push(("quoteOrderQty", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        if let Some(v) = &self_trade_prevention_mode {
            query.push(("selfTradePreventionMode", v.to_string()));
        }
        query.push(("side", side.to_string()));
        query.push(("signature", signature.to_string()));
        if let Some(v) = &stop_price {
            query.push(("stopPrice", v.to_string()));
        }
        if let Some(v) = &strategy_id {
            query.push(("strategyId", v.to_string()));
        }
        if let Some(v) = &strategy_type {
            query.push(("strategyType", v.to_string()));
        }
        query.push(("symbol", symbol.to_string()));
        if let Some(v) = &time_in_force {
            query.push(("timeInForce", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        if let Some(v) = &trailing_delta {
            query.push(("trailingDelta", v.to_string()));
        }
        query.push(("type", type_.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Current Open Orders (USER_DATA)

Get all open orders on a symbol. Careful when accessing this with no symbol.

Weight(IP):
- `6` for a single symbol;
- `80` when the symbol parameter is omitted;

Sends a `GET` request to `/api/v3/openOrders`

Arguments:
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `symbol`: Trading symbol, e.g. BNBUSDT
- `timestamp`: UTC timestamp in ms
*/
    pub async fn list_open_orders<'a>(
        &'a self,
        recv_window: Option<i64>,
        signature: &'a str,
        symbol: Option<&'a str>,
        timestamp: i64,
    ) -> Result<ResponseValue<Vec<types::OrderDetails>>, Error<types::Error>> {
        let url = format!("{}/api/v3/openOrders", self.baseurl,);
        let mut query = Vec::with_capacity(4usize);
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &symbol {
            query.push(("symbol", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Cancel all Open Orders on a Symbol (TRADE)

Cancels all active orders on a symbol.
This includes OCO orders.

Weight(IP): 1

Sends a `DELETE` request to `/api/v3/openOrders`

Arguments:
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `symbol`: Trading symbol, e.g. BNBUSDT
- `timestamp`: UTC timestamp in ms
*/
    pub async fn cancel_open_orders<'a>(
        &'a self,
        recv_window: Option<i64>,
        signature: &'a str,
        symbol: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<Vec<types::CancelOpenOrdersResponseItem>>,
        Error<types::Error>,
    > {
        let url = format!("{}/api/v3/openOrders", self.baseurl,);
        let mut query = Vec::with_capacity(4usize);
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("symbol", symbol.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .delete(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**All Orders (USER_DATA)

Get all account orders; active, canceled, or filled..

- If `orderId` is set, it will get orders >= that `orderId`. Otherwise most recent orders are returned.
- For some historical orders `cummulativeQuoteQty` will be < 0, meaning the data is not available at this time.
- If `startTime` and/or `endTime` provided, `orderId` is not required

Weight(IP): 20

Sends a `GET` request to `/api/v3/allOrders`

Arguments:
- `end_time`: UTC timestamp in ms
- `limit`: Default 500; max 1000.
- `order_id`: Order id
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `start_time`: UTC timestamp in ms
- `symbol`: Trading symbol, e.g. BNBUSDT
- `timestamp`: UTC timestamp in ms
*/
    pub async fn all_orders<'a>(
        &'a self,
        end_time: Option<i64>,
        limit: Option<i32>,
        order_id: Option<i64>,
        recv_window: Option<i64>,
        signature: &'a str,
        start_time: Option<i64>,
        symbol: &'a str,
        timestamp: i64,
    ) -> Result<ResponseValue<Vec<types::OrderDetails>>, Error<types::Error>> {
        let url = format!("{}/api/v3/allOrders", self.baseurl,);
        let mut query = Vec::with_capacity(8usize);
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }
        if let Some(v) = &order_id {
            query.push(("orderId", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        query.push(("symbol", symbol.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**New OCO (TRADE)

Send in a new OCO

- Price Restrictions:
  - `SELL`: Limit Price > Last Price > Stop Price
  - `BUY`: Limit Price < Last Price < Stop Price
- Quantity Restrictions:
    - Both legs must have the same quantity
    - `ICEBERG` quantities however do not have to be the same
- Order Rate Limit
    - `OCO` counts as 2 orders against the order rate limit.

Weight(IP): 1

Sends a `POST` request to `/api/v3/order/oco`

Arguments:
- `limit_client_order_id`: A unique Id for the limit order
- `limit_iceberg_qty`
- `limit_strategy_id`
- `limit_strategy_type`: The value cannot be less than 1000000.
- `list_client_order_id`: A unique Id for the entire orderList
- `new_order_resp_type`: Set the response JSON.
- `price`: Order price
- `quantity`
- `recv_window`: The value cannot be greater than 60000
- `self_trade_prevention_mode`: The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
- `side`
- `signature`: Signature
- `stop_client_order_id`: A unique Id for the stop loss/stop loss limit leg
- `stop_iceberg_qty`
- `stop_limit_price`: If provided, stopLimitTimeInForce is required.
- `stop_limit_time_in_force`
- `stop_price`
- `stop_strategy_id`
- `stop_strategy_type`
- `symbol`: Trading symbol, e.g. BNBUSDT
- `timestamp`: UTC timestamp in ms
- `trailing_delta`
*/
    pub async fn place_order_oco<'a>(
        &'a self,
        limit_client_order_id: Option<&'a str>,
        limit_iceberg_qty: Option<f64>,
        limit_strategy_id: Option<i64>,
        limit_strategy_type: Option<i64>,
        list_client_order_id: Option<&'a str>,
        new_order_resp_type: Option<types::PlaceOrderOcoNewOrderRespType>,
        price: f64,
        quantity: f64,
        recv_window: Option<i64>,
        self_trade_prevention_mode: Option<types::PlaceOrderOcoSelfTradePreventionMode>,
        side: types::PlaceOrderOcoSide,
        signature: &'a str,
        stop_client_order_id: Option<&'a str>,
        stop_iceberg_qty: Option<f64>,
        stop_limit_price: Option<f64>,
        stop_limit_time_in_force: Option<types::PlaceOrderOcoStopLimitTimeInForce>,
        stop_price: f64,
        stop_strategy_id: Option<i64>,
        stop_strategy_type: Option<i64>,
        symbol: &'a str,
        timestamp: i64,
        trailing_delta: Option<f64>,
    ) -> Result<ResponseValue<types::PlaceOrderOcoResponse>, Error<types::Error>> {
        let url = format!("{}/api/v3/order/oco", self.baseurl,);
        let mut query = Vec::with_capacity(22usize);
        if let Some(v) = &limit_client_order_id {
            query.push(("limitClientOrderId", v.to_string()));
        }
        if let Some(v) = &limit_iceberg_qty {
            query.push(("limitIcebergQty", v.to_string()));
        }
        if let Some(v) = &limit_strategy_id {
            query.push(("limitStrategyId", v.to_string()));
        }
        if let Some(v) = &limit_strategy_type {
            query.push(("limitStrategyType", v.to_string()));
        }
        if let Some(v) = &list_client_order_id {
            query.push(("listClientOrderId", v.to_string()));
        }
        if let Some(v) = &new_order_resp_type {
            query.push(("newOrderRespType", v.to_string()));
        }
        query.push(("price", price.to_string()));
        query.push(("quantity", quantity.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        if let Some(v) = &self_trade_prevention_mode {
            query.push(("selfTradePreventionMode", v.to_string()));
        }
        query.push(("side", side.to_string()));
        query.push(("signature", signature.to_string()));
        if let Some(v) = &stop_client_order_id {
            query.push(("stopClientOrderId", v.to_string()));
        }
        if let Some(v) = &stop_iceberg_qty {
            query.push(("stopIcebergQty", v.to_string()));
        }
        if let Some(v) = &stop_limit_price {
            query.push(("stopLimitPrice", v.to_string()));
        }
        if let Some(v) = &stop_limit_time_in_force {
            query.push(("stopLimitTimeInForce", v.to_string()));
        }
        query.push(("stopPrice", stop_price.to_string()));
        if let Some(v) = &stop_strategy_id {
            query.push(("stopStrategyId", v.to_string()));
        }
        if let Some(v) = &stop_strategy_type {
            query.push(("stopStrategyType", v.to_string()));
        }
        query.push(("symbol", symbol.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        if let Some(v) = &trailing_delta {
            query.push(("trailingDelta", v.to_string()));
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Query OCO (USER_DATA)

Retrieves a specific OCO based on provided optional parameters

Weight(IP): 4

Sends a `GET` request to `/api/v3/orderList`

Arguments:
- `order_list_id`: Order list id
- `orig_client_order_id`: Order id from client
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn order_list<'a>(
        &'a self,
        order_list_id: Option<i64>,
        orig_client_order_id: Option<&'a str>,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<ResponseValue<types::OrderListResponse>, Error<types::Error>> {
        let url = format!("{}/api/v3/orderList", self.baseurl,);
        let mut query = Vec::with_capacity(5usize);
        if let Some(v) = &order_list_id {
            query.push(("orderListId", v.to_string()));
        }
        if let Some(v) = &orig_client_order_id {
            query.push(("origClientOrderId", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Cancel OCO (TRADE)

Cancel an entire Order List

Canceling an individual leg will cancel the entire OCO

Weight(IP): 1

Sends a `DELETE` request to `/api/v3/orderList`

Arguments:
- `list_client_order_id`: A unique Id for the entire orderList
- `new_client_order_id`: Used to uniquely identify this cancel. Automatically generated by default
- `order_list_id`: Order list id
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `symbol`: Trading symbol, e.g. BNBUSDT
- `timestamp`: UTC timestamp in ms
*/
    pub async fn delete_order_list<'a>(
        &'a self,
        list_client_order_id: Option<&'a str>,
        new_client_order_id: Option<&'a str>,
        order_list_id: Option<i64>,
        recv_window: Option<i64>,
        signature: &'a str,
        symbol: &'a str,
        timestamp: i64,
    ) -> Result<ResponseValue<types::OcoOrder>, Error<types::Error>> {
        let url = format!("{}/api/v3/orderList", self.baseurl,);
        let mut query = Vec::with_capacity(7usize);
        if let Some(v) = &list_client_order_id {
            query.push(("listClientOrderId", v.to_string()));
        }
        if let Some(v) = &new_client_order_id {
            query.push(("newClientOrderId", v.to_string()));
        }
        if let Some(v) = &order_list_id {
            query.push(("orderListId", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("symbol", symbol.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .delete(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Query all OCO (USER_DATA)

Retrieves all OCO based on provided optional parameters

Weight(IP): 20

Sends a `GET` request to `/api/v3/allOrderList`

Arguments:
- `end_time`: UTC timestamp in ms
- `from_id`: Trade id to fetch from. Default gets most recent trades.
- `limit`: Default 500; max 1000.
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `start_time`: UTC timestamp in ms
- `timestamp`: UTC timestamp in ms
*/
    pub async fn all_order_list<'a>(
        &'a self,
        end_time: Option<i64>,
        from_id: Option<i64>,
        limit: Option<i32>,
        recv_window: Option<i64>,
        signature: &'a str,
        start_time: Option<i64>,
        timestamp: i64,
    ) -> Result<
        ResponseValue<Vec<types::AllOrderListResponseItem>>,
        Error<types::Error>,
    > {
        let url = format!("{}/api/v3/allOrderList", self.baseurl,);
        let mut query = Vec::with_capacity(7usize);
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        if let Some(v) = &from_id {
            query.push(("fromId", v.to_string()));
        }
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Query Open OCO (USER_DATA)

Weight(IP): 6

Sends a `GET` request to `/api/v3/openOrderList`

Arguments:
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn open_order_list<'a>(
        &'a self,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<Vec<types::OpenOrderListResponseItem>>,
        Error<types::Error>,
    > {
        let url = format!("{}/api/v3/openOrderList", self.baseurl,);
        let mut query = Vec::with_capacity(3usize);
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**New order using SOR (TRADE)

Weight(IP): 6

Sends a `POST` request to `/api/v3/sor/order`

Arguments:
- `iceberg_qty`: Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
- `new_client_order_id`: Used to uniquely identify this cancel. Automatically generated by default
- `new_order_resp_type`: Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.
- `price`
- `quantity`
- `recv_window`: The value cannot be greater than 60000
- `self_trade_prevention_mode`: The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
- `side`
- `signature`: Signature
- `strategy_id`
- `strategy_type`: The value cannot be less than 1000000.
- `symbol`: Trading symbol, e.g. BNBUSDT
- `time_in_force`: Order time in force
- `timestamp`: UTC timestamp in ms
- `type_`: Order type
*/
    pub async fn sor_order<'a>(
        &'a self,
        iceberg_qty: Option<f64>,
        new_client_order_id: Option<&'a str>,
        new_order_resp_type: Option<types::SorOrderNewOrderRespType>,
        price: Option<f64>,
        quantity: f64,
        recv_window: Option<i64>,
        self_trade_prevention_mode: Option<types::SorOrderSelfTradePreventionMode>,
        side: types::SorOrderSide,
        signature: &'a str,
        strategy_id: Option<i64>,
        strategy_type: Option<i64>,
        symbol: &'a str,
        time_in_force: Option<types::SorOrderTimeInForce>,
        timestamp: i64,
        type_: types::SorOrderType,
    ) -> Result<ResponseValue<types::SorOrderResponse>, Error<types::Error>> {
        let url = format!("{}/api/v3/sor/order", self.baseurl,);
        let mut query = Vec::with_capacity(15usize);
        if let Some(v) = &iceberg_qty {
            query.push(("icebergQty", v.to_string()));
        }
        if let Some(v) = &new_client_order_id {
            query.push(("newClientOrderId", v.to_string()));
        }
        if let Some(v) = &new_order_resp_type {
            query.push(("newOrderRespType", v.to_string()));
        }
        if let Some(v) = &price {
            query.push(("price", v.to_string()));
        }
        query.push(("quantity", quantity.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        if let Some(v) = &self_trade_prevention_mode {
            query.push(("selfTradePreventionMode", v.to_string()));
        }
        query.push(("side", side.to_string()));
        query.push(("signature", signature.to_string()));
        if let Some(v) = &strategy_id {
            query.push(("strategyId", v.to_string()));
        }
        if let Some(v) = &strategy_type {
            query.push(("strategyType", v.to_string()));
        }
        query.push(("symbol", symbol.to_string()));
        if let Some(v) = &time_in_force {
            query.push(("timeInForce", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        query.push(("type", type_.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Test new order using SOR (TRADE)

Test new order creation and signature/recvWindow using smart order routing (SOR).
Creates and validates a new order but does not send it into the matching engine.

Sends a `POST` request to `/api/v3/sor/order/test`

Arguments:
- `iceberg_qty`: Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
- `new_client_order_id`: Used to uniquely identify this cancel. Automatically generated by default
- `new_order_resp_type`: Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.
- `price`
- `quantity`
- `recv_window`: The value cannot be greater than 60000
- `self_trade_prevention_mode`: The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
- `side`
- `signature`: Signature
- `strategy_id`
- `strategy_type`: The value cannot be less than 1000000.
- `symbol`: Trading symbol, e.g. BNBUSDT
- `time_in_force`: Order time in force
- `timestamp`: UTC timestamp in ms
- `type_`: Order type
*/
    pub async fn sor_order_test<'a>(
        &'a self,
        iceberg_qty: Option<f64>,
        new_client_order_id: Option<&'a str>,
        new_order_resp_type: Option<types::SorOrderTestNewOrderRespType>,
        price: Option<f64>,
        quantity: f64,
        recv_window: Option<i64>,
        self_trade_prevention_mode: Option<types::SorOrderTestSelfTradePreventionMode>,
        side: types::SorOrderTestSide,
        signature: &'a str,
        strategy_id: Option<i64>,
        strategy_type: Option<i64>,
        symbol: &'a str,
        time_in_force: Option<types::SorOrderTestTimeInForce>,
        timestamp: i64,
        type_: types::SorOrderTestType,
    ) -> Result<
        ResponseValue<serde_json::Map<String, serde_json::Value>>,
        Error<types::Error>,
    > {
        let url = format!("{}/api/v3/sor/order/test", self.baseurl,);
        let mut query = Vec::with_capacity(15usize);
        if let Some(v) = &iceberg_qty {
            query.push(("icebergQty", v.to_string()));
        }
        if let Some(v) = &new_client_order_id {
            query.push(("newClientOrderId", v.to_string()));
        }
        if let Some(v) = &new_order_resp_type {
            query.push(("newOrderRespType", v.to_string()));
        }
        if let Some(v) = &price {
            query.push(("price", v.to_string()));
        }
        query.push(("quantity", quantity.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        if let Some(v) = &self_trade_prevention_mode {
            query.push(("selfTradePreventionMode", v.to_string()));
        }
        query.push(("side", side.to_string()));
        query.push(("signature", signature.to_string()));
        if let Some(v) = &strategy_id {
            query.push(("strategyId", v.to_string()));
        }
        if let Some(v) = &strategy_type {
            query.push(("strategyType", v.to_string()));
        }
        query.push(("symbol", symbol.to_string()));
        if let Some(v) = &time_in_force {
            query.push(("timeInForce", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        query.push(("type", type_.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Account Information (USER_DATA)

Get current account information.

Weight(IP): 20

Sends a `GET` request to `/api/v3/account`

Arguments:
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn account<'a>(
        &'a self,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<ResponseValue<types::Account>, Error<types::Error>> {
        let url = format!("{}/api/v3/account", self.baseurl,);
        let mut query = Vec::with_capacity(3usize);
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Account Trade List (USER_DATA)

Get trades for a specific account and symbol.

If `fromId` is set, it will get id >= that `fromId`. Otherwise most recent orders are returned.

The time between startTime and endTime can't be longer than 24 hours.
These are the supported combinations of all parameters:

  symbol

  symbol + orderId

  symbol + startTime

  symbol + endTime

  symbol + fromId

  symbol + startTime + endTime

  symbol+ orderId + fromId

Weight(IP): 20

Sends a `GET` request to `/api/v3/myTrades`

Arguments:
- `end_time`: UTC timestamp in ms
- `from_id`: Trade id to fetch from. Default gets most recent trades.
- `limit`: Default 500; max 1000.
- `order_id`: This can only be used in combination with symbol.
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `start_time`: UTC timestamp in ms
- `symbol`: Trading symbol, e.g. BNBUSDT
- `timestamp`: UTC timestamp in ms
*/
    pub async fn my_trades<'a>(
        &'a self,
        end_time: Option<i64>,
        from_id: Option<i64>,
        limit: Option<i32>,
        order_id: Option<i64>,
        recv_window: Option<i64>,
        signature: &'a str,
        start_time: Option<i64>,
        symbol: &'a str,
        timestamp: i64,
    ) -> Result<ResponseValue<Vec<types::MyTrade>>, Error<types::Error>> {
        let url = format!("{}/api/v3/myTrades", self.baseurl,);
        let mut query = Vec::with_capacity(9usize);
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        if let Some(v) = &from_id {
            query.push(("fromId", v.to_string()));
        }
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }
        if let Some(v) = &order_id {
            query.push(("orderId", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        query.push(("symbol", symbol.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Query Current Order Count Usage (TRADE)

Displays the user's current order count usage for all intervals.

Weight(IP): 40

Sends a `GET` request to `/api/v3/rateLimit/order`

Arguments:
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn rate_limit_order<'a>(
        &'a self,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<Vec<types::RateLimitOrderResponseItem>>,
        Error<types::Error>,
    > {
        let url = format!("{}/api/v3/rateLimit/order", self.baseurl,);
        let mut query = Vec::with_capacity(3usize);
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Query Prevented Matches

Displays the list of orders that were expired because of STP.

For additional information on what a Prevented match is, as well as Self Trade Prevention (STP), please refer to our STP FAQ page.

These are the combinations supported:

* symbol + preventedMatchId
* symbol + orderId
* symbol + orderId + fromPreventedMatchId (limit will default to 500)
* symbol + orderId + fromPreventedMatchId + limit

Weight(IP):

Case 	                          Weight
If symbol is invalid: 	        2
Querying by preventedMatchId: 	2
Querying by orderId: 	          20

Sends a `GET` request to `/api/v3/myPreventedMatches`

Arguments:
- `from_prevented_match_id`
- `limit`: Default 500; max 1000.
- `order_id`: Order id
- `prevented_match_id`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `symbol`: Trading symbol, e.g. BNBUSDT
- `timestamp`: UTC timestamp in ms
*/
    pub async fn my_prevented_matches<'a>(
        &'a self,
        from_prevented_match_id: Option<i64>,
        limit: Option<i32>,
        order_id: Option<i64>,
        prevented_match_id: Option<i64>,
        recv_window: Option<i64>,
        signature: &'a str,
        symbol: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<Vec<types::MyPreventedMatchesResponseItem>>,
        Error<types::Error>,
    > {
        let url = format!("{}/api/v3/myPreventedMatches", self.baseurl,);
        let mut query = Vec::with_capacity(8usize);
        if let Some(v) = &from_prevented_match_id {
            query.push(("fromPreventedMatchId", v.to_string()));
        }
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }
        if let Some(v) = &order_id {
            query.push(("orderId", v.to_string()));
        }
        if let Some(v) = &prevented_match_id {
            query.push(("preventedMatchId", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("symbol", symbol.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Query Allocations (USER_DATA)

Retrieves allocations resulting from SOR order placement.

Weight: 20

Supported parameter combinations:
Parameters 	                          Response
symbol 	                              allocations from oldest to newest
symbol + startTime 	                  oldest allocations since startTime
symbol + endTime 	                    newest allocations until endTime
symbol + startTime + endTime 	        allocations within the time range
symbol + fromAllocationId 	          allocations by allocation ID
symbol + orderId 	                    allocations related to an order starting with oldest
symbol + orderId + fromAllocationId 	allocations related to an order by allocation ID

Note: The time between startTime and endTime can't be longer than 24 hours.

Sends a `GET` request to `/api/v3/myAllocations`

Arguments:
- `end_time`: UTC timestamp in ms
- `from_allocation_id`
- `limit`: Default 500; max 1000.
- `order_id`: Order id
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `start_time`: UTC timestamp in ms
- `symbol`: Trading symbol, e.g. BNBUSDT
- `timestamp`: UTC timestamp in ms
*/
    pub async fn my_allocations<'a>(
        &'a self,
        end_time: Option<i64>,
        from_allocation_id: Option<i64>,
        limit: Option<i32>,
        order_id: Option<i64>,
        recv_window: Option<i64>,
        signature: &'a str,
        start_time: Option<i64>,
        symbol: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<Vec<types::MyAllocationsResponseItem>>,
        Error<types::Error>,
    > {
        let url = format!("{}/api/v3/myAllocations", self.baseurl,);
        let mut query = Vec::with_capacity(9usize);
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        if let Some(v) = &from_allocation_id {
            query.push(("fromAllocationId", v.to_string()));
        }
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }
        if let Some(v) = &order_id {
            query.push(("orderId", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        query.push(("symbol", symbol.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get Cross Margin Transfer History (USER_DATA)

- Response in descending order
- Returns data for last 7 days by default
- Set `archived` to `true` to query data from 6 months ago

Weight(IP): 1

Sends a `GET` request to `/sapi/v1/margin/transfer`

Arguments:
- `archived`: Default: false. Set to true for archived data from 6 months ago
- `asset`
- `current`: Current querying page. Start from 1. Default:1
- `end_time`: UTC timestamp in ms
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `size`: Default:10 Max:100
- `start_time`: UTC timestamp in ms
- `timestamp`: UTC timestamp in ms
- `type_`
*/
    pub async fn get_margin_transfer<'a>(
        &'a self,
        archived: Option<&'a str>,
        asset: Option<&'a str>,
        current: Option<i32>,
        end_time: Option<i64>,
        recv_window: Option<i64>,
        signature: &'a str,
        size: Option<i32>,
        start_time: Option<i64>,
        timestamp: i64,
        type_: Option<types::GetMarginTransferType>,
    ) -> Result<ResponseValue<types::GetMarginTransferResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/margin/transfer", self.baseurl,);
        let mut query = Vec::with_capacity(10usize);
        if let Some(v) = &archived {
            query.push(("archived", v.to_string()));
        }
        if let Some(v) = &asset {
            query.push(("asset", v.to_string()));
        }
        if let Some(v) = &current {
            query.push(("current", v.to_string()));
        }
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &size {
            query.push(("size", v.to_string()));
        }
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        if let Some(v) = &type_ {
            query.push(("type", v.to_string()));
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Cross Margin Account Transfer (MARGIN)

Execute transfer between spot account and cross margin account.

Weight(IP): 600

Sends a `POST` request to `/sapi/v1/margin/transfer`

Arguments:
- `amount`
- `asset`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
- `type_`: * `1` - transfer from main account to margin account
* `2` - transfer from margin account to main account
*/
    pub async fn execute_margin_transfer<'a>(
        &'a self,
        amount: f64,
        asset: &'a str,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
        type_: i64,
    ) -> Result<ResponseValue<types::Transaction>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/margin/transfer", self.baseurl,);
        let mut query = Vec::with_capacity(6usize);
        query.push(("amount", amount.to_string()));
        query.push(("asset", asset.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        query.push(("type", type_.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Query Loan Record (USER_DATA)

- `txId` or `startTime` must be sent. `txId` takes precedence.
- Response in descending order
- If `isolatedSymbol` is not sent, crossed margin data will be returned
- Set `archived` to `true` to query data from 6 months ago

Weight(IP): 10

Sends a `GET` request to `/sapi/v1/margin/loan`

Arguments:
- `archived`: Default: false. Set to true for archived data from 6 months ago
- `asset`
- `current`: Current querying page. Start from 1. Default:1
- `end_time`: UTC timestamp in ms
- `isolated_symbol`: Isolated symbol
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `size`: Default:10 Max:100
- `start_time`: UTC timestamp in ms
- `timestamp`: UTC timestamp in ms
- `tx_id`: the tranId in  `POST /sapi/v1/margin/loan`
*/
    pub async fn query_margin_loan_record<'a>(
        &'a self,
        archived: Option<&'a str>,
        asset: &'a str,
        current: Option<i32>,
        end_time: Option<i64>,
        isolated_symbol: Option<&'a str>,
        recv_window: Option<i64>,
        signature: &'a str,
        size: Option<i32>,
        start_time: Option<i64>,
        timestamp: i64,
        tx_id: Option<i64>,
    ) -> Result<
        ResponseValue<types::QueryMarginLoanRecordResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/margin/loan", self.baseurl,);
        let mut query = Vec::with_capacity(11usize);
        if let Some(v) = &archived {
            query.push(("archived", v.to_string()));
        }
        query.push(("asset", asset.to_string()));
        if let Some(v) = &current {
            query.push(("current", v.to_string()));
        }
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        if let Some(v) = &isolated_symbol {
            query.push(("isolatedSymbol", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &size {
            query.push(("size", v.to_string()));
        }
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        if let Some(v) = &tx_id {
            query.push(("txId", v.to_string()));
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Margin Account Borrow (MARGIN)

Apply for a loan.

- If "isIsolated" = "TRUE", "symbol" must be sent
- "isIsolated" = "FALSE" for crossed margin loan

Weight(UID): 3000

Sends a `POST` request to `/sapi/v1/margin/loan`

Arguments:
- `amount`
- `asset`
- `is_isolated`: * `TRUE` - For isolated margin
* `FALSE` - Default, not for isolated margin
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `symbol`: Trading symbol, e.g. BNBUSDT
- `timestamp`: UTC timestamp in ms
*/
    pub async fn apply_for_margin_loan<'a>(
        &'a self,
        amount: f64,
        asset: &'a str,
        is_isolated: Option<types::ApplyForMarginLoanIsIsolated>,
        recv_window: Option<i64>,
        signature: &'a str,
        symbol: Option<&'a str>,
        timestamp: i64,
    ) -> Result<ResponseValue<types::Transaction>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/margin/loan", self.baseurl,);
        let mut query = Vec::with_capacity(7usize);
        query.push(("amount", amount.to_string()));
        query.push(("asset", asset.to_string()));
        if let Some(v) = &is_isolated {
            query.push(("isIsolated", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &symbol {
            query.push(("symbol", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Query Repay Record (USER_DATA)

- `txId` or `startTime` must be sent. `txId` takes precedence.
- Response in descending order
- If `isolatedSymbol` is not sent, crossed margin data will be returned
- Set `archived` to `true` to query data from 6 months ago

Weight(IP): 10

Sends a `GET` request to `/sapi/v1/margin/repay`

Arguments:
- `archived`: Default: false. Set to true for archived data from 6 months ago
- `asset`
- `current`: Current querying page. Start from 1. Default:1
- `end_time`: UTC timestamp in ms
- `isolated_symbol`: Isolated symbol
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `size`: Default:10 Max:100
- `start_time`: UTC timestamp in ms
- `timestamp`: UTC timestamp in ms
- `tx_id`: the tranId in  `POST /sapi/v1/margin/repay`
*/
    pub async fn query_margin_repay<'a>(
        &'a self,
        archived: Option<&'a str>,
        asset: &'a str,
        current: Option<i32>,
        end_time: Option<i64>,
        isolated_symbol: Option<&'a str>,
        recv_window: Option<i64>,
        signature: &'a str,
        size: Option<i32>,
        start_time: Option<i64>,
        timestamp: i64,
        tx_id: Option<i64>,
    ) -> Result<ResponseValue<types::QueryMarginRepayResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/margin/repay", self.baseurl,);
        let mut query = Vec::with_capacity(11usize);
        if let Some(v) = &archived {
            query.push(("archived", v.to_string()));
        }
        query.push(("asset", asset.to_string()));
        if let Some(v) = &current {
            query.push(("current", v.to_string()));
        }
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        if let Some(v) = &isolated_symbol {
            query.push(("isolatedSymbol", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &size {
            query.push(("size", v.to_string()));
        }
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        if let Some(v) = &tx_id {
            query.push(("txId", v.to_string()));
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Margin Account Repay (MARGIN)

Repay loan for margin account.

- If "isIsolated" = "TRUE", "symbol" must be sent
- "isIsolated" = "FALSE" for crossed margin repay

Weight(IP): 3000

Sends a `POST` request to `/sapi/v1/margin/repay`

Arguments:
- `amount`
- `asset`
- `is_isolated`: * `TRUE` - For isolated margin
* `FALSE` - Default, not for isolated margin
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `symbol`: Trading symbol, e.g. BNBUSDT
- `timestamp`: UTC timestamp in ms
*/
    pub async fn margin_repay<'a>(
        &'a self,
        amount: f64,
        asset: &'a str,
        is_isolated: Option<types::MarginRepayIsIsolated>,
        recv_window: Option<i64>,
        signature: &'a str,
        symbol: Option<&'a str>,
        timestamp: i64,
    ) -> Result<ResponseValue<types::Transaction>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/margin/repay", self.baseurl,);
        let mut query = Vec::with_capacity(7usize);
        query.push(("amount", amount.to_string()));
        query.push(("asset", asset.to_string()));
        if let Some(v) = &is_isolated {
            query.push(("isIsolated", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &symbol {
            query.push(("symbol", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Query Margin Asset (MARKET_DATA)

Weight(IP): 10

Sends a `GET` request to `/sapi/v1/margin/asset`

*/
    pub async fn margin_asset<'a>(
        &'a self,
        asset: &'a str,
    ) -> Result<ResponseValue<types::MarginAssetResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/margin/asset", self.baseurl,);
        let mut query = Vec::with_capacity(1usize);
        query.push(("asset", asset.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Query Cross Margin Pair (MARKET_DATA)

Weight(IP): 10

Sends a `GET` request to `/sapi/v1/margin/pair`

Arguments:
- `symbol`: Trading symbol, e.g. BNBUSDT
*/
    pub async fn margin_pair<'a>(
        &'a self,
        symbol: &'a str,
    ) -> Result<ResponseValue<types::MarginPairResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/margin/pair", self.baseurl,);
        let mut query = Vec::with_capacity(1usize);
        query.push(("symbol", symbol.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get All Margin Assets (MARKET_DATA)

Weight(IP): 1

Sends a `GET` request to `/sapi/v1/margin/allAssets`

*/
    pub async fn margin_all_assets<'a>(
        &'a self,
    ) -> Result<
        ResponseValue<Vec<types::MarginAllAssetsResponseItem>>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/margin/allAssets", self.baseurl,);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get All Cross Margin Pairs (MARKET_DATA)

Weight(IP): 1

Sends a `GET` request to `/sapi/v1/margin/allPairs`

*/
    pub async fn margin_all_pairs<'a>(
        &'a self,
    ) -> Result<
        ResponseValue<Vec<types::MarginAllPairsResponseItem>>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/margin/allPairs", self.baseurl,);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Query Margin PriceIndex (MARKET_DATA)

Weight(IP): 10

Sends a `GET` request to `/sapi/v1/margin/priceIndex`

Arguments:
- `symbol`: Trading symbol, e.g. BNBUSDT
*/
    pub async fn margin_price_index<'a>(
        &'a self,
        symbol: &'a str,
    ) -> Result<ResponseValue<types::MarginPriceIndexResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/margin/priceIndex", self.baseurl,);
        let mut query = Vec::with_capacity(1usize);
        query.push(("symbol", symbol.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Query Margin Account's Order (USER_DATA)

- Either `orderId` or `origClientOrderId` must be sent.
- For some historical orders `cummulativeQuoteQty` will be < 0, meaning the data is not available at this time.

Weight(IP): 10

Sends a `GET` request to `/sapi/v1/margin/order`

Arguments:
- `is_isolated`: * `TRUE` - For isolated margin
* `FALSE` - Default, not for isolated margin
- `order_id`: Order id
- `orig_client_order_id`: Order id from client
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `symbol`: Trading symbol, e.g. BNBUSDT
- `timestamp`: UTC timestamp in ms
*/
    pub async fn margin_order<'a>(
        &'a self,
        is_isolated: Option<types::MarginOrderIsIsolated>,
        order_id: Option<i64>,
        orig_client_order_id: Option<&'a str>,
        recv_window: Option<i64>,
        signature: &'a str,
        symbol: &'a str,
        timestamp: i64,
    ) -> Result<ResponseValue<types::MarginOrderDetail>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/margin/order", self.baseurl,);
        let mut query = Vec::with_capacity(7usize);
        if let Some(v) = &is_isolated {
            query.push(("isIsolated", v.to_string()));
        }
        if let Some(v) = &order_id {
            query.push(("orderId", v.to_string()));
        }
        if let Some(v) = &orig_client_order_id {
            query.push(("origClientOrderId", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("symbol", symbol.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Margin Account New Order (TRADE)

Post a new order for margin account.

Weight(UID): 6

Sends a `POST` request to `/sapi/v1/margin/order`

Arguments:
- `auto_repay_at_cancel`
- `iceberg_qty`: Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
- `is_isolated`: * `TRUE` - For isolated margin
* `FALSE` - Default, not for isolated margin
- `new_client_order_id`: Used to uniquely identify this cancel. Automatically generated by default
- `new_order_resp_type`: Set the response JSON.
- `price`: Order price
- `quantity`
- `quote_order_qty`: Quote quantity
- `recv_window`: The value cannot be greater than 60000
- `self_trade_prevention_mode`: The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
- `side`
- `side_effect_type`: Default `NO_SIDE_EFFECT`
- `signature`: Signature
- `stop_price`: Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
- `symbol`: Trading symbol, e.g. BNBUSDT
- `time_in_force`: Order time in force
- `timestamp`: UTC timestamp in ms
- `type_`: Order type
*/
    pub async fn post_margin_order<'a>(
        &'a self,
        auto_repay_at_cancel: bool,
        iceberg_qty: Option<f64>,
        is_isolated: Option<types::PostMarginOrderIsIsolated>,
        new_client_order_id: Option<&'a str>,
        new_order_resp_type: Option<types::PostMarginOrderNewOrderRespType>,
        price: Option<f64>,
        quantity: f64,
        quote_order_qty: Option<f64>,
        recv_window: Option<i64>,
        self_trade_prevention_mode: Option<
            types::PostMarginOrderSelfTradePreventionMode,
        >,
        side: types::PostMarginOrderSide,
        side_effect_type: Option<types::PostMarginOrderSideEffectType>,
        signature: &'a str,
        stop_price: Option<f64>,
        symbol: &'a str,
        time_in_force: Option<types::PostMarginOrderTimeInForce>,
        timestamp: i64,
        type_: types::PostMarginOrderType,
    ) -> Result<ResponseValue<types::PostMarginOrderResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/margin/order", self.baseurl,);
        let mut query = Vec::with_capacity(18usize);
        query.push(("autoRepayAtCancel", auto_repay_at_cancel.to_string()));
        if let Some(v) = &iceberg_qty {
            query.push(("icebergQty", v.to_string()));
        }
        if let Some(v) = &is_isolated {
            query.push(("isIsolated", v.to_string()));
        }
        if let Some(v) = &new_client_order_id {
            query.push(("newClientOrderId", v.to_string()));
        }
        if let Some(v) = &new_order_resp_type {
            query.push(("newOrderRespType", v.to_string()));
        }
        if let Some(v) = &price {
            query.push(("price", v.to_string()));
        }
        query.push(("quantity", quantity.to_string()));
        if let Some(v) = &quote_order_qty {
            query.push(("quoteOrderQty", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        if let Some(v) = &self_trade_prevention_mode {
            query.push(("selfTradePreventionMode", v.to_string()));
        }
        query.push(("side", side.to_string()));
        if let Some(v) = &side_effect_type {
            query.push(("sideEffectType", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &stop_price {
            query.push(("stopPrice", v.to_string()));
        }
        query.push(("symbol", symbol.to_string()));
        if let Some(v) = &time_in_force {
            query.push(("timeInForce", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        query.push(("type", type_.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Margin Account Cancel Order (TRADE)

Cancel an active order for margin account.

Either `orderId` or `origClientOrderId` must be sent.

Weight(IP): 10

Sends a `DELETE` request to `/sapi/v1/margin/order`

Arguments:
- `is_isolated`: * `TRUE` - For isolated margin
* `FALSE` - Default, not for isolated margin
- `new_client_order_id`: Used to uniquely identify this cancel. Automatically generated by default
- `order_id`: Order id
- `orig_client_order_id`: Order id from client
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `symbol`: Trading symbol, e.g. BNBUSDT
- `timestamp`: UTC timestamp in ms
*/
    pub async fn cancel_margin_order<'a>(
        &'a self,
        is_isolated: Option<types::CancelMarginOrderIsIsolated>,
        new_client_order_id: Option<&'a str>,
        order_id: Option<i64>,
        orig_client_order_id: Option<&'a str>,
        recv_window: Option<i64>,
        signature: &'a str,
        symbol: &'a str,
        timestamp: i64,
    ) -> Result<ResponseValue<types::MarginOrder>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/margin/order", self.baseurl,);
        let mut query = Vec::with_capacity(8usize);
        if let Some(v) = &is_isolated {
            query.push(("isIsolated", v.to_string()));
        }
        if let Some(v) = &new_client_order_id {
            query.push(("newClientOrderId", v.to_string()));
        }
        if let Some(v) = &order_id {
            query.push(("orderId", v.to_string()));
        }
        if let Some(v) = &orig_client_order_id {
            query.push(("origClientOrderId", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("symbol", symbol.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .delete(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get Interest History (USER_DATA)

- Response in descending order
- If `isolatedSymbol` is not sent, crossed margin data will be returned
- Set `archived` to `true` to query data from 6 months ago
- `type` in response has 4 enums:
  - `PERIODIC` interest charged per hour
  - `ON_BORROW` first interest charged on borrow
  - `PERIODIC_CONVERTED` interest charged per hour converted into BNB
  - `ON_BORROW_CONVERTED` first interest charged on borrow converted into BNB

Weight(IP): 1

Sends a `GET` request to `/sapi/v1/margin/interestHistory`

Arguments:
- `archived`: Default: false. Set to true for archived data from 6 months ago
- `asset`
- `current`: Current querying page. Start from 1. Default:1
- `end_time`: UTC timestamp in ms
- `isolated_symbol`: Isolated symbol
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `size`: Default:10 Max:100
- `start_time`: UTC timestamp in ms
- `timestamp`: UTC timestamp in ms
*/
    pub async fn margin_interest_history<'a>(
        &'a self,
        archived: Option<&'a str>,
        asset: Option<&'a str>,
        current: Option<i32>,
        end_time: Option<i64>,
        isolated_symbol: Option<&'a str>,
        recv_window: Option<i64>,
        signature: &'a str,
        size: Option<i32>,
        start_time: Option<i64>,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::MarginInterestHistoryResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/margin/interestHistory", self.baseurl,);
        let mut query = Vec::with_capacity(10usize);
        if let Some(v) = &archived {
            query.push(("archived", v.to_string()));
        }
        if let Some(v) = &asset {
            query.push(("asset", v.to_string()));
        }
        if let Some(v) = &current {
            query.push(("current", v.to_string()));
        }
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        if let Some(v) = &isolated_symbol {
            query.push(("isolatedSymbol", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &size {
            query.push(("size", v.to_string()));
        }
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get Force Liquidation Record (USER_DATA)

- Response in descending order

Weight(IP): 1

Sends a `GET` request to `/sapi/v1/margin/forceLiquidationRec`

Arguments:
- `current`: Current querying page. Start from 1. Default:1
- `end_time`: UTC timestamp in ms
- `isolated_symbol`: Isolated symbol
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `size`: Default:10 Max:100
- `start_time`: UTC timestamp in ms
- `timestamp`: UTC timestamp in ms
*/
    pub async fn margin_force_liquidation_rec<'a>(
        &'a self,
        current: Option<i32>,
        end_time: Option<i64>,
        isolated_symbol: Option<&'a str>,
        recv_window: Option<i64>,
        signature: &'a str,
        size: Option<i32>,
        start_time: Option<i64>,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::MarginForceLiquidationRecResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/margin/forceLiquidationRec", self.baseurl,);
        let mut query = Vec::with_capacity(8usize);
        if let Some(v) = &current {
            query.push(("current", v.to_string()));
        }
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        if let Some(v) = &isolated_symbol {
            query.push(("isolatedSymbol", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &size {
            query.push(("size", v.to_string()));
        }
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Query Cross Margin Account Details (USER_DATA)

Weight(IP): 10

Sends a `GET` request to `/sapi/v1/margin/account`

Arguments:
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn margin_account<'a>(
        &'a self,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<ResponseValue<types::MarginAccountResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/margin/account", self.baseurl,);
        let mut query = Vec::with_capacity(3usize);
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Query Margin Account's Open Orders (USER_DATA)

- If the `symbol` is not sent, orders for all symbols will be returned in an array.
- When all symbols are returned, the number of requests counted against the rate limiter is equal to the number of symbols currently trading on the exchange
- If isIsolated ="TRUE", symbol must be sent.

Weight(IP): 10

Sends a `GET` request to `/sapi/v1/margin/openOrders`

Arguments:
- `is_isolated`: * `TRUE` - For isolated margin
* `FALSE` - Default, not for isolated margin
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `symbol`: Trading symbol, e.g. BNBUSDT
- `timestamp`: UTC timestamp in ms
*/
    pub async fn margin_open_orders<'a>(
        &'a self,
        is_isolated: Option<types::MarginOpenOrdersIsIsolated>,
        recv_window: Option<i64>,
        signature: &'a str,
        symbol: Option<&'a str>,
        timestamp: i64,
    ) -> Result<ResponseValue<Vec<types::MarginOrderDetail>>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/margin/openOrders", self.baseurl,);
        let mut query = Vec::with_capacity(5usize);
        if let Some(v) = &is_isolated {
            query.push(("isIsolated", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &symbol {
            query.push(("symbol", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Margin Account Cancel all Open Orders on a Symbol (TRADE)

- Cancels all active orders on a symbol for margin account.
- This includes OCO orders.

Weight(IP): 1


Sends a `DELETE` request to `/sapi/v1/margin/openOrders`

Arguments:
- `is_isolated`: * `TRUE` - For isolated margin
* `FALSE` - Default, not for isolated margin
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `symbol`: Trading symbol, e.g. BNBUSDT
- `timestamp`: UTC timestamp in ms
*/
    pub async fn margin_cancel_orders<'a>(
        &'a self,
        is_isolated: Option<types::MarginCancelOrdersIsIsolated>,
        recv_window: Option<i64>,
        signature: &'a str,
        symbol: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<Vec<types::MarginCancelOrdersResponseItem>>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/margin/openOrders", self.baseurl,);
        let mut query = Vec::with_capacity(5usize);
        if let Some(v) = &is_isolated {
            query.push(("isIsolated", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("symbol", symbol.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .delete(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Query Margin Account's All Orders (USER_DATA)

- If `orderId` is set, it will get orders >= that orderId. Otherwise most recent orders are returned.
- For some historical orders `cummulativeQuoteQty` will be < 0, meaning the data is not available at this time.

Weight(IP): 200

Request Limit: 60 times/min per IP

Sends a `GET` request to `/sapi/v1/margin/allOrders`

Arguments:
- `end_time`: UTC timestamp in ms
- `is_isolated`: * `TRUE` - For isolated margin
* `FALSE` - Default, not for isolated margin
- `limit`: Default 500; max 1000.
- `order_id`: Order id
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `start_time`: UTC timestamp in ms
- `symbol`: Trading symbol, e.g. BNBUSDT
- `timestamp`: UTC timestamp in ms
*/
    pub async fn margin_query_all_orders<'a>(
        &'a self,
        end_time: Option<i64>,
        is_isolated: Option<types::MarginQueryAllOrdersIsIsolated>,
        limit: Option<i32>,
        order_id: Option<i64>,
        recv_window: Option<i64>,
        signature: &'a str,
        start_time: Option<i64>,
        symbol: &'a str,
        timestamp: i64,
    ) -> Result<ResponseValue<Vec<types::MarginOrderDetail>>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/margin/allOrders", self.baseurl,);
        let mut query = Vec::with_capacity(9usize);
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        if let Some(v) = &is_isolated {
            query.push(("isIsolated", v.to_string()));
        }
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }
        if let Some(v) = &order_id {
            query.push(("orderId", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        query.push(("symbol", symbol.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Margin Account New OCO (TRADE)

Send in a new OCO for a margin account

- Price Restrictions:
  - SELL: Limit Price > Last Price > Stop Price
  - BUY: Limit Price < Last Price < Stop Price
- Quantity Restrictions:
  - Both legs must have the same quantity
  - ICEBERG quantities however do not have to be the same.
- Order Rate Limit
  - OCO counts as 2 orders against the order rate limit.

Weight(UID): 6

Sends a `POST` request to `/sapi/v1/margin/order/oco`

Arguments:
- `is_isolated`: * `TRUE` - For isolated margin
* `FALSE` - Default, not for isolated margin
- `limit_client_order_id`: A unique Id for the limit order
- `limit_iceberg_qty`
- `list_client_order_id`: A unique Id for the entire orderList
- `new_order_resp_type`: Set the response JSON.
- `price`: Order price
- `quantity`
- `recv_window`: The value cannot be greater than 60000
- `self_trade_prevention_mode`: The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
- `side`
- `side_effect_type`: Default `NO_SIDE_EFFECT`
- `signature`: Signature
- `stop_client_order_id`: A unique Id for the stop loss/stop loss limit leg
- `stop_iceberg_qty`
- `stop_limit_price`: If provided, stopLimitTimeInForce is required.
- `stop_limit_time_in_force`
- `stop_price`
- `symbol`: Trading symbol, e.g. BNBUSDT
- `timestamp`: UTC timestamp in ms
*/
    pub async fn send_margin_query_oco<'a>(
        &'a self,
        is_isolated: Option<types::SendMarginQueryOcoIsIsolated>,
        limit_client_order_id: Option<&'a str>,
        limit_iceberg_qty: Option<f64>,
        list_client_order_id: Option<&'a str>,
        new_order_resp_type: Option<types::SendMarginQueryOcoNewOrderRespType>,
        price: f64,
        quantity: f64,
        recv_window: Option<i64>,
        self_trade_prevention_mode: Option<
            types::SendMarginQueryOcoSelfTradePreventionMode,
        >,
        side: types::SendMarginQueryOcoSide,
        side_effect_type: Option<types::SendMarginQueryOcoSideEffectType>,
        signature: &'a str,
        stop_client_order_id: Option<&'a str>,
        stop_iceberg_qty: Option<f64>,
        stop_limit_price: Option<f64>,
        stop_limit_time_in_force: Option<types::SendMarginQueryOcoStopLimitTimeInForce>,
        stop_price: f64,
        symbol: &'a str,
        timestamp: i64,
    ) -> Result<ResponseValue<types::SendMarginQueryOcoResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/margin/order/oco", self.baseurl,);
        let mut query = Vec::with_capacity(19usize);
        if let Some(v) = &is_isolated {
            query.push(("isIsolated", v.to_string()));
        }
        if let Some(v) = &limit_client_order_id {
            query.push(("limitClientOrderId", v.to_string()));
        }
        if let Some(v) = &limit_iceberg_qty {
            query.push(("limitIcebergQty", v.to_string()));
        }
        if let Some(v) = &list_client_order_id {
            query.push(("listClientOrderId", v.to_string()));
        }
        if let Some(v) = &new_order_resp_type {
            query.push(("newOrderRespType", v.to_string()));
        }
        query.push(("price", price.to_string()));
        query.push(("quantity", quantity.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        if let Some(v) = &self_trade_prevention_mode {
            query.push(("selfTradePreventionMode", v.to_string()));
        }
        query.push(("side", side.to_string()));
        if let Some(v) = &side_effect_type {
            query.push(("sideEffectType", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &stop_client_order_id {
            query.push(("stopClientOrderId", v.to_string()));
        }
        if let Some(v) = &stop_iceberg_qty {
            query.push(("stopIcebergQty", v.to_string()));
        }
        if let Some(v) = &stop_limit_price {
            query.push(("stopLimitPrice", v.to_string()));
        }
        if let Some(v) = &stop_limit_time_in_force {
            query.push(("stopLimitTimeInForce", v.to_string()));
        }
        query.push(("stopPrice", stop_price.to_string()));
        query.push(("symbol", symbol.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Query Margin Account's OCO (USER_DATA)

Retrieves a specific OCO based on provided optional parameters

- Either `orderListId` or `origClientOrderId` must be provided

Weight(IP): 10

Sends a `GET` request to `/sapi/v1/margin/orderList`

Arguments:
- `is_isolated`: * `TRUE` - For isolated margin
* `FALSE` - Default, not for isolated margin
- `order_list_id`: Order list id
- `orig_client_order_id`: Order id from client
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `symbol`: Mandatory for isolated margin, not supported for cross margin
- `timestamp`: UTC timestamp in ms
*/
    pub async fn margin_order_list<'a>(
        &'a self,
        is_isolated: Option<types::MarginOrderListIsIsolated>,
        order_list_id: Option<i64>,
        orig_client_order_id: Option<&'a str>,
        recv_window: Option<i64>,
        signature: &'a str,
        symbol: Option<&'a str>,
        timestamp: i64,
    ) -> Result<ResponseValue<types::MarginOrderListResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/margin/orderList", self.baseurl,);
        let mut query = Vec::with_capacity(7usize);
        if let Some(v) = &is_isolated {
            query.push(("isIsolated", v.to_string()));
        }
        if let Some(v) = &order_list_id {
            query.push(("orderListId", v.to_string()));
        }
        if let Some(v) = &orig_client_order_id {
            query.push(("origClientOrderId", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &symbol {
            query.push(("symbol", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Margin Account Cancel OCO (TRADE)

Cancel an entire Order List for a margin account

- Canceling an individual leg will cancel the entire OCO
- Either `orderListId` or `listClientOrderId` must be provided

Weight(UID): 1

Sends a `DELETE` request to `/sapi/v1/margin/orderList`

Arguments:
- `is_isolated`: * `TRUE` - For isolated margin
* `FALSE` - Default, not for isolated margin
- `list_client_order_id`: A unique Id for the entire orderList
- `new_client_order_id`: Used to uniquely identify this cancel. Automatically generated by default
- `order_list_id`: Order list id
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `symbol`: Trading symbol, e.g. BNBUSDT
- `timestamp`: UTC timestamp in ms
*/
    pub async fn cancel_margin_order_oco<'a>(
        &'a self,
        is_isolated: Option<types::CancelMarginOrderOcoIsIsolated>,
        list_client_order_id: Option<&'a str>,
        new_client_order_id: Option<&'a str>,
        order_list_id: Option<i64>,
        recv_window: Option<i64>,
        signature: &'a str,
        symbol: &'a str,
        timestamp: i64,
    ) -> Result<ResponseValue<types::MarginOcoOrder>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/margin/orderList", self.baseurl,);
        let mut query = Vec::with_capacity(8usize);
        if let Some(v) = &is_isolated {
            query.push(("isIsolated", v.to_string()));
        }
        if let Some(v) = &list_client_order_id {
            query.push(("listClientOrderId", v.to_string()));
        }
        if let Some(v) = &new_client_order_id {
            query.push(("newClientOrderId", v.to_string()));
        }
        if let Some(v) = &order_list_id {
            query.push(("orderListId", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("symbol", symbol.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .delete(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Query Margin Account's all OCO (USER_DATA)

Retrieves all OCO for a specific margin account based on provided optional parameters

Weight(IP): 200

Sends a `GET` request to `/sapi/v1/margin/allOrderList`

Arguments:
- `end_time`: UTC timestamp in ms
- `from_id`: If supplied, neither `startTime` or `endTime` can be provided
- `is_isolated`: * `TRUE` - For isolated margin
* `FALSE` - Default, not for isolated margin
- `limit`: Default Value: 500; Max Value: 1000
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `start_time`: UTC timestamp in ms
- `symbol`: Mandatory for isolated margin, not supported for cross margin
- `timestamp`: UTC timestamp in ms
*/
    pub async fn margin_all_order_list<'a>(
        &'a self,
        end_time: Option<i64>,
        from_id: Option<&'a str>,
        is_isolated: Option<types::MarginAllOrderListIsIsolated>,
        limit: Option<i32>,
        recv_window: Option<i64>,
        signature: &'a str,
        start_time: Option<i64>,
        symbol: Option<&'a str>,
        timestamp: i64,
    ) -> Result<
        ResponseValue<Vec<types::MarginAllOrderListResponseItem>>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/margin/allOrderList", self.baseurl,);
        let mut query = Vec::with_capacity(9usize);
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        if let Some(v) = &from_id {
            query.push(("fromId", v.to_string()));
        }
        if let Some(v) = &is_isolated {
            query.push(("isIsolated", v.to_string()));
        }
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        if let Some(v) = &symbol {
            query.push(("symbol", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Query Margin Account's Open OCO (USER_DATA)

Weight(IP): 10

Sends a `GET` request to `/sapi/v1/margin/openOrderList`

Arguments:
- `is_isolated`: * `TRUE` - For isolated margin
* `FALSE` - Default, not for isolated margin
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `symbol`: Mandatory for isolated margin, not supported for cross margin
- `timestamp`: UTC timestamp in ms
*/
    pub async fn margin_open_order_list<'a>(
        &'a self,
        is_isolated: Option<types::MarginOpenOrderListIsIsolated>,
        recv_window: Option<i64>,
        signature: &'a str,
        symbol: Option<&'a str>,
        timestamp: i64,
    ) -> Result<
        ResponseValue<Vec<types::MarginOpenOrderListResponseItem>>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/margin/openOrderList", self.baseurl,);
        let mut query = Vec::with_capacity(5usize);
        if let Some(v) = &is_isolated {
            query.push(("isIsolated", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &symbol {
            query.push(("symbol", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Query Margin Account's Trade List (USER_DATA)

- If `fromId` is set, it will get orders >= that `fromId`. Otherwise most recent trades are returned.

Weight(IP): 10

Sends a `GET` request to `/sapi/v1/margin/myTrades`

Arguments:
- `end_time`: UTC timestamp in ms
- `from_id`: Trade id to fetch from. Default gets most recent trades.
- `is_isolated`: * `TRUE` - For isolated margin
* `FALSE` - Default, not for isolated margin
- `limit`: Default 500; max 1000.
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `start_time`: UTC timestamp in ms
- `symbol`: Trading symbol, e.g. BNBUSDT
- `timestamp`: UTC timestamp in ms
*/
    pub async fn margin_my_trades<'a>(
        &'a self,
        end_time: Option<i64>,
        from_id: Option<i64>,
        is_isolated: Option<types::MarginMyTradesIsIsolated>,
        limit: Option<i32>,
        recv_window: Option<i64>,
        signature: &'a str,
        start_time: Option<i64>,
        symbol: &'a str,
        timestamp: i64,
    ) -> Result<ResponseValue<Vec<types::MarginTrade>>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/margin/myTrades", self.baseurl,);
        let mut query = Vec::with_capacity(9usize);
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        if let Some(v) = &from_id {
            query.push(("fromId", v.to_string()));
        }
        if let Some(v) = &is_isolated {
            query.push(("isIsolated", v.to_string()));
        }
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        query.push(("symbol", symbol.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Query Max Borrow (USER_DATA)

- If `isolatedSymbol` is not sent, crossed margin data will be sent.
- `borrowLimit` is also available from https://www.binance.com/en/margin-fee

Weight(IP): 50

Sends a `GET` request to `/sapi/v1/margin/maxBorrowable`

Arguments:
- `asset`
- `isolated_symbol`: Isolated symbol
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn margin_max_borrowable<'a>(
        &'a self,
        asset: &'a str,
        isolated_symbol: Option<&'a str>,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<ResponseValue<types::MarginMaxBorrowableResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/margin/maxBorrowable", self.baseurl,);
        let mut query = Vec::with_capacity(5usize);
        query.push(("asset", asset.to_string()));
        if let Some(v) = &isolated_symbol {
            query.push(("isolatedSymbol", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Query Max Transfer-Out Amount (USER_DATA)

- If `isolatedSymbol` is not sent, crossed margin data will be sent.

Weight(IP): 50

Sends a `GET` request to `/sapi/v1/margin/maxTransferable`

Arguments:
- `asset`
- `isolated_symbol`: Isolated symbol
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn margin_max_transferable<'a>(
        &'a self,
        asset: &'a str,
        isolated_symbol: Option<&'a str>,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::MarginMaxTransferableResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/margin/maxTransferable", self.baseurl,);
        let mut query = Vec::with_capacity(5usize);
        query.push(("asset", asset.to_string()));
        if let Some(v) = &isolated_symbol {
            query.push(("isolatedSymbol", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get Summary of Margin account (USER_DATA)

Get personal margin level information

Weight(IP): 10

Sends a `GET` request to `/sapi/v1/margin/tradeCoeff`

Arguments:
- `email`: Email Address
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn margin_trade_coeff<'a>(
        &'a self,
        email: &'a str,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<ResponseValue<types::MarginTradeCoeffResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/margin/tradeCoeff", self.baseurl,);
        let mut query = Vec::with_capacity(4usize);
        query.push(("email", email.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get Isolated Margin Transfer History (USER_DATA)

Weight(IP): 1

Sends a `GET` request to `/sapi/v1/margin/isolated/transfer`

Arguments:
- `asset`
- `current`: Current querying page. Start from 1. Default:1
- `end_time`: UTC timestamp in ms
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `size`: Default:10 Max:100
- `start_time`: UTC timestamp in ms
- `symbol`: Trading symbol, e.g. BNBUSDT
- `timestamp`: UTC timestamp in ms
- `type_`
*/
    pub async fn query_margin_isolated_transfer<'a>(
        &'a self,
        asset: Option<&'a str>,
        current: Option<i32>,
        end_time: Option<i64>,
        recv_window: Option<i64>,
        signature: &'a str,
        size: Option<i32>,
        start_time: Option<i64>,
        symbol: &'a str,
        timestamp: i64,
        type_: Option<types::QueryMarginIsolatedTransferType>,
    ) -> Result<ResponseValue<types::MarginTransferDetails>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/margin/isolated/transfer", self.baseurl,);
        let mut query = Vec::with_capacity(10usize);
        if let Some(v) = &asset {
            query.push(("asset", v.to_string()));
        }
        if let Some(v) = &current {
            query.push(("current", v.to_string()));
        }
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &size {
            query.push(("size", v.to_string()));
        }
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        query.push(("symbol", symbol.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        if let Some(v) = &type_ {
            query.push(("type", v.to_string()));
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Isolated Margin Account Transfer (MARGIN)

Weight(UID): 600

Sends a `POST` request to `/sapi/v1/margin/isolated/transfer`

Arguments:
- `amount`
- `asset`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `symbol`: Trading symbol, e.g. BNBUSDT
- `timestamp`: UTC timestamp in ms
- `trans_from`
- `trans_to`
*/
    pub async fn post_margin_isolated_transfer<'a>(
        &'a self,
        amount: f64,
        asset: &'a str,
        recv_window: Option<i64>,
        signature: &'a str,
        symbol: &'a str,
        timestamp: i64,
        trans_from: types::PostMarginIsolatedTransferTransFrom,
        trans_to: types::PostMarginIsolatedTransferTransTo,
    ) -> Result<
        ResponseValue<serde_json::Map<String, serde_json::Value>>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/margin/isolated/transfer", self.baseurl,);
        let mut query = Vec::with_capacity(8usize);
        query.push(("amount", amount.to_string()));
        query.push(("asset", asset.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("symbol", symbol.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        query.push(("transFrom", trans_from.to_string()));
        query.push(("transTo", trans_to.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Query Isolated Margin Account Info (USER_DATA)

- If "symbols" is not sent, all isolated assets will be returned.
- If "symbols" is sent, only the isolated assets of the sent symbols will be returned.

Weight(IP): 10

Sends a `GET` request to `/sapi/v1/margin/isolated/account`

Arguments:
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `symbols`: Max 5 symbols can be sent; separated by ','
- `timestamp`: UTC timestamp in ms
*/
    pub async fn query_margin_isolated_account<'a>(
        &'a self,
        recv_window: Option<i64>,
        signature: &'a str,
        symbols: Option<&'a str>,
        timestamp: i64,
    ) -> Result<ResponseValue<types::IsolatedMarginAccountInfo>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/margin/isolated/account", self.baseurl,);
        let mut query = Vec::with_capacity(4usize);
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &symbols {
            query.push(("symbols", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Enable Isolated Margin Account (TRADE)

Enable isolated margin account for a specific symbol.

Weight(UID): 300

Sends a `POST` request to `/sapi/v1/margin/isolated/account`

Arguments:
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `symbol`: Trading symbol, e.g. BNBUSDT
- `timestamp`: UTC timestamp in ms
*/
    pub async fn post_margin_isolated_account<'a>(
        &'a self,
        recv_window: Option<i64>,
        signature: &'a str,
        symbol: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::PostMarginIsolatedAccountResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/margin/isolated/account", self.baseurl,);
        let mut query = Vec::with_capacity(4usize);
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("symbol", symbol.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Disable Isolated Margin Account (TRADE)

Disable isolated margin account for a specific symbol. Each trading pair can only be deactivated once every 24 hours .

Weight(UID): 300

Sends a `DELETE` request to `/sapi/v1/margin/isolated/account`

Arguments:
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `symbol`: Trading symbol, e.g. BNBUSDT
- `timestamp`: UTC timestamp in ms
*/
    pub async fn disable_isolated_margin_account<'a>(
        &'a self,
        recv_window: Option<i64>,
        signature: &'a str,
        symbol: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::DisableIsolatedMarginAccountResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/margin/isolated/account", self.baseurl,);
        let mut query = Vec::with_capacity(4usize);
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("symbol", symbol.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .delete(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Query Enabled Isolated Margin Account Limit (USER_DATA)

Query enabled isolated margin account limit.

Weight(IP): 1

Sends a `GET` request to `/sapi/v1/margin/isolated/accountLimit`

Arguments:
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn margin_isolated_account_limit<'a>(
        &'a self,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::MarginIsolatedAccountLimitResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/margin/isolated/accountLimit", self.baseurl,);
        let mut query = Vec::with_capacity(3usize);
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Query Isolated Margin Symbol (USER_DATA)

Weight(IP): 10

Sends a `GET` request to `/sapi/v1/margin/isolated/pair`

Arguments:
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `symbol`: Trading symbol, e.g. BNBUSDT
- `timestamp`: UTC timestamp in ms
*/
    pub async fn margin_isolated_pair<'a>(
        &'a self,
        recv_window: Option<i64>,
        signature: &'a str,
        symbol: &'a str,
        timestamp: i64,
    ) -> Result<ResponseValue<types::MarginIsolatedPairResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/margin/isolated/pair", self.baseurl,);
        let mut query = Vec::with_capacity(4usize);
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("symbol", symbol.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get All Isolated Margin Symbol(USER_DATA)

Weight(IP): 10

Sends a `GET` request to `/sapi/v1/margin/isolated/allPairs`

Arguments:
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn margin_isolated_all_pairs<'a>(
        &'a self,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<Vec<types::MarginIsolatedAllPairsResponseItem>>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/margin/isolated/allPairs", self.baseurl,);
        let mut query = Vec::with_capacity(3usize);
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get BNB Burn Status(USER_DATA)

Weight(IP): 1

Sends a `GET` request to `/sapi/v1/bnbBurn`

Arguments:
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn query_toggle_bnb_burn_status<'a>(
        &'a self,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<ResponseValue<types::BnbBurnStatus>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/bnbBurn", self.baseurl,);
        let mut query = Vec::with_capacity(3usize);
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Toggle BNB Burn On Spot Trade And Margin Interest (USER_DATA)

- "spotBNBBurn" and "interestBNBBurn" should be sent at least one.

Weight(IP): 1

Sends a `POST` request to `/sapi/v1/bnbBurn`

Arguments:
- `interest_bnb_burn`: Determines whether to use BNB to pay for margin loan's interest
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `spot_bnb_burn`: Determines whether to use BNB to pay for trading fees on SPOT
- `timestamp`: UTC timestamp in ms
*/
    pub async fn toggle_bnb_burn<'a>(
        &'a self,
        interest_bnb_burn: Option<types::ToggleBnbBurnInterestBnbBurn>,
        recv_window: Option<i64>,
        signature: &'a str,
        spot_bnb_burn: Option<types::ToggleBnbBurnSpotBnbBurn>,
        timestamp: i64,
    ) -> Result<ResponseValue<types::BnbBurnStatus>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/bnbBurn", self.baseurl,);
        let mut query = Vec::with_capacity(5usize);
        if let Some(v) = &interest_bnb_burn {
            query.push(("interestBNBBurn", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &spot_bnb_burn {
            query.push(("spotBNBBurn", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Margin Interest Rate History (USER_DATA)

The max interval between startTime and endTime is 30 days.

Weight(IP): 1

Sends a `GET` request to `/sapi/v1/margin/interestRateHistory`

Arguments:
- `asset`
- `end_time`: UTC timestamp in ms
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `start_time`: UTC timestamp in ms
- `timestamp`: UTC timestamp in ms
- `vip_level`: Defaults to user's vip level
*/
    pub async fn margin_interest_rate_history<'a>(
        &'a self,
        asset: &'a str,
        end_time: Option<i64>,
        recv_window: Option<i64>,
        signature: &'a str,
        start_time: Option<i64>,
        timestamp: i64,
        vip_level: Option<i32>,
    ) -> Result<
        ResponseValue<Vec<types::MarginInterestRateHistoryResponseItem>>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/margin/interestRateHistory", self.baseurl,);
        let mut query = Vec::with_capacity(7usize);
        query.push(("asset", asset.to_string()));
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        if let Some(v) = &vip_level {
            query.push(("vipLevel", v.to_string()));
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Query Cross Margin Fee Data (USER_DATA)

Get cross margin fee data collection with any vip level or user's current specific data as https://www.binance.com/en/margin-fee

Weight(IP): 1 when coin is specified; 5 when the coin parameter is omitted

Sends a `GET` request to `/sapi/v1/margin/crossMarginData`

Arguments:
- `coin`: Coin name
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
- `vip_level`: Defaults to user's vip level
*/
    pub async fn margin_cross_margin_data<'a>(
        &'a self,
        coin: Option<&'a str>,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
        vip_level: Option<i32>,
    ) -> Result<
        ResponseValue<Vec<types::MarginCrossMarginDataResponseItem>>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/margin/crossMarginData", self.baseurl,);
        let mut query = Vec::with_capacity(5usize);
        if let Some(v) = &coin {
            query.push(("coin", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        if let Some(v) = &vip_level {
            query.push(("vipLevel", v.to_string()));
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Query Isolated Margin Fee Data (USER_DATA)

Get isolated margin fee data collection with any vip level or user's current specific data as https://www.binance.com/en/margin-fee

Weight(IP): 1 when a single is specified; 10 when the symbol parameter is omitted

Sends a `GET` request to `/sapi/v1/margin/isolatedMarginData`

Arguments:
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `symbol`: Trading symbol, e.g. BNBUSDT
- `timestamp`: UTC timestamp in ms
- `vip_level`: Defaults to user's vip level
*/
    pub async fn margin_isolated_margin_data<'a>(
        &'a self,
        recv_window: Option<i64>,
        signature: &'a str,
        symbol: Option<&'a str>,
        timestamp: i64,
        vip_level: Option<i32>,
    ) -> Result<
        ResponseValue<Vec<types::MarginIsolatedMarginDataResponseItem>>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/margin/isolatedMarginData", self.baseurl,);
        let mut query = Vec::with_capacity(5usize);
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &symbol {
            query.push(("symbol", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        if let Some(v) = &vip_level {
            query.push(("vipLevel", v.to_string()));
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Query Isolated Margin Tier Data (USER_DATA)

Get isolated margin tier data collection with any tier as https://www.binance.com/en/margin-data

Weight(IP): 1

Sends a `GET` request to `/sapi/v1/margin/isolatedMarginTier`

Arguments:
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `symbol`: Trading symbol, e.g. BNBUSDT
- `tier`: All margin tier data will be returned if tier is omitted
- `timestamp`: UTC timestamp in ms
*/
    pub async fn margin_isolated_margin_tier<'a>(
        &'a self,
        recv_window: Option<i64>,
        signature: &'a str,
        symbol: &'a str,
        tier: Option<&'a str>,
        timestamp: i64,
    ) -> Result<
        ResponseValue<Vec<types::MarginIsolatedMarginTierResponseItem>>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/margin/isolatedMarginTier", self.baseurl,);
        let mut query = Vec::with_capacity(5usize);
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("symbol", symbol.to_string()));
        if let Some(v) = &tier {
            query.push(("tier", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Query Current Margin Order Count Usage (TRADE)

Displays the user's current margin order count usage for all intervals.

Weight(IP): 20

Sends a `GET` request to `/sapi/v1/margin/rateLimit/order`

Arguments:
- `is_isolated`: * `TRUE` - For isolated margin
* `FALSE` - Default, not for isolated margin
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `symbol`: isolated symbol, mandatory for isolated margin
- `timestamp`: UTC timestamp in ms
*/
    pub async fn margin_rate_limit_order<'a>(
        &'a self,
        is_isolated: Option<&'a str>,
        recv_window: Option<i64>,
        signature: &'a str,
        symbol: Option<&'a str>,
        timestamp: i64,
    ) -> Result<
        ResponseValue<Vec<types::MarginRateLimitOrderResponseItem>>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/margin/rateLimit/order", self.baseurl,);
        let mut query = Vec::with_capacity(5usize);
        if let Some(v) = &is_isolated {
            query.push(("isIsolated", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &symbol {
            query.push(("symbol", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Margin Dustlog (USER_DATA)

Query the historical information of user margin account small-value asset conversion BNB.

Weight(IP): 1

Sends a `GET` request to `/sapi/v1/margin/dribblet`

Arguments:
- `end_time`: UTC timestamp in ms
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `start_time`: UTC timestamp in ms
- `timestamp`: UTC timestamp in ms
*/
    pub async fn margin_dribblet<'a>(
        &'a self,
        end_time: Option<i64>,
        recv_window: Option<i64>,
        signature: &'a str,
        start_time: Option<i64>,
        timestamp: i64,
    ) -> Result<ResponseValue<types::MarginDribbletResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/margin/dribblet", self.baseurl,);
        let mut query = Vec::with_capacity(5usize);
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Cross margin collateral ratio (MARKET_DATA)


Weight(IP): 100

Sends a `GET` request to `/sapi/v1/margin/crossMarginCollateralRatio`

*/
    pub async fn margin_cross_margin_collateral_ratio<'a>(
        &'a self,
    ) -> Result<
        ResponseValue<Vec<types::MarginCrossMarginCollateralRatioResponseItem>>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/margin/crossMarginCollateralRatio", self.baseurl,);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get Small Liability Exchange Coin List (USER_DATA)

Query the coins which can be small liability exchange

Weight(UID): 100

Sends a `GET` request to `/sapi/v1/margin/exchange-small-liability`

Arguments:
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn margin_exchange_small_liability<'a>(
        &'a self,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<Vec<types::MarginExchangeSmallLiabilityResponseItem>>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/margin/exchange-small-liability", self.baseurl,);
        let mut query = Vec::with_capacity(3usize);
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get Small Liability Exchange History (USER_DATA)

Get Small liability Exchange History

Weight(UID): 100

Sends a `GET` request to `/sapi/v1/margin/exchange-small-liability-history`

Arguments:
- `current`: Current querying page. Start from 1. Default:1
- `end_time`: UTC timestamp in ms
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `size`: Default:10 Max:100
- `start_time`: UTC timestamp in ms
- `timestamp`: UTC timestamp in ms
*/
    pub async fn margin_exchange_small_liability_history<'a>(
        &'a self,
        current: Option<i32>,
        end_time: Option<i64>,
        recv_window: Option<i64>,
        signature: &'a str,
        size: Option<i32>,
        start_time: Option<i64>,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::MarginExchangeSmallLiabilityHistoryResponse>,
        Error<types::Error>,
    > {
        let url = format!(
            "{}/sapi/v1/margin/exchange-small-liability-history", self.baseurl,
        );
        let mut query = Vec::with_capacity(7usize);
        if let Some(v) = &current {
            query.push(("current", v.to_string()));
        }
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &size {
            query.push(("size", v.to_string()));
        }
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get a future hourly interest rate (USER_DATA)

Get user the next hourly estimate interest

Weight(UID): 100

Sends a `GET` request to `/sapi/v1/margin/next-hourly-interest-rate`

Arguments:
- `assets`: List of assets, separated by commas, up to 20
- `is_isolated`: for isolated margin or not, "TRUE", "FALSE"
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn margin_next_hourly_interest_rate<'a>(
        &'a self,
        assets: Option<&'a str>,
        is_isolated: Option<types::MarginNextHourlyInterestRateIsIsolated>,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<Vec<types::MarginNextHourlyInterestRateResponseItem>>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/margin/next-hourly-interest-rate", self.baseurl,);
        let mut query = Vec::with_capacity(5usize);
        if let Some(v) = &assets {
            query.push(("assets", v.to_string()));
        }
        if let Some(v) = &is_isolated {
            query.push(("isIsolated", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get cross or isolated margin capital flow(USER_DATA)

Get cross or isolated margin capital flow

Weight(IP): 100

Sends a `GET` request to `/sapi/v1/margin/capital-flow`

Arguments:
- `asset`
- `end_time`: UTC timestamp in ms
- `from_id`: If fromId is set, the data with id > fromId will be returned. Otherwise the latest data will be returned
- `limit`: The number of data items returned each time is limited. Default 500; Max 1000.
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `start_time`: Only supports querying the data of the last 90 days
- `symbol`: Required when querying isolated data
- `timestamp`: UTC timestamp in ms
- `type_`
*/
    pub async fn margin_capital_flow<'a>(
        &'a self,
        asset: Option<&'a str>,
        end_time: Option<i64>,
        from_id: Option<i64>,
        limit: Option<i64>,
        recv_window: Option<i64>,
        signature: &'a str,
        start_time: Option<i64>,
        symbol: Option<&'a str>,
        timestamp: i64,
        type_: Option<types::MarginCapitalFlowType>,
    ) -> Result<
        ResponseValue<Vec<types::MarginCapitalFlowResponseItem>>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/margin/capital-flow", self.baseurl,);
        let mut query = Vec::with_capacity(10usize);
        if let Some(v) = &asset {
            query.push(("asset", v.to_string()));
        }
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        if let Some(v) = &from_id {
            query.push(("fromId", v.to_string()));
        }
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        if let Some(v) = &symbol {
            query.push(("symbol", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        if let Some(v) = &type_ {
            query.push(("type", v.to_string()));
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get tokens or symbols delist schedule for cross margin and isolated margin (MARKET_DATA)

Get tokens or symbols delist schedule for cross margin and isolated margin

Weight(IP): 100

Sends a `GET` request to `/sapi/v1/margin/delist-schedule`

Arguments:
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn margin_delist_schedule<'a>(
        &'a self,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<Vec<types::MarginDelistScheduleResponseItem>>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/margin/delist-schedule", self.baseurl,);
        let mut query = Vec::with_capacity(3usize);
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Query Margin Available Inventory (USER_DATA)

Margin available Inventory query

Weight(UID): 50

Sends a `GET` request to `/sapi/v1/margin/available-inventory`

Arguments:
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
- `type_`
*/
    pub async fn margin_available_inventory<'a>(
        &'a self,
        signature: &'a str,
        timestamp: i64,
        type_: types::MarginAvailableInventoryType,
    ) -> Result<
        ResponseValue<types::MarginAvailableInventoryResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/margin/available-inventory", self.baseurl,);
        let mut query = Vec::with_capacity(3usize);
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        query.push(("type", type_.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Margin manual liquidation(MARGIN)

Margin manual liquidation

Weight(UID): 3000

Sends a `POST` request to `/sapi/v1/margin/manual-liquidation`

Arguments:
- `signature`: Signature
- `symbol`
- `timestamp`: UTC timestamp in ms
- `type_`
*/
    pub async fn margin_manual_liquidation<'a>(
        &'a self,
        signature: &'a str,
        symbol: Option<&'a str>,
        timestamp: i64,
        type_: types::MarginManualLiquidationType,
    ) -> Result<
        ResponseValue<Vec<types::MarginManualLiquidationResponseItem>>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/margin/manual-liquidation", self.baseurl,);
        let mut query = Vec::with_capacity(4usize);
        query.push(("signature", signature.to_string()));
        if let Some(v) = &symbol {
            query.push(("symbol", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        query.push(("type", type_.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get Assets That Can Be Converted Into BNB (USER_DATA)

Get assets that can be converted into BNB.

Weight(IP): 100

Sends a `GET` request to `/sapi/v1/margin/dust`

Arguments:
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn margin_dust<'a>(
        &'a self,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<ResponseValue<types::MarginDustResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/margin/dust", self.baseurl,);
        let mut query = Vec::with_capacity(3usize);
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Dust Transfer (TRADE)

Convert dust assets to BNB

Weight(UID): 3000

Sends a `POST` request to `/sapi/v1/margin/dust`

Arguments:
- `asset`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn convert_dust_assets_to_bnb<'a>(
        &'a self,
        asset: &'a str,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::ConvertDustAssetsToBnbResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/margin/dust", self.baseurl,);
        let mut query = Vec::with_capacity(4usize);
        query.push(("asset", asset.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Adjust cross margin max leverage (USER_DATA)

Adjust cross margin max leverage

Weight(UID): 3000

Sends a `POST` request to `/sapi/v1/margin/max-leverage`

Arguments:
- `max_leverage`: Can only adjust 3 or 5
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn margin_max_leverage<'a>(
        &'a self,
        max_leverage: i64,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<ResponseValue<types::MarginMaxLeverageResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/margin/max-leverage", self.baseurl,);
        let mut query = Vec::with_capacity(4usize);
        query.push(("maxLeverage", max_leverage.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Query Liability Coin Leverage Bracket in Cross Margin Pro Mode (MARKET_DATA)

Liability Coin Leverage Bracket in Cross Margin Pro Mode

Weight(IP): 1

Sends a `GET` request to `/sapi/v1/margin/leverageBracket`

*/
    pub async fn margin_leverage_bracket<'a>(
        &'a self,
    ) -> Result<
        ResponseValue<Vec<types::MarginLeverageBracketResponseItem>>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/margin/leverageBracket", self.baseurl,);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**System Status (System)

Fetch system status.

Weight(IP): 1

Sends a `GET` request to `/sapi/v1/system/status`

*/
    pub async fn system_status<'a>(
        &'a self,
    ) -> Result<ResponseValue<types::SystemStatusResponse>, Error<()>> {
        let url = format!("{}/sapi/v1/system/status", self.baseurl,);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**All Coins' Information (USER_DATA)

Get information of coins (available for deposit and withdraw) for user.

Weight(IP): 10

Sends a `GET` request to `/sapi/v1/capital/config/getall`

Arguments:
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn capital_config_getall<'a>(
        &'a self,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<Vec<types::CapitalConfigGetallResponseItem>>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/capital/config/getall", self.baseurl,);
        let mut query = Vec::with_capacity(3usize);
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Daily Account Snapshot (USER_DATA)

- The query time period must be less than 30 days
- Support query within the last one month only
- If startTimeand endTime not sent, return records of the last 7 days by default

Weight(IP): 2400

Sends a `GET` request to `/sapi/v1/accountSnapshot`

Arguments:
- `end_time`: UTC timestamp in ms
- `limit`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `start_time`: UTC timestamp in ms
- `timestamp`: UTC timestamp in ms
- `type_`
*/
    pub async fn account_snapshot<'a>(
        &'a self,
        end_time: Option<i64>,
        limit: Option<i64>,
        recv_window: Option<i64>,
        signature: &'a str,
        start_time: Option<i64>,
        timestamp: i64,
        type_: types::AccountSnapshotType,
    ) -> Result<ResponseValue<types::AccountSnapshotResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/accountSnapshot", self.baseurl,);
        let mut query = Vec::with_capacity(7usize);
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        query.push(("type", type_.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Disable Fast Withdraw Switch (USER_DATA)

- This request will disable fastwithdraw switch under your account.
- You need to enable "trade" option for the api key which requests this endpoint.

Weight(IP): 1

Sends a `POST` request to `/sapi/v1/account/disableFastWithdrawSwitch`

Arguments:
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn account_disable_fast_withdraw_switch<'a>(
        &'a self,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<serde_json::Map<String, serde_json::Value>>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/account/disableFastWithdrawSwitch", self.baseurl,);
        let mut query = Vec::with_capacity(3usize);
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Enable Fast Withdraw Switch (USER_DATA)

- This request will enable fastwithdraw switch under your account. You need to enable "trade" option for the api key which requests this endpoint.
- When Fast Withdraw Switch is on, transferring funds to a Binance account will be done instantly. There is no on-chain transaction, no transaction ID and no withdrawal fee.

Weight(IP): 1

Sends a `POST` request to `/sapi/v1/account/enableFastWithdrawSwitch`

Arguments:
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn account_enable_fast_withdraw_switch<'a>(
        &'a self,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<serde_json::Map<String, serde_json::Value>>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/account/enableFastWithdrawSwitch", self.baseurl,);
        let mut query = Vec::with_capacity(3usize);
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Withdraw (USER_DATA)

Submit a withdraw request.

- If `network` not send, return with default network of the coin.
- You can get `network` and `isDefault` in `networkList` of a coin in the response of `Get /sapi/v1/capital/config/getall (HMAC SHA256)`.

Weight(IP): 1

Sends a `POST` request to `/sapi/v1/capital/withdraw/apply`

Arguments:
- `address`
- `address_tag`: Secondary address identifier for coins like XRP,XMR etc.
- `amount`
- `coin`: Coin name
- `name`
- `network`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
- `transaction_fee_flag`: When making internal transfer
- `true` ->  returning the fee to the destination account;
- `false` -> returning the fee back to the departure account.
- `wallet_type`: The wallet type for withdraw0-Spot wallet, 1- Funding wallet. Default is Spot wallet
- `withdraw_order_id`: Client id for withdraw
*/
    pub async fn capital_withdraw_apply<'a>(
        &'a self,
        address: &'a str,
        address_tag: Option<&'a str>,
        amount: f64,
        coin: &'a str,
        name: Option<&'a str>,
        network: Option<&'a str>,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
        transaction_fee_flag: Option<bool>,
        wallet_type: Option<i32>,
        withdraw_order_id: Option<&'a str>,
    ) -> Result<
        ResponseValue<types::CapitalWithdrawApplyResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/capital/withdraw/apply", self.baseurl,);
        let mut query = Vec::with_capacity(12usize);
        query.push(("address", address.to_string()));
        if let Some(v) = &address_tag {
            query.push(("addressTag", v.to_string()));
        }
        query.push(("amount", amount.to_string()));
        query.push(("coin", coin.to_string()));
        if let Some(v) = &name {
            query.push(("name", v.to_string()));
        }
        if let Some(v) = &network {
            query.push(("network", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        if let Some(v) = &transaction_fee_flag {
            query.push(("transactionFeeFlag", v.to_string()));
        }
        if let Some(v) = &wallet_type {
            query.push(("walletType", v.to_string()));
        }
        if let Some(v) = &withdraw_order_id {
            query.push(("withdrawOrderId", v.to_string()));
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Deposit History(supporting network) (USER_DATA)

Fetch deposit history.

- Please notice the default `startTime` and `endTime` to make sure that time interval is within 0-90 days.
- If both `startTime` and `endTime` are sent, time between `startTime` and `endTime` must be less than 90 days.

Weight(IP): 1

Sends a `GET` request to `/sapi/v1/capital/deposit/hisrec`

Arguments:
- `coin`: Coin name
- `end_time`: UTC timestamp in ms
- `limit`: Default 500; max 1000.
- `offset`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `start_time`: UTC timestamp in ms
- `status`: * `0` - pending
* `6` - credited but cannot withdraw
* `1` - success
- `timestamp`: UTC timestamp in ms
*/
    pub async fn capital_deposit_hisrec<'a>(
        &'a self,
        coin: Option<&'a str>,
        end_time: Option<i64>,
        limit: Option<i32>,
        offset: Option<i32>,
        recv_window: Option<i64>,
        signature: &'a str,
        start_time: Option<i64>,
        status: Option<i32>,
        timestamp: i64,
    ) -> Result<
        ResponseValue<Vec<types::CapitalDepositHisrecResponseItem>>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/capital/deposit/hisrec", self.baseurl,);
        let mut query = Vec::with_capacity(9usize);
        if let Some(v) = &coin {
            query.push(("coin", v.to_string()));
        }
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }
        if let Some(v) = &offset {
            query.push(("offset", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        if let Some(v) = &status {
            query.push(("status", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Withdraw History (supporting network) (USER_DATA)

Fetch withdraw history.

This endpoint specifically uses per second UID rate limit, user's total second level IP rate limit is 180000/second. Response from the endpoint contains header key X-SAPI-USED-UID-WEIGHT-1S, which defines weight used by the current IP.

- `network` may not be in the response for old withdraw.
- Please notice the default `startTime` and `endTime` to make sure that time interval is within 0-90 days.
- If both `startTime` and `endTime` are sent, time between `startTime` and `endTime` must be less than 90 days
- If withdrawOrderId is sent, time between startTime and endTime must be less than 7 days.
- If withdrawOrderId is sent, startTime and endTime are not sent, will return last 7 days records by default.

Weight(UID): 18000
Request Limit: 10 requests per second

Sends a `GET` request to `/sapi/v1/capital/withdraw/history`

Arguments:
- `coin`: Coin name
- `end_time`: UTC timestamp in ms
- `limit`: Default 500; max 1000.
- `offset`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `start_time`: UTC timestamp in ms
- `status`: * `0` - Email Sent
* `1` - Cancelled
* `2` - Awaiting Approval
* `3` - Rejected
* `4` - Processing
* `5` - Failure
* `6` - Completed
- `timestamp`: UTC timestamp in ms
- `withdraw_order_id`
*/
    pub async fn capital_withdraw_history<'a>(
        &'a self,
        coin: Option<&'a str>,
        end_time: Option<i64>,
        limit: Option<i32>,
        offset: Option<i32>,
        recv_window: Option<i64>,
        signature: &'a str,
        start_time: Option<i64>,
        status: Option<i64>,
        timestamp: i64,
        withdraw_order_id: Option<&'a str>,
    ) -> Result<
        ResponseValue<Vec<types::CapitalWithdrawHistoryResponseItem>>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/capital/withdraw/history", self.baseurl,);
        let mut query = Vec::with_capacity(10usize);
        if let Some(v) = &coin {
            query.push(("coin", v.to_string()));
        }
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }
        if let Some(v) = &offset {
            query.push(("offset", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        if let Some(v) = &status {
            query.push(("status", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        if let Some(v) = &withdraw_order_id {
            query.push(("withdrawOrderId", v.to_string()));
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Deposit Address (supporting network) (USER_DATA)

Fetch deposit address with network.

- If network is not send, return with default network of the coin.
- You can get network and isDefault in networkList in the response of Get /sapi/v1/capital/config/getall (HMAC SHA256).

Weight(IP): 10

Sends a `GET` request to `/sapi/v1/capital/deposit/address`

Arguments:
- `coin`: Coin name
- `network`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn capital_deposit_address<'a>(
        &'a self,
        coin: &'a str,
        network: Option<&'a str>,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::CapitalDepositAddressResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/capital/deposit/address", self.baseurl,);
        let mut query = Vec::with_capacity(5usize);
        query.push(("coin", coin.to_string()));
        if let Some(v) = &network {
            query.push(("network", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Account Status (USER_DATA)

Fetch account status detail.

Weight(IP): 1

Sends a `GET` request to `/sapi/v1/account/status`

Arguments:
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn account_status<'a>(
        &'a self,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<ResponseValue<types::AccountStatusResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/account/status", self.baseurl,);
        let mut query = Vec::with_capacity(3usize);
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Account API Trading Status (USER_DATA)

Fetch account API trading status with details.

Weight(IP): 1

Sends a `GET` request to `/sapi/v1/account/apiTradingStatus`

Arguments:
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn account_api_trading_status<'a>(
        &'a self,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::AccountApiTradingStatusResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/account/apiTradingStatus", self.baseurl,);
        let mut query = Vec::with_capacity(3usize);
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**DustLog(USER_DATA)

Weight(IP): 1

Sends a `GET` request to `/sapi/v1/asset/dribblet`

Arguments:
- `end_time`: UTC timestamp in ms
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `start_time`: UTC timestamp in ms
- `timestamp`: UTC timestamp in ms
*/
    pub async fn asset_dribblet<'a>(
        &'a self,
        end_time: Option<i64>,
        recv_window: Option<i64>,
        signature: &'a str,
        start_time: Option<i64>,
        timestamp: i64,
    ) -> Result<ResponseValue<types::AssetDribbletResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/asset/dribblet", self.baseurl,);
        let mut query = Vec::with_capacity(5usize);
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get Assets That Can Be Converted Into BNB (USER_DATA)

Weight(IP): 1

Sends a `POST` request to `/sapi/v1/asset/dust-btc`

Arguments:
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn asset_dust_btc<'a>(
        &'a self,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<ResponseValue<types::AssetDustBtcResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/asset/dust-btc", self.baseurl,);
        let mut query = Vec::with_capacity(3usize);
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Asset Dividend Record (USER_DATA)

Query asset Dividend Record

Weight(IP): 10

Sends a `GET` request to `/sapi/v1/asset/assetDividend`

Arguments:
- `asset`
- `end_time`: UTC timestamp in ms
- `limit`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `start_time`: UTC timestamp in ms
- `timestamp`: UTC timestamp in ms
*/
    pub async fn asset_asset_dividend<'a>(
        &'a self,
        asset: Option<&'a str>,
        end_time: Option<i64>,
        limit: Option<i64>,
        recv_window: Option<i64>,
        signature: &'a str,
        start_time: Option<i64>,
        timestamp: i64,
    ) -> Result<ResponseValue<types::AssetAssetDividendResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/asset/assetDividend", self.baseurl,);
        let mut query = Vec::with_capacity(7usize);
        if let Some(v) = &asset {
            query.push(("asset", v.to_string()));
        }
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Asset Detail (USER_DATA)

Fetch details of assets supported on Binance.

- Please get network and other deposit or withdraw details from `GET /sapi/v1/capital/config/getall`.

Weight(IP): 1

Sends a `GET` request to `/sapi/v1/asset/assetDetail`

Arguments:
- `asset`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn asset_asset_detail<'a>(
        &'a self,
        asset: Option<&'a str>,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<ResponseValue<types::AssetAssetDetailResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/asset/assetDetail", self.baseurl,);
        let mut query = Vec::with_capacity(4usize);
        if let Some(v) = &asset {
            query.push(("asset", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Trade Fee (USER_DATA)

Fetch trade fee

Weight(IP): 1

Sends a `GET` request to `/sapi/v1/asset/tradeFee`

Arguments:
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `symbol`: Trading symbol, e.g. BNBUSDT
- `timestamp`: UTC timestamp in ms
*/
    pub async fn asset_trade_fee<'a>(
        &'a self,
        recv_window: Option<i64>,
        signature: &'a str,
        symbol: Option<&'a str>,
        timestamp: i64,
    ) -> Result<
        ResponseValue<Vec<types::AssetTradeFeeResponseItem>>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/asset/tradeFee", self.baseurl,);
        let mut query = Vec::with_capacity(4usize);
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &symbol {
            query.push(("symbol", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Query User Universal Transfer History (USER_DATA)

- `fromSymbol` must be sent when type are ISOLATEDMARGIN_MARGIN and ISOLATEDMARGIN_ISOLATEDMARGIN
- `toSymbol` must be sent when type are MARGIN_ISOLATEDMARGIN and ISOLATEDMARGIN_ISOLATEDMARGIN
- Support query within the last 6 months only
- If `startTime` and `endTime` not sent, return records of the last 7 days by default

Weight(IP): 1

Sends a `GET` request to `/sapi/v1/asset/transfer`

Arguments:
- `current`: Current querying page. Start from 1. Default:1
- `end_time`: UTC timestamp in ms
- `from_symbol`: Must be sent when type are ISOLATEDMARGIN_MARGIN and ISOLATEDMARGIN_ISOLATEDMARGIN
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `size`: Default:10 Max:100
- `start_time`: UTC timestamp in ms
- `timestamp`: UTC timestamp in ms
- `to_symbol`: Must be sent when type are MARGIN_ISOLATEDMARGIN and ISOLATEDMARGIN_ISOLATEDMARGIN
- `type_`: Universal transfer type
*/
    pub async fn asset_transfer<'a>(
        &'a self,
        current: Option<i32>,
        end_time: Option<i64>,
        from_symbol: Option<&'a str>,
        recv_window: Option<i64>,
        signature: &'a str,
        size: Option<i32>,
        start_time: Option<i64>,
        timestamp: i64,
        to_symbol: Option<&'a str>,
        type_: types::AssetTransferType,
    ) -> Result<ResponseValue<types::AssetTransferResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/asset/transfer", self.baseurl,);
        let mut query = Vec::with_capacity(10usize);
        if let Some(v) = &current {
            query.push(("current", v.to_string()));
        }
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        if let Some(v) = &from_symbol {
            query.push(("fromSymbol", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &size {
            query.push(("size", v.to_string()));
        }
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        if let Some(v) = &to_symbol {
            query.push(("toSymbol", v.to_string()));
        }
        query.push(("type", type_.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**User Universal Transfer (USER_DATA)

You need to enable `Permits Universal Transfer` option for the api key which requests this endpoint.

- `fromSymbol` must be sent when type are ISOLATEDMARGIN_MARGIN and ISOLATEDMARGIN_ISOLATEDMARGIN
- `toSymbol` must be sent when type are MARGIN_ISOLATEDMARGIN and ISOLATEDMARGIN_ISOLATEDMARGIN

ENUM of transfer types:
  - MAIN_UMFUTURE Spot account transfer to USD-M Futures account
  - MAIN_CMFUTURE Spot account transfer to COIN-M Futures account
  - MAIN_MARGIN Spot account transfer to Margin(cross)account
  - UMFUTURE_MAIN USD-M Futures account transfer to Spot account
  - UMFUTURE_MARGIN USD-M Futures account transfer to Margin(cross)account
  - CMFUTURE_MAIN COIN-M Futures account transfer to Spot account
  - CMFUTURE_MARGIN COIN-M Futures account transfer to Margin(cross) account
  - MARGIN_MAIN Margin(cross)account transfer to Spot account
  - MARGIN_UMFUTURE Margin(cross)account transfer to USD-M Futures
  - MARGIN_CMFUTURE Margin(cross)account transfer to COIN-M Futures
  - ISOLATEDMARGIN_MARGIN Isolated margin account transfer to Margin(cross) account
  - MARGIN_ISOLATEDMARGIN Margin(cross) account transfer to Isolated margin account
  - ISOLATEDMARGIN_ISOLATEDMARGIN Isolated margin account transfer to Isolated margin account
  - MAIN_FUNDING Spot account transfer to Funding account
  - FUNDING_MAIN Funding account transfer to Spot account
  - FUNDING_UMFUTURE Funding account transfer to UMFUTURE account
  - UMFUTURE_FUNDING UMFUTURE account transfer to Funding account
  - MARGIN_FUNDING MARGIN account transfer to Funding account
  - FUNDING_MARGIN Funding account transfer to Margin account
  - FUNDING_CMFUTURE Funding account transfer to CMFUTURE account
  - CMFUTURE_FUNDING CMFUTURE account transfer to Funding account
  - MAIN_OPTION Spot account transfer to Options account
  - OPTION_MAIN Options account transfer to Spot account
  - UMFUTURE_OPTION USD-M Futures account transfer to Options account
  - OPTION_UMFUTURE Options account transfer to USD-M Futures account
  - MARGIN_OPTION Margin(cross)account transfer to Options account
  - OPTION_MARGIN Options account transfer to Margin(cross)account
  - FUNDING_OPTION Funding account transfer to Options account
  - OPTION_FUNDING Options account transfer to Funding account
  - MAIN_PORTFOLIO_MARGIN Spot account transfer to Portfolio Margin account
  - PORTFOLIO_MARGIN_MAIN Portfolio Margin account transfer to Spot account
  - MAIN_ISOLATED_MARGIN Spot account transfer to Isolated margin account
  - ISOLATED_MARGIN_MAIN Isolated margin account transfer to Spot account

Weight(IP): 1

Sends a `POST` request to `/sapi/v1/asset/transfer`

Arguments:
- `amount`
- `asset`
- `from_symbol`: Must be sent when type are ISOLATEDMARGIN_MARGIN and ISOLATEDMARGIN_ISOLATEDMARGIN
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
- `to_symbol`: Must be sent when type are MARGIN_ISOLATEDMARGIN and ISOLATEDMARGIN_ISOLATEDMARGIN
- `type_`: Universal transfer type
*/
    pub async fn post_user_universal_transfer<'a>(
        &'a self,
        amount: f64,
        asset: &'a str,
        from_symbol: Option<&'a str>,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
        to_symbol: Option<&'a str>,
        type_: types::PostUserUniversalTransferType,
    ) -> Result<
        ResponseValue<types::PostUserUniversalTransferResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/asset/transfer", self.baseurl,);
        let mut query = Vec::with_capacity(8usize);
        query.push(("amount", amount.to_string()));
        query.push(("asset", asset.to_string()));
        if let Some(v) = &from_symbol {
            query.push(("fromSymbol", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        if let Some(v) = &to_symbol {
            query.push(("toSymbol", v.to_string()));
        }
        query.push(("type", type_.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Funding Wallet (USER_DATA)

- Currently supports querying the following business assetsBinance Pay, Binance Card, Binance Gift Card, Stock Token

Weight(IP): 1

Sends a `POST` request to `/sapi/v1/asset/get-funding-asset`

Arguments:
- `asset`
- `need_btc_valuation`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn asset_get_funding_asset<'a>(
        &'a self,
        asset: Option<&'a str>,
        need_btc_valuation: Option<types::AssetGetFundingAssetNeedBtcValuation>,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<Vec<types::AssetGetFundingAssetResponseItem>>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/asset/get-funding-asset", self.baseurl,);
        let mut query = Vec::with_capacity(5usize);
        if let Some(v) = &asset {
            query.push(("asset", v.to_string()));
        }
        if let Some(v) = &need_btc_valuation {
            query.push(("needBtcValuation", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**User Asset (USER_DATA)

Get user assets, just for positive data.

Weight(IP): 5

Sends a `POST` request to `/sapi/v3/asset/getUserAsset`

Arguments:
- `asset`
- `need_btc_valuation`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn asset_get_user_asset<'a>(
        &'a self,
        asset: Option<&'a str>,
        need_btc_valuation: Option<types::AssetGetUserAssetNeedBtcValuation>,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<Vec<types::AssetGetUserAssetResponseItem>>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v3/asset/getUserAsset", self.baseurl,);
        let mut query = Vec::with_capacity(5usize);
        if let Some(v) = &asset {
            query.push(("asset", v.to_string()));
        }
        if let Some(v) = &need_btc_valuation {
            query.push(("needBtcValuation", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Convert Transfer (USER_DATA)

Convert transfer, convert between BUSD and stablecoins.
If the clientId has been used before, will not do the convert transfer, the original transfer will be returned.

Weight(UID): 5

Sends a `POST` request to `/sapi/v1/asset/convert-transfer`

Arguments:
- `amount`
- `asset`
- `client_tran_id`: The unique flag, the min length is 20
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `target_asset`: Target asset you want to convert
- `timestamp`: UTC timestamp in ms
*/
    pub async fn asset_convert_transfer<'a>(
        &'a self,
        amount: f64,
        asset: &'a str,
        client_tran_id: &'a str,
        recv_window: Option<i64>,
        signature: &'a str,
        target_asset: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::AssetConvertTransferResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/asset/convert-transfer", self.baseurl,);
        let mut query = Vec::with_capacity(7usize);
        query.push(("amount", amount.to_string()));
        query.push(("asset", asset.to_string()));
        query.push(("clientTranId", client_tran_id.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("targetAsset", target_asset.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Query Convert Transfer (USER_DATA)

Weight(UID): 5

Sends a `GET` request to `/sapi/v1/asset/convert-transfer/queryByPage`

Arguments:
- `account_type`: MAIN: main account. CARD: funding account. If it is blank, we will query spot and card wallet, otherwise, we just query the corresponding wallet
- `asset`: If it is blank, we will match deducted asset and target asset.
- `current`: Current querying page. Start from 1. Default:1
- `end_time`: UTC timestamp in ms
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `size`: Default:10 Max:100
- `start_time`: UTC timestamp in ms
- `timestamp`: UTC timestamp in ms
- `tran_id`: The transaction id
*/
    pub async fn asset_convert_transfer_query_by_page<'a>(
        &'a self,
        account_type: Option<types::AssetConvertTransferQueryByPageAccountType>,
        asset: Option<&'a str>,
        current: Option<i32>,
        end_time: i64,
        recv_window: Option<i64>,
        signature: &'a str,
        size: Option<i32>,
        start_time: i64,
        timestamp: i64,
        tran_id: Option<i64>,
    ) -> Result<
        ResponseValue<types::AssetConvertTransferQueryByPageResponse>,
        Error<types::Error>,
    > {
        let url = format!(
            "{}/sapi/v1/asset/convert-transfer/queryByPage", self.baseurl,
        );
        let mut query = Vec::with_capacity(10usize);
        if let Some(v) = &account_type {
            query.push(("accountType", v.to_string()));
        }
        if let Some(v) = &asset {
            query.push(("asset", v.to_string()));
        }
        if let Some(v) = &current {
            query.push(("current", v.to_string()));
        }
        query.push(("endTime", end_time.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &size {
            query.push(("size", v.to_string()));
        }
        query.push(("startTime", start_time.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        if let Some(v) = &tran_id {
            query.push(("tranId", v.to_string()));
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get Cloud-Mining payment and refund history (USER_DATA)

The query of Cloud-Mining payment and refund history

Weight(UID): 600

Sends a `GET` request to `/sapi/v1/asset/ledger-transfer/cloud-mining/queryByPage`

Arguments:
- `asset`: If it is blank, we will query all assets
- `client_tran_id`: The unique flag
- `current`: Current querying page. Start from 1. Default:1
- `end_time`: UTC timestamp in ms
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `size`: Default:10 Max:100
- `start_time`: UTC timestamp in ms
- `timestamp`: UTC timestamp in ms
- `tran_id`: The transaction id
*/
    pub async fn asset_ledger_transfer_cloud_mining_query_by_page<'a>(
        &'a self,
        asset: Option<&'a str>,
        client_tran_id: Option<&'a str>,
        current: Option<i32>,
        end_time: i64,
        recv_window: Option<i64>,
        signature: &'a str,
        size: Option<i32>,
        start_time: i64,
        timestamp: i64,
        tran_id: Option<i64>,
    ) -> Result<
        ResponseValue<types::AssetLedgerTransferCloudMiningQueryByPageResponse>,
        Error<types::Error>,
    > {
        let url = format!(
            "{}/sapi/v1/asset/ledger-transfer/cloud-mining/queryByPage", self.baseurl,
        );
        let mut query = Vec::with_capacity(10usize);
        if let Some(v) = &asset {
            query.push(("asset", v.to_string()));
        }
        if let Some(v) = &client_tran_id {
            query.push(("clientTranId", v.to_string()));
        }
        if let Some(v) = &current {
            query.push(("current", v.to_string()));
        }
        query.push(("endTime", end_time.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &size {
            query.push(("size", v.to_string()));
        }
        query.push(("startTime", start_time.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        if let Some(v) = &tran_id {
            query.push(("tranId", v.to_string()));
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get API Key Permission (USER_DATA)

Weight(IP): 1

Sends a `GET` request to `/sapi/v1/account/apiRestrictions`

Arguments:
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn account_api_restrictions<'a>(
        &'a self,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::AccountApiRestrictionsResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/account/apiRestrictions", self.baseurl,);
        let mut query = Vec::with_capacity(3usize);
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Query auto-converting stable coins (USER_DATA)

Get a user's auto-conversion settings in deposit/withdrawal

Weight(UID): 600'

Sends a `GET` request to `/sapi/v1/capital/contract/convertible-coins`

*/
    pub async fn capital_contract_convertible_coins<'a>(
        &'a self,
    ) -> Result<
        ResponseValue<types::CapitalContractConvertibleCoinsResponse>,
        Error<types::Error>,
    > {
        let url = format!(
            "{}/sapi/v1/capital/contract/convertible-coins", self.baseurl,
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Switch on/off BUSD and stable coins conversion (USER_DATA) (USER_DATA)

User can use it to turn on or turn off the BUSD auto-conversion from/to a specific stable coin.

Weight(UID): 600'

Sends a `POST` request to `/sapi/v1/capital/contract/convertible-coins`

Arguments:
- `coin`: Must be USDC, USDP or TUSD
- `enable`: true: turn on the auto-conversion. false: turn off the auto-conversion
*/
    pub async fn toggle_stable_coin_conversion<'a>(
        &'a self,
        coin: &'a str,
        enable: bool,
    ) -> Result<
        ResponseValue<serde_json::Map<String, serde_json::Value>>,
        Error<types::Error>,
    > {
        let url = format!(
            "{}/sapi/v1/capital/contract/convertible-coins", self.baseurl,
        );
        let mut query = Vec::with_capacity(2usize);
        query.push(("coin", coin.to_string()));
        query.push(("enable", enable.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Create a Virtual Sub-account(For Master Account)

- This request will generate a virtual sub account under your master account.
- You need to enable "trade" option for the api key which requests this endpoint.

Weight(IP): 1

Sends a `POST` request to `/sapi/v1/sub-account/virtualSubAccount`

Arguments:
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `sub_account_string`: Please input a string. We will create a virtual email using that string for you to register
- `timestamp`: UTC timestamp in ms
*/
    pub async fn sub_account_virtual_sub_account<'a>(
        &'a self,
        recv_window: Option<i64>,
        signature: &'a str,
        sub_account_string: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::SubAccountVirtualSubAccountResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/sub-account/virtualSubAccount", self.baseurl,);
        let mut query = Vec::with_capacity(4usize);
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("subAccountString", sub_account_string.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Query Sub-account List (For Master Account)

Weight(IP): 1

Sends a `GET` request to `/sapi/v1/sub-account/list`

Arguments:
- `email`: Sub-account email
- `is_freeze`
- `limit`: Default 1; max 200
- `page`: Default 1
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn sub_account_list<'a>(
        &'a self,
        email: Option<&'a str>,
        is_freeze: Option<types::SubAccountListIsFreeze>,
        limit: Option<i32>,
        page: Option<i32>,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<ResponseValue<types::SubAccountListResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/sub-account/list", self.baseurl,);
        let mut query = Vec::with_capacity(7usize);
        if let Some(v) = &email {
            query.push(("email", v.to_string()));
        }
        if let Some(v) = &is_freeze {
            query.push(("isFreeze", v.to_string()));
        }
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }
        if let Some(v) = &page {
            query.push(("page", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Sub-account Spot Asset Transfer History (For Master Account)

- fromEmail and toEmail cannot be sent at the same time.
- Return fromEmail equal master account email by default.

Weight(IP): 1

Sends a `GET` request to `/sapi/v1/sub-account/sub/transfer/history`

Arguments:
- `end_time`: UTC timestamp in ms
- `from_email`: Sub-account email
- `limit`: Default 1
- `page`: Default 1
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `start_time`: UTC timestamp in ms
- `timestamp`: UTC timestamp in ms
- `to_email`: Sub-account email
*/
    pub async fn sub_account_sub_transfer_history<'a>(
        &'a self,
        end_time: Option<i64>,
        from_email: Option<&'a str>,
        limit: Option<i32>,
        page: Option<i32>,
        recv_window: Option<i64>,
        signature: &'a str,
        start_time: Option<i64>,
        timestamp: i64,
        to_email: Option<&'a str>,
    ) -> Result<
        ResponseValue<Vec<types::SubAccountSubTransferHistoryResponseItem>>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/sub-account/sub/transfer/history", self.baseurl,);
        let mut query = Vec::with_capacity(9usize);
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        if let Some(v) = &from_email {
            query.push(("fromEmail", v.to_string()));
        }
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }
        if let Some(v) = &page {
            query.push(("page", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        if let Some(v) = &to_email {
            query.push(("toEmail", v.to_string()));
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Sub-account Futures Asset Transfer History (For Master Account)

Weight(IP): 1

Sends a `GET` request to `/sapi/v1/sub-account/futures/internalTransfer`

Arguments:
- `email`: Sub-account email
- `end_time`: UTC timestamp in ms
- `futures_type`: 1:USDT-margined Futures, 2: Coin-margined Futures
- `limit`: Default value: 50, Max value: 500
- `page`: Default 1
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `start_time`: UTC timestamp in ms
- `timestamp`: UTC timestamp in ms
*/
    pub async fn sub_account_futures_internal_transfer<'a>(
        &'a self,
        email: &'a str,
        end_time: Option<i64>,
        futures_type: i32,
        limit: Option<i32>,
        page: Option<i32>,
        recv_window: Option<i64>,
        signature: &'a str,
        start_time: Option<i64>,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::SubAccountFuturesInternalTransferResponse>,
        Error<types::Error>,
    > {
        let url = format!(
            "{}/sapi/v1/sub-account/futures/internalTransfer", self.baseurl,
        );
        let mut query = Vec::with_capacity(9usize);
        query.push(("email", email.to_string()));
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        query.push(("futuresType", futures_type.to_string()));
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }
        if let Some(v) = &page {
            query.push(("page", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Sub-account Futures Asset Transfer (For Master Account)

- Master account can transfer max 2000 times a minute

Weight(IP): 1

Sends a `POST` request to `/sapi/v1/sub-account/futures/internalTransfer`

Arguments:
- `amount`
- `asset`
- `from_email`: Sender email
- `futures_type`: 1:USDT-margined Futures,2: Coin-margined Futures
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
- `to_email`: Recipient email
*/
    pub async fn post_sub_account_future_asset_transfer<'a>(
        &'a self,
        amount: f64,
        asset: &'a str,
        from_email: &'a str,
        futures_type: i32,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
        to_email: &'a str,
    ) -> Result<
        ResponseValue<types::PostSubAccountFutureAssetTransferResponse>,
        Error<types::Error>,
    > {
        let url = format!(
            "{}/sapi/v1/sub-account/futures/internalTransfer", self.baseurl,
        );
        let mut query = Vec::with_capacity(8usize);
        query.push(("amount", amount.to_string()));
        query.push(("asset", asset.to_string()));
        query.push(("fromEmail", from_email.to_string()));
        query.push(("futuresType", futures_type.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        query.push(("toEmail", to_email.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Sub-account Assets (For Master Account)

Fetch sub-account assets

Weight(IP): 1

Sends a `GET` request to `/sapi/v3/sub-account/assets`

Arguments:
- `email`: Sub-account email
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn set_sub_account_assets<'a>(
        &'a self,
        email: &'a str,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<ResponseValue<types::SetSubAccountAssetsResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v3/sub-account/assets", self.baseurl,);
        let mut query = Vec::with_capacity(4usize);
        query.push(("email", email.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Sub-account Spot Assets Summary (For Master Account)

Get BTC valued asset summary of subaccounts.

Weight(IP): 1

Sends a `GET` request to `/sapi/v1/sub-account/spotSummary`

Arguments:
- `email`: Sub-account email
- `page`: Default 1
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `size`: Default:10 Max:20
- `timestamp`: UTC timestamp in ms
*/
    pub async fn sub_account_spot_summary<'a>(
        &'a self,
        email: Option<&'a str>,
        page: Option<i32>,
        recv_window: Option<i64>,
        signature: &'a str,
        size: Option<i32>,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::SubAccountSpotSummaryResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/sub-account/spotSummary", self.baseurl,);
        let mut query = Vec::with_capacity(6usize);
        if let Some(v) = &email {
            query.push(("email", v.to_string()));
        }
        if let Some(v) = &page {
            query.push(("page", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &size {
            query.push(("size", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Sub-account Spot Assets Summary (For Master Account)

Fetch sub-account deposit address

Weight(IP): 1

Sends a `GET` request to `/sapi/v1/capital/deposit/subAddress`

Arguments:
- `coin`: Coin name
- `email`: Sub-account email
- `network`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn capital_deposit_sub_address<'a>(
        &'a self,
        coin: &'a str,
        email: &'a str,
        network: Option<&'a str>,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::CapitalDepositSubAddressResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/capital/deposit/subAddress", self.baseurl,);
        let mut query = Vec::with_capacity(6usize);
        query.push(("coin", coin.to_string()));
        query.push(("email", email.to_string()));
        if let Some(v) = &network {
            query.push(("network", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Sub-account Deposit History (For Master Account)

Fetch sub-account deposit history

Weight(IP): 1

Sends a `GET` request to `/sapi/v1/capital/deposit/subHisrec`

Arguments:
- `coin`: Coin name
- `email`: Sub-account email
- `end_time`: UTC timestamp in ms
- `limit`
- `offset`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `start_time`: UTC timestamp in ms
- `status`: 0(0:pending,6: credited but cannot withdraw, 1:success)
- `timestamp`: UTC timestamp in ms
*/
    pub async fn capital_deposit_sub_hisrec<'a>(
        &'a self,
        coin: Option<&'a str>,
        email: &'a str,
        end_time: Option<i64>,
        limit: Option<i64>,
        offset: Option<i32>,
        recv_window: Option<i64>,
        signature: &'a str,
        start_time: Option<i64>,
        status: Option<i32>,
        timestamp: i64,
    ) -> Result<
        ResponseValue<Vec<types::CapitalDepositSubHisrecResponseItem>>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/capital/deposit/subHisrec", self.baseurl,);
        let mut query = Vec::with_capacity(10usize);
        if let Some(v) = &coin {
            query.push(("coin", v.to_string()));
        }
        query.push(("email", email.to_string()));
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }
        if let Some(v) = &offset {
            query.push(("offset", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        if let Some(v) = &status {
            query.push(("status", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**One click arrival deposit apply (USER_DATA)

Apply deposit credit for expired address (One click arrival)

Weight(IP): 1

Sends a `POST` request to `/sapi/v1/capital/deposit/credit-apply`

Arguments:
- `deposit_id`: Deposit record Id, priority use
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `sub_account_id`
- `sub_user_id`
- `timestamp`: UTC timestamp in ms
- `tx_id`: Deposit txId, used when depositId is not specified
*/
    pub async fn capital_deposit_credit_apply<'a>(
        &'a self,
        deposit_id: Option<i64>,
        recv_window: Option<i64>,
        signature: &'a str,
        sub_account_id: Option<i64>,
        sub_user_id: Option<i64>,
        timestamp: i64,
        tx_id: Option<&'a str>,
    ) -> Result<
        ResponseValue<types::CapitalDepositCreditApplyResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/capital/deposit/credit-apply", self.baseurl,);
        let mut query = Vec::with_capacity(7usize);
        if let Some(v) = &deposit_id {
            query.push(("depositId", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &sub_account_id {
            query.push(("subAccountId", v.to_string()));
        }
        if let Some(v) = &sub_user_id {
            query.push(("subUserId", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        if let Some(v) = &tx_id {
            query.push(("txId", v.to_string()));
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Query User Wallet Balance (USER_DATA)

Query User Wallet Balance

Weight(IP): 60

Sends a `GET` request to `/sapi/v1/asset/wallet/balance`

Arguments:
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn asset_wallet_balance<'a>(
        &'a self,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<Vec<types::AssetWalletBalanceResponseItem>>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/asset/wallet/balance", self.baseurl,);
        let mut query = Vec::with_capacity(3usize);
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Query User Delegation History(For Master Account) (USER_DATA)

Query User Delegation History

Weight(IP): 60

Sends a `GET` request to `/sapi/v1/asset/custody/transfer-history`

Arguments:
- `asset`
- `current`: Current querying page. Start from 1. Default:1
- `email`
- `end_time`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `size`: Default:10 Max:100
- `start_time`
- `timestamp`: UTC timestamp in ms
- `type_`
*/
    pub async fn asset_custody_transfer_history<'a>(
        &'a self,
        asset: &'a str,
        current: Option<i32>,
        email: &'a str,
        end_time: i64,
        recv_window: Option<i64>,
        signature: &'a str,
        size: Option<i32>,
        start_time: i64,
        timestamp: i64,
        type_: Option<&'a str>,
    ) -> Result<
        ResponseValue<types::AssetCustodyTransferHistoryResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/asset/custody/transfer-history", self.baseurl,);
        let mut query = Vec::with_capacity(10usize);
        query.push(("asset", asset.to_string()));
        if let Some(v) = &current {
            query.push(("current", v.to_string()));
        }
        query.push(("email", email.to_string()));
        query.push(("endTime", end_time.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &size {
            query.push(("size", v.to_string()));
        }
        query.push(("startTime", start_time.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        if let Some(v) = &type_ {
            query.push(("type", v.to_string()));
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Fetch deposit address list with network (USER_DATA)

Fetch deposit address list with network.

Weight(IP): 10

Sends a `GET` request to `/sapi/v1/capital/deposit/address/list`

Arguments:
- `coin`
- `network`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn capital_deposit_address_list<'a>(
        &'a self,
        coin: &'a str,
        network: Option<&'a str>,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<Vec<types::CapitalDepositAddressListResponseItem>>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/capital/deposit/address/list", self.baseurl,);
        let mut query = Vec::with_capacity(5usize);
        query.push(("coin", coin.to_string()));
        if let Some(v) = &network {
            query.push(("network", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Sub-account's Status on Margin/Futures (For Master Account)

- If no `email` sent, all sub-accounts' information will be returned.

Weight(IP): 10

Sends a `GET` request to `/sapi/v1/sub-account/status`

Arguments:
- `email`: Sub-account email
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn sub_account_status<'a>(
        &'a self,
        email: Option<&'a str>,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<Vec<types::SubAccountStatusResponseItem>>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/sub-account/status", self.baseurl,);
        let mut query = Vec::with_capacity(4usize);
        if let Some(v) = &email {
            query.push(("email", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Enable Margin for Sub-account (For Master Account)

Weight(IP): 1

Sends a `POST` request to `/sapi/v1/sub-account/margin/enable`

Arguments:
- `email`: Sub-account email
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn sub_account_margin_enable<'a>(
        &'a self,
        email: &'a str,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::SubAccountMarginEnableResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/sub-account/margin/enable", self.baseurl,);
        let mut query = Vec::with_capacity(4usize);
        query.push(("email", email.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Detail on Sub-account's Margin Account (For Master Account)

Weight(IP): 10

Sends a `GET` request to `/sapi/v1/sub-account/margin/account`

Arguments:
- `email`: Sub-account email
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn sub_account_margin_account<'a>(
        &'a self,
        email: &'a str,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::SubAccountMarginAccountResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/sub-account/margin/account", self.baseurl,);
        let mut query = Vec::with_capacity(4usize);
        query.push(("email", email.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Summary of Sub-account's Margin Account (For Master Account)

Weight(IP): 10

Sends a `GET` request to `/sapi/v1/sub-account/margin/accountSummary`

Arguments:
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn sub_account_margin_account_summary<'a>(
        &'a self,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::SubAccountMarginAccountSummaryResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/sub-account/margin/accountSummary", self.baseurl,);
        let mut query = Vec::with_capacity(3usize);
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Enable Futures for Sub-account (For Master Account)

Weight(IP): 1

Sends a `POST` request to `/sapi/v1/sub-account/futures/enable`

Arguments:
- `email`: Sub-account email
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn sub_account_futures_enable<'a>(
        &'a self,
        email: &'a str,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::SubAccountFuturesEnableResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/sub-account/futures/enable", self.baseurl,);
        let mut query = Vec::with_capacity(4usize);
        query.push(("email", email.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Detail on Sub-account's Futures Account (For Master Account)

Weight(IP): 10

Sends a `GET` request to `/sapi/v1/sub-account/futures/account`

Arguments:
- `email`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn query_sub_account_futures_account_v1<'a>(
        &'a self,
        email: &'a str,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::QuerySubAccountFuturesAccountV1Response>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/sub-account/futures/account", self.baseurl,);
        let mut query = Vec::with_capacity(4usize);
        query.push(("email", email.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Summary of Sub-account's Futures Account (For Master Account)

Weight(IP): 1

Sends a `GET` request to `/sapi/v1/sub-account/futures/accountSummary`

Arguments:
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn sub_account_futures_account_summary<'a>(
        &'a self,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::SubAccountFuturesAccountSummaryResponse>,
        Error<types::Error>,
    > {
        let url = format!(
            "{}/sapi/v1/sub-account/futures/accountSummary", self.baseurl,
        );
        let mut query = Vec::with_capacity(3usize);
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Futures Position-Risk of Sub-account (For Master Account)

Weight(IP): 10

Sends a `GET` request to `/sapi/v1/sub-account/futures/positionRisk`

Arguments:
- `email`: Sub-account email
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn sub_account_futures_position_risk<'a>(
        &'a self,
        email: &'a str,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<Vec<types::SubAccountFuturesPositionRiskResponseItem>>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/sub-account/futures/positionRisk", self.baseurl,);
        let mut query = Vec::with_capacity(4usize);
        query.push(("email", email.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Transfer for Sub-account (For Master Account)

Weight(IP): 1

Sends a `POST` request to `/sapi/v1/sub-account/futures/transfer`

Arguments:
- `amount`
- `asset`
- `email`: Sub-account email
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
- `type_`: * `1` - transfer from subaccount's spot account to its USDT-margined futures account
* `2` - transfer from subaccount's USDT-margined futures account to its spot account
* `3` - transfer from subaccount's spot account to its COIN-margined futures account
* `4` - transfer from subaccount's COIN-margined futures account to its spot account
*/
    pub async fn sub_account_futures_transfer<'a>(
        &'a self,
        amount: f64,
        asset: &'a str,
        email: &'a str,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
        type_: i64,
    ) -> Result<
        ResponseValue<types::SubAccountFuturesTransferResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/sub-account/futures/transfer", self.baseurl,);
        let mut query = Vec::with_capacity(7usize);
        query.push(("amount", amount.to_string()));
        query.push(("asset", asset.to_string()));
        query.push(("email", email.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        query.push(("type", type_.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Margin Transfer for Sub-account (For Master Account)

Weight(IP): 1

Sends a `POST` request to `/sapi/v1/sub-account/margin/transfer`

Arguments:
- `amount`
- `asset`
- `email`: Sub-account email
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
- `type_`: * `1` - transfer from subaccount's spot account to margin account
* `2` - transfer from subaccount's margin account to its spot account
*/
    pub async fn sub_account_margin_transfer<'a>(
        &'a self,
        amount: f64,
        asset: &'a str,
        email: &'a str,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
        type_: i64,
    ) -> Result<
        ResponseValue<types::SubAccountMarginTransferResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/sub-account/margin/transfer", self.baseurl,);
        let mut query = Vec::with_capacity(7usize);
        query.push(("amount", amount.to_string()));
        query.push(("asset", asset.to_string()));
        query.push(("email", email.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        query.push(("type", type_.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Transfer to Sub-account of Same Master (For Sub-account)

Weight(IP): 1

Sends a `POST` request to `/sapi/v1/sub-account/transfer/subToSub`

Arguments:
- `amount`
- `asset`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
- `to_email`: Recipient email
*/
    pub async fn sub_account_transfer_sub_to_sub<'a>(
        &'a self,
        amount: f64,
        asset: &'a str,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
        to_email: &'a str,
    ) -> Result<
        ResponseValue<types::SubAccountTransferSubToSubResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/sub-account/transfer/subToSub", self.baseurl,);
        let mut query = Vec::with_capacity(6usize);
        query.push(("amount", amount.to_string()));
        query.push(("asset", asset.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        query.push(("toEmail", to_email.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Transfer to Master (For Sub-account)

Weight(IP): 1

Sends a `POST` request to `/sapi/v1/sub-account/transfer/subToMaster`

Arguments:
- `amount`
- `asset`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn sub_account_transfer_sub_to_master<'a>(
        &'a self,
        amount: f64,
        asset: &'a str,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::SubAccountTransferSubToMasterResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/sub-account/transfer/subToMaster", self.baseurl,);
        let mut query = Vec::with_capacity(5usize);
        query.push(("amount", amount.to_string()));
        query.push(("asset", asset.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Sub-account Transfer History (For Sub-account)

- If `type` is not sent, the records of type 2: transfer out will be returned by default.
- If `startTime` and `endTime` are not sent, the recent 30-day data will be returned.

Weight(IP): 1

Sends a `GET` request to `/sapi/v1/sub-account/transfer/subUserHistory`

Arguments:
- `asset`
- `end_time`: UTC timestamp in ms
- `limit`: Default 500; max 1000.
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `start_time`: UTC timestamp in ms
- `timestamp`: UTC timestamp in ms
- `type_`: * `1` - transfer in
* `2` - transfer out
*/
    pub async fn sub_account_transfer_sub_user_history<'a>(
        &'a self,
        asset: Option<&'a str>,
        end_time: Option<i64>,
        limit: Option<i32>,
        recv_window: Option<i64>,
        signature: &'a str,
        start_time: Option<i64>,
        timestamp: i64,
        type_: Option<i32>,
    ) -> Result<
        ResponseValue<Vec<types::SubAccountTransferSubUserHistoryResponseItem>>,
        Error<types::Error>,
    > {
        let url = format!(
            "{}/sapi/v1/sub-account/transfer/subUserHistory", self.baseurl,
        );
        let mut query = Vec::with_capacity(8usize);
        if let Some(v) = &asset {
            query.push(("asset", v.to_string()));
        }
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        if let Some(v) = &type_ {
            query.push(("type", v.to_string()));
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Universal Transfer History (For Master Account)

- `fromEmail` and `toEmail` cannot be sent at the same time.
- Return `fromEmail` equal master account email by default.
- The query time period must be less then 30 days.
- If startTime and endTime not sent, return records of the last 30 days by default.

Weight(IP): 1

Sends a `GET` request to `/sapi/v1/sub-account/universalTransfer`

Arguments:
- `client_tran_id`
- `end_time`: UTC timestamp in ms
- `from_email`: Sub-account email
- `limit`: Default 500, Max 500
- `page`: Default 1
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `start_time`: UTC timestamp in ms
- `timestamp`: UTC timestamp in ms
- `to_email`: Sub-account email
*/
    pub async fn sub_account_universal_transfer<'a>(
        &'a self,
        client_tran_id: Option<&'a str>,
        end_time: Option<i64>,
        from_email: Option<&'a str>,
        limit: Option<i32>,
        page: Option<i32>,
        recv_window: Option<i64>,
        signature: &'a str,
        start_time: Option<i64>,
        timestamp: i64,
        to_email: Option<&'a str>,
    ) -> Result<
        ResponseValue<Vec<types::SubAccountUniversalTransferResponseItem>>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/sub-account/universalTransfer", self.baseurl,);
        let mut query = Vec::with_capacity(10usize);
        if let Some(v) = &client_tran_id {
            query.push(("clientTranId", v.to_string()));
        }
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        if let Some(v) = &from_email {
            query.push(("fromEmail", v.to_string()));
        }
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }
        if let Some(v) = &page {
            query.push(("page", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        if let Some(v) = &to_email {
            query.push(("toEmail", v.to_string()));
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Universal Transfer (For Master Account)

- You need to enable "internal transfer" option for the api key which requests this endpoint.
- Transfer from master account by default if fromEmail is not sent.
- Transfer to master account by default if toEmail is not sent.
- Supported transfer scenarios:
  - Master account SPOT transfer to sub-account SPOT,USDT_FUTURE,COIN_FUTURE,MARGIN(Cross),ISOLATED_MARGIN
  - Sub-account SPOT,USDT_FUTURE,COIN_FUTURE,MARGIN(Cross),ISOLATED_MARGIN transfer to master account SPOT
  - Transfer between two sub-account SPOT accounts

Weight(IP): 1

Sends a `POST` request to `/sapi/v1/sub-account/universalTransfer`

Arguments:
- `amount`
- `asset`
- `client_tran_id`
- `from_account_type`
- `from_email`: Sub-account email
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `symbol`: Only supported under ISOLATED_MARGIN type
- `timestamp`: UTC timestamp in ms
- `to_account_type`
- `to_email`: Sub-account email
*/
    pub async fn universal_transfer_master_account<'a>(
        &'a self,
        amount: f64,
        asset: &'a str,
        client_tran_id: Option<&'a str>,
        from_account_type: types::UniversalTransferMasterAccountFromAccountType,
        from_email: Option<&'a str>,
        recv_window: Option<i64>,
        signature: &'a str,
        symbol: Option<&'a str>,
        timestamp: i64,
        to_account_type: types::UniversalTransferMasterAccountToAccountType,
        to_email: Option<&'a str>,
    ) -> Result<
        ResponseValue<types::UniversalTransferMasterAccountResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/sub-account/universalTransfer", self.baseurl,);
        let mut query = Vec::with_capacity(11usize);
        query.push(("amount", amount.to_string()));
        query.push(("asset", asset.to_string()));
        if let Some(v) = &client_tran_id {
            query.push(("clientTranId", v.to_string()));
        }
        query.push(("fromAccountType", from_account_type.to_string()));
        if let Some(v) = &from_email {
            query.push(("fromEmail", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &symbol {
            query.push(("symbol", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        query.push(("toAccountType", to_account_type.to_string()));
        if let Some(v) = &to_email {
            query.push(("toEmail", v.to_string()));
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Detail on Sub-account's Futures Account V2 (For Master Account)

Weight(IP): 1

Sends a `GET` request to `/sapi/v2/sub-account/futures/account`

Arguments:
- `email`: Sub-account email
- `futures_type`: * `1` - USDT Margined Futures
* `2` - COIN Margined Futures
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn query_sub_account_futures_account_v2<'a>(
        &'a self,
        email: &'a str,
        futures_type: i32,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::QuerySubAccountFuturesAccountV2Response>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v2/sub-account/futures/account", self.baseurl,);
        let mut query = Vec::with_capacity(5usize);
        query.push(("email", email.to_string()));
        query.push(("futuresType", futures_type.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Summary of Sub-account's Futures Account V2 (For Master Account)

Weight(IP): 10

Sends a `GET` request to `/sapi/v2/sub-account/futures/accountSummary`

Arguments:
- `futures_type`: * `1` - USDT Margined Futures
* `2` - COIN Margined Futures
- `limit`: Default 10, Max 20
- `page`: Default 1
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn query_sub_account_futures_account_summary<'a>(
        &'a self,
        futures_type: i32,
        limit: Option<i32>,
        page: Option<i32>,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::QuerySubAccountFuturesAccountSummaryResponse>,
        Error<types::Error>,
    > {
        let url = format!(
            "{}/sapi/v2/sub-account/futures/accountSummary", self.baseurl,
        );
        let mut query = Vec::with_capacity(6usize);
        query.push(("futuresType", futures_type.to_string()));
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }
        if let Some(v) = &page {
            query.push(("page", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Futures Position-Risk of Sub-account V2 (For Master Account)

Weight(IP): 1

Sends a `GET` request to `/sapi/v2/sub-account/futures/positionRisk`

Arguments:
- `email`: Sub-account email
- `futures_type`: * `1` - USDT Margined Futures
* `2` - COIN Margined Futures
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn query_sub_account_futures_position_risk<'a>(
        &'a self,
        email: &'a str,
        futures_type: i32,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::QuerySubAccountFuturesPositionRiskResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v2/sub-account/futures/positionRisk", self.baseurl,);
        let mut query = Vec::with_capacity(5usize);
        query.push(("email", email.to_string()));
        query.push(("futuresType", futures_type.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Enable Leverage Token for Sub-account (For Master Account)

Weight(IP): 1

Sends a `POST` request to `/sapi/v1/sub-account/blvt/enable`

Arguments:
- `email`: Sub-account email
- `enable_blvt`: Only true for now
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn sub_account_blvt_enable<'a>(
        &'a self,
        email: &'a str,
        enable_blvt: bool,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::SubAccountBlvtEnableResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/sub-account/blvt/enable", self.baseurl,);
        let mut query = Vec::with_capacity(5usize);
        query.push(("email", email.to_string()));
        query.push(("enableBlvt", enable_blvt.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Deposit assets into the managed sub-account(For Investor Master Account)

Weight(IP): 1

Sends a `POST` request to `/sapi/v1/managed-subaccount/deposit`

Arguments:
- `amount`
- `asset`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
- `to_email`: Recipient email
*/
    pub async fn managed_subaccount_deposit<'a>(
        &'a self,
        amount: f64,
        asset: &'a str,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
        to_email: &'a str,
    ) -> Result<
        ResponseValue<types::ManagedSubaccountDepositResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/managed-subaccount/deposit", self.baseurl,);
        let mut query = Vec::with_capacity(6usize);
        query.push(("amount", amount.to_string()));
        query.push(("asset", asset.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        query.push(("toEmail", to_email.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Managed sub-account asset details(For Investor Master Account)

Weight(IP): 1

Sends a `GET` request to `/sapi/v1/managed-subaccount/asset`

Arguments:
- `email`: Sub-account email
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn managed_subaccount_asset<'a>(
        &'a self,
        email: &'a str,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<Vec<types::ManagedSubaccountAssetResponseItem>>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/managed-subaccount/asset", self.baseurl,);
        let mut query = Vec::with_capacity(4usize);
        query.push(("email", email.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Withdrawl assets from the managed sub-account(For Investor Master Account)

Weight(IP): 1

Sends a `POST` request to `/sapi/v1/managed-subaccount/withdraw`

Arguments:
- `amount`
- `asset`
- `from_email`: Sender email
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
- `transfer_date`: Withdrawals is automatically occur on the transfer date(UTC0). If a date is not selected, the withdrawal occurs right now
*/
    pub async fn managed_subaccount_withdraw<'a>(
        &'a self,
        amount: f64,
        asset: &'a str,
        from_email: &'a str,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
        transfer_date: Option<i64>,
    ) -> Result<
        ResponseValue<types::ManagedSubaccountWithdrawResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/managed-subaccount/withdraw", self.baseurl,);
        let mut query = Vec::with_capacity(7usize);
        query.push(("amount", amount.to_string()));
        query.push(("asset", asset.to_string()));
        query.push(("fromEmail", from_email.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        if let Some(v) = &transfer_date {
            query.push(("transferDate", v.to_string()));
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Managed sub-account snapshot (For Investor Master Account)

- The query time period must be less then 30 days
- Support query within the last one month only
- If `startTime` and `endTime` not sent, return records of the last 7 days by default

Weight(IP): 2400

Sends a `GET` request to `/sapi/v1/managed-subaccount/accountSnapshot`

Arguments:
- `email`: Sub-account email
- `end_time`: UTC timestamp in ms
- `limit`: min 7, max 30, default 7
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `start_time`: UTC timestamp in ms
- `timestamp`: UTC timestamp in ms
- `type_`: "SPOT", "MARGIN"(cross), "FUTURES"(UM)
*/
    pub async fn managed_subaccount_account_snapshot<'a>(
        &'a self,
        email: &'a str,
        end_time: Option<i64>,
        limit: Option<i32>,
        recv_window: Option<i64>,
        signature: &'a str,
        start_time: Option<i64>,
        timestamp: i64,
        type_: &'a str,
    ) -> Result<
        ResponseValue<types::ManagedSubaccountAccountSnapshotResponse>,
        Error<types::Error>,
    > {
        let url = format!(
            "{}/sapi/v1/managed-subaccount/accountSnapshot", self.baseurl,
        );
        let mut query = Vec::with_capacity(8usize);
        query.push(("email", email.to_string()));
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        query.push(("type", type_.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Query Managed Sub Account Transfer Log (For Investor Master Account)

Investor can use this api to query managed sub account transfer log. This endpoint is available for investor of Managed Sub-Account. A Managed Sub-Account is an account type for investors who value flexibility in asset allocation and account application, while delegating trades to a professional trading team.

Weight(IP): 1

Sends a `GET` request to `/sapi/v1/managed-subaccount/queryTransLogForInvestor`

Arguments:
- `email`
- `end_time`: UTC timestamp in ms
- `limit`: Default 500; max 1000.
- `page`: Default 1
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `start_time`: UTC timestamp in ms
- `timestamp`: UTC timestamp in ms
- `transfer_function_account_type`: Transfer function account type (SPOT/MARGIN/ISOLATED_MARGIN/USDT_FUTURE/COIN_FUTURE)
- `transfers`: Transfer Direction (FROM/TO)
*/
    pub async fn managed_subaccount_query_trans_log_for_investor<'a>(
        &'a self,
        email: &'a str,
        end_time: Option<i64>,
        limit: Option<i32>,
        page: Option<i32>,
        recv_window: Option<i64>,
        signature: &'a str,
        start_time: Option<i64>,
        timestamp: i64,
        transfer_function_account_type: Option<&'a str>,
        transfers: Option<&'a str>,
    ) -> Result<
        ResponseValue<types::ManagedSubaccountQueryTransLogForInvestorResponse>,
        Error<types::Error>,
    > {
        let url = format!(
            "{}/sapi/v1/managed-subaccount/queryTransLogForInvestor", self.baseurl,
        );
        let mut query = Vec::with_capacity(10usize);
        query.push(("email", email.to_string()));
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }
        if let Some(v) = &page {
            query.push(("page", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        if let Some(v) = &transfer_function_account_type {
            query.push(("transferFunctionAccountType", v.to_string()));
        }
        if let Some(v) = &transfers {
            query.push(("transfers", v.to_string()));
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Query Managed Sub Account Transfer Log (For Trading Team Master Account)

Trading team can use this api to query managed sub account transfer log. This endpoint is available for trading team of Managed Sub-Account. A Managed Sub-Account is an account type for investors who value flexibility in asset allocation and account application, while delegating trades to a professional trading team

Weight(IP): 60

Sends a `GET` request to `/sapi/v1/managed-subaccount/queryTransLogForTradeParent`

Arguments:
- `email`
- `end_time`: UTC timestamp in ms
- `limit`: Default 500; max 1000.
- `page`: Default 1
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `start_time`: UTC timestamp in ms
- `timestamp`: UTC timestamp in ms
- `transfer_function_account_type`: Transfer function account type (SPOT/MARGIN/ISOLATED_MARGIN/USDT_FUTURE/COIN_FUTURE)
- `transfers`: Transfer Direction (FROM/TO)
*/
    pub async fn managed_subaccount_query_trans_log_for_trade_parent<'a>(
        &'a self,
        email: &'a str,
        end_time: Option<i64>,
        limit: Option<i32>,
        page: Option<i32>,
        recv_window: Option<i64>,
        signature: &'a str,
        start_time: Option<i64>,
        timestamp: i64,
        transfer_function_account_type: Option<&'a str>,
        transfers: Option<&'a str>,
    ) -> Result<
        ResponseValue<types::ManagedSubaccountQueryTransLogForTradeParentResponse>,
        Error<types::Error>,
    > {
        let url = format!(
            "{}/sapi/v1/managed-subaccount/queryTransLogForTradeParent", self.baseurl,
        );
        let mut query = Vec::with_capacity(10usize);
        query.push(("email", email.to_string()));
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }
        if let Some(v) = &page {
            query.push(("page", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        if let Some(v) = &transfer_function_account_type {
            query.push(("transferFunctionAccountType", v.to_string()));
        }
        if let Some(v) = &transfers {
            query.push(("transfers", v.to_string()));
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Query Managed Sub-account Futures Asset Details (For Investor Master Account)

Investor can use this api to query managed sub account futures asset details

Sends a `GET` request to `/sapi/v1/managed-subaccount/fetch-future-asset`

Arguments:
- `email`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn managed_subaccount_fetch_future_asset<'a>(
        &'a self,
        email: &'a str,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::ManagedSubaccountFetchFutureAssetResponse>,
        Error<types::Error>,
    > {
        let url = format!(
            "{}/sapi/v1/managed-subaccount/fetch-future-asset", self.baseurl,
        );
        let mut query = Vec::with_capacity(4usize);
        query.push(("email", email.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Query Managed Sub-account Margin Asset Details (For Investor Master Account)

Investor can use this api to query managed sub account margin asset details

Sends a `GET` request to `/sapi/v1/managed-subaccount/marginAsset`

Arguments:
- `email`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn managed_subaccount_margin_asset<'a>(
        &'a self,
        email: &'a str,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::ManagedSubaccountMarginAssetResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/managed-subaccount/marginAsset", self.baseurl,);
        let mut query = Vec::with_capacity(4usize);
        query.push(("email", email.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Query Managed Sub-account List (For Investor)

Get investor's managed sub-account list.

Weight(UID): 60

Sends a `GET` request to `/sapi/v1/managed-subaccount/info`

Arguments:
- `email`
- `limit`: Default 500; max 1000.
- `page`: Default 1
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn managed_subaccount_info<'a>(
        &'a self,
        email: &'a str,
        limit: Option<i32>,
        page: Option<i32>,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::ManagedSubaccountInfoResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/managed-subaccount/info", self.baseurl,);
        let mut query = Vec::with_capacity(6usize);
        query.push(("email", email.to_string()));
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }
        if let Some(v) = &page {
            query.push(("page", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get Managed Sub-account Deposit Address (For Investor Master Account)

Get investor's managed sub-account deposit address

Weight(UID): 1

Sends a `GET` request to `/sapi/v1/managed-subaccount/deposit/address`

Arguments:
- `coin`: Coin name
- `email`
- `network`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn managed_subaccount_deposit_address<'a>(
        &'a self,
        coin: &'a str,
        email: &'a str,
        network: Option<&'a str>,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::ManagedSubaccountDepositAddressResponse>,
        Error<types::Error>,
    > {
        let url = format!(
            "{}/sapi/v1/managed-subaccount/deposit/address", self.baseurl,
        );
        let mut query = Vec::with_capacity(6usize);
        query.push(("coin", coin.to_string()));
        query.push(("email", email.to_string()));
        if let Some(v) = &network {
            query.push(("network", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Query Managed Sub Account Transfer Log (For Trading Team Sub Account)(USER_DATA)

Query Managed Sub Account Transfer Log (For Trading Team Sub Account)

Weight(UID): 60

Sends a `GET` request to `/sapi/v1/managed-subaccount/query-trans-log`

Arguments:
- `end_time`: UTC timestamp in ms
- `limit`: Default 500; max 1000.
- `page`: Default 1
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `start_time`: UTC timestamp in ms
- `timestamp`: UTC timestamp in ms
- `transfer_function_account_type`: Transfer function account type
- `transfers`: Transfer Direction
*/
    pub async fn managed_subaccount_query_trans_log<'a>(
        &'a self,
        end_time: Option<i64>,
        limit: Option<i32>,
        page: Option<i32>,
        recv_window: Option<i64>,
        signature: &'a str,
        start_time: Option<i64>,
        timestamp: i64,
        transfer_function_account_type: types::ManagedSubaccountQueryTransLogTransferFunctionAccountType,
        transfers: types::ManagedSubaccountQueryTransLogTransfers,
    ) -> Result<
        ResponseValue<types::ManagedSubaccountQueryTransLogResponse>,
        Error<types::Error>,
    > {
        let url = format!(
            "{}/sapi/v1/managed-subaccount/query-trans-log", self.baseurl,
        );
        let mut query = Vec::with_capacity(9usize);
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }
        if let Some(v) = &page {
            query.push(("page", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        query
            .push((
                "transferFunctionAccountType",
                transfer_function_account_type.to_string(),
            ));
        query.push(("transfers", transfers.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get IP Restriction for a Sub-account API Key (For Master Account)

Weight(UID): 3000

Sends a `GET` request to `/sapi/v1/sub-account/subAccountApi/ipRestriction`

Arguments:
- `email`: Sub-account email
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `sub_account_api_key`
- `timestamp`: UTC timestamp in ms
*/
    pub async fn query_sub_account_sub_account_api_ip_restriction<'a>(
        &'a self,
        email: &'a str,
        recv_window: Option<i64>,
        signature: &'a str,
        sub_account_api_key: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::QuerySubAccountSubAccountApiIpRestrictionResponse>,
        Error<types::Error>,
    > {
        let url = format!(
            "{}/sapi/v1/sub-account/subAccountApi/ipRestriction", self.baseurl,
        );
        let mut query = Vec::with_capacity(5usize);
        query.push(("email", email.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("subAccountApiKey", sub_account_api_key.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Delete IP List for a Sub-account API Key (For Master Account)

Weight(UID): 3000

Sends a `DELETE` request to `/sapi/v1/sub-account/subAccountApi/ipRestriction/ipList`

Arguments:
- `email`: Sub-account email
- `ip_address`: Can be added in batches, separated by commas
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `sub_account_api_key`
- `third_party_name`: third party IP list name
- `timestamp`: UTC timestamp in ms
*/
    pub async fn sub_account_delete_ip_list<'a>(
        &'a self,
        email: &'a str,
        ip_address: Option<&'a str>,
        recv_window: Option<i64>,
        signature: &'a str,
        sub_account_api_key: &'a str,
        third_party_name: Option<&'a str>,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::SubAccountDeleteIpListResponse>,
        Error<types::Error>,
    > {
        let url = format!(
            "{}/sapi/v1/sub-account/subAccountApi/ipRestriction/ipList", self.baseurl,
        );
        let mut query = Vec::with_capacity(7usize);
        query.push(("email", email.to_string()));
        if let Some(v) = &ip_address {
            query.push(("ipAddress", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("subAccountApiKey", sub_account_api_key.to_string()));
        if let Some(v) = &third_party_name {
            query.push(("thirdPartyName", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .delete(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Query Sub-account Transaction Statistics (For Master Account)

Query Sub-account Transaction statistics (For Master Account).

Weight(UID): 60

Sends a `GET` request to `/sapi/v1/sub-account/transaction-statistics`

Arguments:
- `email`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn sub_account_transaction_statistics<'a>(
        &'a self,
        email: &'a str,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::SubAccountTransactionStatisticsResponse>,
        Error<types::Error>,
    > {
        let url = format!(
            "{}/sapi/v1/sub-account/transaction-statistics", self.baseurl,
        );
        let mut query = Vec::with_capacity(4usize);
        query.push(("email", email.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Enable Options for Sub-account (For Master Account)(USER_DATA)

Enable Options for Sub-account (For Master Account).

Weight(IP): 1

Sends a `POST` request to `/sapi/v1/sub-account/eoptions/enable`

Arguments:
- `email`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn sub_account_eoptions_enable<'a>(
        &'a self,
        email: &'a str,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::SubAccountEoptionsEnableResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/sub-account/eoptions/enable", self.baseurl,);
        let mut query = Vec::with_capacity(4usize);
        query.push(("email", email.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Update IP Restriction for Sub-Account API key (For Master Account)

Update IP Restriction for Sub-Account API key

Weight(UID): 3000

Sends a `POST` request to `/sapi/v2/sub-account/subAccountApi/ipRestriction`

Arguments:
- `email`: Sub-account email
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `status`: IP Restriction status. 1 = IP Unrestricted. 2 = Restrict access to trusted IPs only. 3 = Restrict access to users' trusted third party IPs only
- `sub_account_api_key`
- `third_party_name`: third party IP list name
- `timestamp`: UTC timestamp in ms
*/
    pub async fn set_sub_account_sub_account_api_ip_restriction<'a>(
        &'a self,
        email: &'a str,
        recv_window: Option<i64>,
        signature: &'a str,
        status: &'a str,
        sub_account_api_key: &'a str,
        third_party_name: Option<&'a str>,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::SetSubAccountSubAccountApiIpRestrictionResponse>,
        Error<types::Error>,
    > {
        let url = format!(
            "{}/sapi/v2/sub-account/subAccountApi/ipRestriction", self.baseurl,
        );
        let mut query = Vec::with_capacity(7usize);
        query.push(("email", email.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("status", status.to_string()));
        query.push(("subAccountApiKey", sub_account_api_key.to_string()));
        if let Some(v) = &third_party_name {
            query.push(("thirdPartyName", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Query Sub-account Assets (For Master Account)

Fetch sub-account assets

Weight(UID): 60

Sends a `GET` request to `/sapi/v4/sub-account/assets`

Arguments:
- `email`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn query_sub_account_assets<'a>(
        &'a self,
        email: &'a str,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::QuerySubAccountAssetsResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v4/sub-account/assets", self.baseurl,);
        let mut query = Vec::with_capacity(4usize);
        query.push(("email", email.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Ping/Keep-alive a ListenKey (USER_STREAM)

Keepalive a user data stream to prevent a time out. User data streams will close after 60 minutes. It's recommended to send a ping about every 30 minutes.

Weight: 2

Sends a `PUT` request to `/api/v3/userDataStream`

Arguments:
- `listen_key`: User websocket listen key
*/
    pub async fn ping_keep_alive_listen_key<'a>(
        &'a self,
        listen_key: Option<&'a str>,
    ) -> Result<
        ResponseValue<serde_json::Map<String, serde_json::Value>>,
        Error<types::Error>,
    > {
        let url = format!("{}/api/v3/userDataStream", self.baseurl,);
        let mut query = Vec::with_capacity(1usize);
        if let Some(v) = &listen_key {
            query.push(("listenKey", v.to_string()));
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Create a ListenKey (USER_STREAM)

Start a new user data stream.
The stream will close after 60 minutes unless a keepalive is sent. If the account has an active `listenKey`, that `listenKey` will be returned and its validity will be extended for 60 minutes.

Weight: 2

Sends a `POST` request to `/api/v3/userDataStream`

*/
    pub async fn create_user_data_stream<'a>(
        &'a self,
    ) -> Result<ResponseValue<types::CreateUserDataStreamResponse>, Error<()>> {
        let url = format!("{}/api/v3/userDataStream", self.baseurl,);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Close a ListenKey (USER_STREAM)

Close out a user data stream.

Weight: 2

Sends a `DELETE` request to `/api/v3/userDataStream`

Arguments:
- `listen_key`: User websocket listen key
*/
    pub async fn close_listen_key<'a>(
        &'a self,
        listen_key: Option<&'a str>,
    ) -> Result<
        ResponseValue<serde_json::Map<String, serde_json::Value>>,
        Error<types::Error>,
    > {
        let url = format!("{}/api/v3/userDataStream", self.baseurl,);
        let mut query = Vec::with_capacity(1usize);
        if let Some(v) = &listen_key {
            query.push(("listenKey", v.to_string()));
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .delete(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Ping/Keep-alive a ListenKey (USER_STREAM)

Keepalive a user data stream to prevent a time out. User data streams will close after 60 minutes. It's recommended to send a ping about every 30 minutes.

Weight: 1

Sends a `PUT` request to `/sapi/v1/userDataStream`

Arguments:
- `listen_key`: User websocket listen key
*/
    pub async fn ping_keep_alive_user_stream<'a>(
        &'a self,
        listen_key: Option<&'a str>,
    ) -> Result<
        ResponseValue<serde_json::Map<String, serde_json::Value>>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/userDataStream", self.baseurl,);
        let mut query = Vec::with_capacity(1usize);
        if let Some(v) = &listen_key {
            query.push(("listenKey", v.to_string()));
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Create a ListenKey (USER_STREAM)

Start a new user data stream.
The stream will close after 60 minutes unless a keepalive is sent. If the account has an active `listenKey`, that `listenKey` will be returned and its validity will be extended for 60 minutes.

Weight: 1

Sends a `POST` request to `/sapi/v1/userDataStream`

*/
    pub async fn create_listen_key_user_data_stream<'a>(
        &'a self,
    ) -> Result<ResponseValue<types::CreateListenKeyUserDataStreamResponse>, Error<()>> {
        let url = format!("{}/sapi/v1/userDataStream", self.baseurl,);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Close a ListenKey (USER_STREAM)

Close out a user data stream.

Weight: 1

Sends a `DELETE` request to `/sapi/v1/userDataStream`

Arguments:
- `listen_key`: User websocket listen key
*/
    pub async fn close_listen_key_user_stream<'a>(
        &'a self,
        listen_key: Option<&'a str>,
    ) -> Result<
        ResponseValue<serde_json::Map<String, serde_json::Value>>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/userDataStream", self.baseurl,);
        let mut query = Vec::with_capacity(1usize);
        if let Some(v) = &listen_key {
            query.push(("listenKey", v.to_string()));
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .delete(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Ping/Keep-alive a Listen Key (USER_STREAM)

Keepalive a user data stream to prevent a time out. User data streams will close after 60 minutes. It's recommended to send a ping about every 30 minutes.

Weight: 1

Sends a `PUT` request to `/sapi/v1/userDataStream/isolated`

Arguments:
- `listen_key`: User websocket listen key
*/
    pub async fn ping_keep_alive_user_stream_again<'a>(
        &'a self,
        listen_key: Option<&'a str>,
    ) -> Result<
        ResponseValue<serde_json::Map<String, serde_json::Value>>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/userDataStream/isolated", self.baseurl,);
        let mut query = Vec::with_capacity(1usize);
        if let Some(v) = &listen_key {
            query.push(("listenKey", v.to_string()));
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Generate a Listen Key (USER_STREAM)

Start a new user data stream.
The stream will close after 60 minutes unless a keepalive is sent. If the account has an active `listenKey`, that `listenKey` will be returned and its validity will be extended for 60 minutes.

Weight: 1

Sends a `POST` request to `/sapi/v1/userDataStream/isolated`

*/
    pub async fn user_data_stream_isolated<'a>(
        &'a self,
    ) -> Result<ResponseValue<types::UserDataStreamIsolatedResponse>, Error<()>> {
        let url = format!("{}/sapi/v1/userDataStream/isolated", self.baseurl,);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Close a ListenKey (USER_STREAM)

Close out a user data stream.

Weight: 1

Sends a `DELETE` request to `/sapi/v1/userDataStream/isolated`

Arguments:
- `listen_key`: User websocket listen key
*/
    pub async fn close_listen_key_us<'a>(
        &'a self,
        listen_key: Option<&'a str>,
    ) -> Result<
        ResponseValue<serde_json::Map<String, serde_json::Value>>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/userDataStream/isolated", self.baseurl,);
        let mut query = Vec::with_capacity(1usize);
        if let Some(v) = &listen_key {
            query.push(("listenKey", v.to_string()));
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .delete(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Fiat Deposit/Withdraw History (USER_DATA)

- If beginTime and endTime are not sent, the recent 30-day data will be returned.

Weight(UID): 90000

Sends a `GET` request to `/sapi/v1/fiat/orders`

Arguments:
- `begin_time`
- `end_time`: UTC timestamp in ms
- `page`: Default 1
- `recv_window`: The value cannot be greater than 60000
- `rows`: Default 100, max 500
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
- `transaction_type`: * `0` - deposit
* `1` - withdraw
*/
    pub async fn fiat_orders<'a>(
        &'a self,
        begin_time: Option<i64>,
        end_time: Option<i64>,
        page: Option<i32>,
        recv_window: Option<i64>,
        rows: Option<i32>,
        signature: &'a str,
        timestamp: i64,
        transaction_type: i64,
    ) -> Result<ResponseValue<types::FiatOrdersResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/fiat/orders", self.baseurl,);
        let mut query = Vec::with_capacity(8usize);
        if let Some(v) = &begin_time {
            query.push(("beginTime", v.to_string()));
        }
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        if let Some(v) = &page {
            query.push(("page", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        if let Some(v) = &rows {
            query.push(("rows", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        query.push(("transactionType", transaction_type.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Fiat Payments History (USER_DATA)

- If beginTime and endTime are not sent, the recent 30-day data will be returned.

Weight(IP): 1

Sends a `GET` request to `/sapi/v1/fiat/payments`

Arguments:
- `begin_time`
- `end_time`: UTC timestamp in ms
- `page`: Default 1
- `recv_window`: The value cannot be greater than 60000
- `rows`: Default 100, max 500
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
- `transaction_type`: * `0` - deposit
* `1` - withdraw
*/
    pub async fn fiat_payments<'a>(
        &'a self,
        begin_time: Option<i64>,
        end_time: Option<i64>,
        page: Option<i32>,
        recv_window: Option<i64>,
        rows: Option<i32>,
        signature: &'a str,
        timestamp: i64,
        transaction_type: i64,
    ) -> Result<ResponseValue<types::FiatPaymentsResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/fiat/payments", self.baseurl,);
        let mut query = Vec::with_capacity(8usize);
        if let Some(v) = &begin_time {
            query.push(("beginTime", v.to_string()));
        }
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        if let Some(v) = &page {
            query.push(("page", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        if let Some(v) = &rows {
            query.push(("rows", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        query.push(("transactionType", transaction_type.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get Fixed/Activity Project List(USER_DATA)

Weight(IP): 1

Sends a `GET` request to `/sapi/v1/lending/project/list`

Arguments:
- `asset`
- `current`: Current querying page. Start from 1. Default:1
- `is_sort_asc`: default "true"
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `size`: Default:10 Max:100
- `sort_by`: Default `START_TIME`
- `status`: Default `ALL`
- `timestamp`: UTC timestamp in ms
- `type_`
*/
    pub async fn lending_project_list<'a>(
        &'a self,
        asset: Option<&'a str>,
        current: Option<i32>,
        is_sort_asc: Option<bool>,
        recv_window: Option<i64>,
        signature: &'a str,
        size: Option<i32>,
        sort_by: Option<types::LendingProjectListSortBy>,
        status: Option<types::LendingProjectListStatus>,
        timestamp: i64,
        type_: types::LendingProjectListType,
    ) -> Result<
        ResponseValue<Vec<types::LendingProjectListResponseItem>>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/lending/project/list", self.baseurl,);
        let mut query = Vec::with_capacity(10usize);
        if let Some(v) = &asset {
            query.push(("asset", v.to_string()));
        }
        if let Some(v) = &current {
            query.push(("current", v.to_string()));
        }
        if let Some(v) = &is_sort_asc {
            query.push(("isSortAsc", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &size {
            query.push(("size", v.to_string()));
        }
        if let Some(v) = &sort_by {
            query.push(("sortBy", v.to_string()));
        }
        if let Some(v) = &status {
            query.push(("status", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        query.push(("type", type_.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Purchase Fixed/Activity Project (USER_DATA)

Weight(IP): 1

Sends a `POST` request to `/sapi/v1/lending/customizedFixed/purchase`

Arguments:
- `lot`
- `project_id`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn lending_customized_fixed_purchase<'a>(
        &'a self,
        lot: &'a str,
        project_id: &'a str,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::LendingCustomizedFixedPurchaseResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/lending/customizedFixed/purchase", self.baseurl,);
        let mut query = Vec::with_capacity(5usize);
        query.push(("lot", lot.to_string()));
        query.push(("projectId", project_id.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get Fixed/Activity Project Position (USER_DATA)

Weight(IP): 1

Sends a `GET` request to `/sapi/v1/lending/project/position/list`

Arguments:
- `asset`
- `project_id`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `status`: Default `ALL`
- `timestamp`: UTC timestamp in ms
*/
    pub async fn lending_project_position_list<'a>(
        &'a self,
        asset: &'a str,
        project_id: Option<&'a str>,
        recv_window: Option<i64>,
        signature: &'a str,
        status: Option<types::LendingProjectPositionListStatus>,
        timestamp: i64,
    ) -> Result<
        ResponseValue<Vec<types::LendingProjectPositionListResponseItem>>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/lending/project/position/list", self.baseurl,);
        let mut query = Vec::with_capacity(6usize);
        query.push(("asset", asset.to_string()));
        if let Some(v) = &project_id {
            query.push(("projectId", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &status {
            query.push(("status", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Change Fixed/Activity Position to Daily Position (USER_DATA)

- PositionId is mandatory parameter for fixed position.

Weight(IP): 1

Sends a `POST` request to `/sapi/v1/lending/positionChanged`

Arguments:
- `lot`
- `position_id`
- `project_id`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn lending_position_changed<'a>(
        &'a self,
        lot: &'a str,
        position_id: Option<&'a str>,
        project_id: &'a str,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::LendingPositionChangedResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/lending/positionChanged", self.baseurl,);
        let mut query = Vec::with_capacity(6usize);
        query.push(("lot", lot.to_string()));
        if let Some(v) = &position_id {
            query.push(("positionId", v.to_string()));
        }
        query.push(("projectId", project_id.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get Staking Product List (USER_DATA)

Get available Staking product list.

Weight(IP): 1

Sends a `GET` request to `/sapi/v1/staking/productList`

Arguments:
- `asset`
- `current`: Current querying page. Start from 1. Default:1
- `product`: * `STAKING` - for Locked Staking
* `F_DEFI` - for flexible DeFi Staking
* `L_DEFI` - for locked DeFi Staking
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `size`: Default:10 Max:100
- `timestamp`: UTC timestamp in ms
*/
    pub async fn staking_product_list<'a>(
        &'a self,
        asset: Option<&'a str>,
        current: Option<i32>,
        product: &'a str,
        recv_window: Option<i64>,
        signature: &'a str,
        size: Option<i32>,
        timestamp: i64,
    ) -> Result<
        ResponseValue<Vec<types::StakingProductListResponseItem>>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/staking/productList", self.baseurl,);
        let mut query = Vec::with_capacity(7usize);
        if let Some(v) = &asset {
            query.push(("asset", v.to_string()));
        }
        if let Some(v) = &current {
            query.push(("current", v.to_string()));
        }
        query.push(("product", product.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &size {
            query.push(("size", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Purchase Staking Product (USER_DATA)

Weight(IP): 1

Sends a `POST` request to `/sapi/v1/staking/purchase`

Arguments:
- `amount`
- `product`: * `STAKING` - for Locked Staking
* `F_DEFI` - for flexible DeFi Staking
* `L_DEFI` - for locked DeFi Staking
- `product_id`
- `recv_window`: The value cannot be greater than 60000
- `renewable`: true or false, default false. Active if product is `STAKING` or `L_DEFI`
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn staking_purchase<'a>(
        &'a self,
        amount: f64,
        product: &'a str,
        product_id: &'a str,
        recv_window: Option<i64>,
        renewable: Option<&'a str>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<ResponseValue<types::StakingPurchaseResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/staking/purchase", self.baseurl,);
        let mut query = Vec::with_capacity(7usize);
        query.push(("amount", amount.to_string()));
        query.push(("product", product.to_string()));
        query.push(("productId", product_id.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        if let Some(v) = &renewable {
            query.push(("renewable", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Redeem Staking Product (USER_DATA)

Redeem Staking product. Locked staking and Locked DeFI staking belong to early redemption, redeeming in advance will result in loss of interest that you have earned.

Weight(IP): 1

Sends a `POST` request to `/sapi/v1/staking/redeem`

Arguments:
- `amount`: Mandatory if product is `F_DEFI`
- `position_id`: Mandatory if product is `STAKING` or `L_DEFI`
- `product`: * `STAKING` - for Locked Staking
* `F_DEFI` - for flexible DeFi Staking
* `L_DEFI` - for locked DeFi Staking
- `product_id`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn staking_redeem<'a>(
        &'a self,
        amount: Option<f64>,
        position_id: Option<&'a str>,
        product: &'a str,
        product_id: &'a str,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<ResponseValue<types::StakingRedeemResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/staking/redeem", self.baseurl,);
        let mut query = Vec::with_capacity(7usize);
        if let Some(v) = &amount {
            query.push(("amount", v.to_string()));
        }
        if let Some(v) = &position_id {
            query.push(("positionId", v.to_string()));
        }
        query.push(("product", product.to_string()));
        query.push(("productId", product_id.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get Staking Product Position (USER_DATA)

Weight(IP): 1

Sends a `GET` request to `/sapi/v1/staking/position`

Arguments:
- `asset`
- `current`: Current querying page. Start from 1. Default:1
- `product`: * `STAKING` - for Locked Staking
* `F_DEFI` - for flexible DeFi Staking
* `L_DEFI` - for locked DeFi Staking
- `product_id`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `size`: Default:10 Max:100
- `timestamp`: UTC timestamp in ms
*/
    pub async fn staking_position<'a>(
        &'a self,
        asset: Option<&'a str>,
        current: Option<i32>,
        product: &'a str,
        product_id: Option<&'a str>,
        recv_window: Option<i64>,
        signature: &'a str,
        size: Option<i32>,
        timestamp: i64,
    ) -> Result<
        ResponseValue<Vec<types::StakingPositionResponseItem>>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/staking/position", self.baseurl,);
        let mut query = Vec::with_capacity(8usize);
        if let Some(v) = &asset {
            query.push(("asset", v.to_string()));
        }
        if let Some(v) = &current {
            query.push(("current", v.to_string()));
        }
        query.push(("product", product.to_string()));
        if let Some(v) = &product_id {
            query.push(("productId", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &size {
            query.push(("size", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get Staking History (USER_DATA)

Weight(IP): 1

Sends a `GET` request to `/sapi/v1/staking/stakingRecord`

Arguments:
- `asset`
- `current`: Current querying page. Start from 1. Default:1
- `end_time`: UTC timestamp in ms
- `product`: * `STAKING` - for Locked Staking
* `F_DEFI` - for flexible DeFi Staking
* `L_DEFI` - for locked DeFi Staking
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `size`: Default:10 Max:100
- `start_time`: UTC timestamp in ms
- `timestamp`: UTC timestamp in ms
- `txn_type`: `SUBSCRIPTION`, `REDEMPTION`, `INTEREST`
*/
    pub async fn staking_staking_record<'a>(
        &'a self,
        asset: Option<&'a str>,
        current: Option<i32>,
        end_time: Option<i64>,
        product: &'a str,
        recv_window: Option<i64>,
        signature: &'a str,
        size: Option<i32>,
        start_time: Option<i64>,
        timestamp: i64,
        txn_type: &'a str,
    ) -> Result<
        ResponseValue<Vec<types::StakingStakingRecordResponseItem>>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/staking/stakingRecord", self.baseurl,);
        let mut query = Vec::with_capacity(10usize);
        if let Some(v) = &asset {
            query.push(("asset", v.to_string()));
        }
        if let Some(v) = &current {
            query.push(("current", v.to_string()));
        }
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        query.push(("product", product.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &size {
            query.push(("size", v.to_string()));
        }
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        query.push(("txnType", txn_type.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Set Auto Staking (USER_DATA)

Set auto staking on Locked Staking or Locked DeFi Staking

Weight(IP): 1

Sends a `POST` request to `/sapi/v1/staking/setAutoStaking`

Arguments:
- `position_id`
- `product`: * `STAKING` - for Locked Staking
* `L_DEFI` - for locked DeFi Staking
- `recv_window`: The value cannot be greater than 60000
- `renewable`: true or false
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn staking_set_auto_staking<'a>(
        &'a self,
        position_id: &'a str,
        product: &'a str,
        recv_window: Option<i64>,
        renewable: &'a str,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::StakingSetAutoStakingResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/staking/setAutoStaking", self.baseurl,);
        let mut query = Vec::with_capacity(6usize);
        query.push(("positionId", position_id.to_string()));
        query.push(("product", product.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("renewable", renewable.to_string()));
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get Personal Left Quota of Staking Product (USER_DATA)

Weight(IP): 1

Sends a `GET` request to `/sapi/v1/staking/personalLeftQuota`

Arguments:
- `product`: * `STAKING` - for Locked Staking
* `F_DEFI` - for flexible DeFi Staking
* `L_DEFI` - for locked DeFi Staking
- `product_id`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn staking_personal_left_quota<'a>(
        &'a self,
        product: &'a str,
        product_id: &'a str,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<Vec<types::StakingPersonalLeftQuotaResponseItem>>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/staking/personalLeftQuota", self.baseurl,);
        let mut query = Vec::with_capacity(5usize);
        query.push(("product", product.to_string()));
        query.push(("productId", product_id.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Acquiring Algorithm (MARKET_DATA)

Weight(IP): 1

Sends a `GET` request to `/sapi/v1/mining/pub/algoList`

*/
    pub async fn mining_pub_algo_list<'a>(
        &'a self,
    ) -> Result<ResponseValue<types::MiningPubAlgoListResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/mining/pub/algoList", self.baseurl,);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Acquiring CoinName (MARKET_DATA)

Weight(IP): 1

Sends a `GET` request to `/sapi/v1/mining/pub/coinList`

*/
    pub async fn mining_pub_coin_list<'a>(
        &'a self,
    ) -> Result<ResponseValue<types::MiningPubCoinListResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/mining/pub/coinList", self.baseurl,);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Request for Detail Miner List (USER_DATA)

Weight(IP): 5

Sends a `GET` request to `/sapi/v1/mining/worker/detail`

Arguments:
- `algo`: Algorithm(sha256)
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
- `user_name`: Mining Account
- `worker_name`: Miners name
*/
    pub async fn mining_worker_detail<'a>(
        &'a self,
        algo: &'a str,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
        user_name: &'a str,
        worker_name: &'a str,
    ) -> Result<ResponseValue<types::MiningWorkerDetailResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/mining/worker/detail", self.baseurl,);
        let mut query = Vec::with_capacity(6usize);
        query.push(("algo", algo.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        query.push(("userName", user_name.to_string()));
        query.push(("workerName", worker_name.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Request for Miner List (USER_DATA)

Weight(IP): 5

Sends a `GET` request to `/sapi/v1/mining/worker/list`

Arguments:
- `algo`: Algorithm(sha256)
- `page_index`: Page number, default is first page, start form 1
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `sort`: sort sequence(default=0)0 positive sequence, 1 negative sequence
- `sort_column`: Sort by( default 1): 1: miner name, 2: real-time computing power, 3: daily average computing power, 4: real-time rejection rate, 5: last submission time
- `timestamp`: UTC timestamp in ms
- `user_name`: Mining Account
- `worker_status`: miners status(default=0)0 all, 1 valid, 2 invalid, 3 failure
*/
    pub async fn mining_worker_list<'a>(
        &'a self,
        algo: &'a str,
        page_index: Option<i32>,
        recv_window: Option<i64>,
        signature: &'a str,
        sort: Option<i32>,
        sort_column: Option<i32>,
        timestamp: i64,
        user_name: &'a str,
        worker_status: Option<i32>,
    ) -> Result<ResponseValue<types::MiningWorkerListResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/mining/worker/list", self.baseurl,);
        let mut query = Vec::with_capacity(9usize);
        query.push(("algo", algo.to_string()));
        if let Some(v) = &page_index {
            query.push(("pageIndex", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &sort {
            query.push(("sort", v.to_string()));
        }
        if let Some(v) = &sort_column {
            query.push(("sortColumn", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        query.push(("userName", user_name.to_string()));
        if let Some(v) = &worker_status {
            query.push(("workerStatus", v.to_string()));
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Earnings List (USER_DATA)

Weight(IP): 5

Sends a `GET` request to `/sapi/v1/mining/payment/list`

Arguments:
- `algo`: Algorithm(sha256)
- `coin`: Coin name
- `end_date`: Search date, millisecond timestamp, while empty query all
- `page_index`: Page number, default is first page, start form 1
- `page_size`: Number of pages, minimum 10, maximum 200
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `start_date`: Search date, millisecond timestamp, while empty query all
- `timestamp`: UTC timestamp in ms
- `user_name`: Mining Account
*/
    pub async fn mining_payment_list<'a>(
        &'a self,
        algo: &'a str,
        coin: Option<&'a str>,
        end_date: Option<&'a str>,
        page_index: Option<i32>,
        page_size: Option<&'a str>,
        recv_window: Option<i64>,
        signature: &'a str,
        start_date: Option<&'a str>,
        timestamp: i64,
        user_name: &'a str,
    ) -> Result<ResponseValue<types::MiningPaymentListResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/mining/payment/list", self.baseurl,);
        let mut query = Vec::with_capacity(10usize);
        query.push(("algo", algo.to_string()));
        if let Some(v) = &coin {
            query.push(("coin", v.to_string()));
        }
        if let Some(v) = &end_date {
            query.push(("endDate", v.to_string()));
        }
        if let Some(v) = &page_index {
            query.push(("pageIndex", v.to_string()));
        }
        if let Some(v) = &page_size {
            query.push(("pageSize", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &start_date {
            query.push(("startDate", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        query.push(("userName", user_name.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Extra Bonus List (USER_DATA)

Weight(IP): 5

Sends a `GET` request to `/sapi/v1/mining/payment/other`

Arguments:
- `algo`: Algorithm(sha256)
- `coin`: Coin name
- `end_date`: Search date, millisecond timestamp, while empty query all
- `page_index`: Page number, default is first page, start form 1
- `page_size`: Number of pages, minimum 10, maximum 200
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `start_date`: Search date, millisecond timestamp, while empty query all
- `timestamp`: UTC timestamp in ms
- `user_name`: Mining Account
*/
    pub async fn mining_payment_other<'a>(
        &'a self,
        algo: &'a str,
        coin: Option<&'a str>,
        end_date: Option<&'a str>,
        page_index: Option<i32>,
        page_size: Option<&'a str>,
        recv_window: Option<i64>,
        signature: &'a str,
        start_date: Option<&'a str>,
        timestamp: i64,
        user_name: &'a str,
    ) -> Result<ResponseValue<types::MiningPaymentOtherResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/mining/payment/other", self.baseurl,);
        let mut query = Vec::with_capacity(10usize);
        query.push(("algo", algo.to_string()));
        if let Some(v) = &coin {
            query.push(("coin", v.to_string()));
        }
        if let Some(v) = &end_date {
            query.push(("endDate", v.to_string()));
        }
        if let Some(v) = &page_index {
            query.push(("pageIndex", v.to_string()));
        }
        if let Some(v) = &page_size {
            query.push(("pageSize", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &start_date {
            query.push(("startDate", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        query.push(("userName", user_name.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Hashrate Resale List (USER_DATA)

Weight(IP): 5

Sends a `GET` request to `/sapi/v1/mining/hash-transfer/config/details/list`

Arguments:
- `page_index`: Page number, default is first page, start form 1
- `page_size`: Number of pages, minimum 10, maximum 200
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn mining_hash_transfer_config_details_list<'a>(
        &'a self,
        page_index: Option<i32>,
        page_size: Option<&'a str>,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::MiningHashTransferConfigDetailsListResponse>,
        Error<types::Error>,
    > {
        let url = format!(
            "{}/sapi/v1/mining/hash-transfer/config/details/list", self.baseurl,
        );
        let mut query = Vec::with_capacity(5usize);
        if let Some(v) = &page_index {
            query.push(("pageIndex", v.to_string()));
        }
        if let Some(v) = &page_size {
            query.push(("pageSize", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Hashrate Resale Details (USER_DATA)

Weight(IP): 5

Sends a `GET` request to `/sapi/v1/mining/hash-transfer/profit/details`

Arguments:
- `config_id`: Mining ID
- `page_index`: Page number, default is first page, start form 1
- `page_size`: Number of pages, minimum 10, maximum 200
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
- `user_name`: Mining Account
*/
    pub async fn mining_hash_transfer_profit_details<'a>(
        &'a self,
        config_id: &'a str,
        page_index: Option<i32>,
        page_size: Option<&'a str>,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
        user_name: &'a str,
    ) -> Result<
        ResponseValue<types::MiningHashTransferProfitDetailsResponse>,
        Error<types::Error>,
    > {
        let url = format!(
            "{}/sapi/v1/mining/hash-transfer/profit/details", self.baseurl,
        );
        let mut query = Vec::with_capacity(7usize);
        query.push(("configId", config_id.to_string()));
        if let Some(v) = &page_index {
            query.push(("pageIndex", v.to_string()));
        }
        if let Some(v) = &page_size {
            query.push(("pageSize", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        query.push(("userName", user_name.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Hashrate Resale Request (USER_DATA)

Weight(IP): 5

Sends a `POST` request to `/sapi/v1/mining/hash-transfer/config`

Arguments:
- `algo`: Algorithm(sha256)
- `end_date`: Search date, millisecond timestamp, while empty query all
- `hash_rate`: Resale hashrate h/s must be transferred (BTC is greater than 500000000000 ETH is greater than 500000)
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `start_date`: Search date, millisecond timestamp, while empty query all
- `timestamp`: UTC timestamp in ms
- `to_pool_user`: Mining Account
- `user_name`: Mining Account
*/
    pub async fn mining_hash_transfer_config<'a>(
        &'a self,
        algo: &'a str,
        end_date: Option<&'a str>,
        hash_rate: &'a str,
        recv_window: Option<i64>,
        signature: &'a str,
        start_date: Option<&'a str>,
        timestamp: i64,
        to_pool_user: &'a str,
        user_name: &'a str,
    ) -> Result<
        ResponseValue<types::MiningHashTransferConfigResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/mining/hash-transfer/config", self.baseurl,);
        let mut query = Vec::with_capacity(9usize);
        query.push(("algo", algo.to_string()));
        if let Some(v) = &end_date {
            query.push(("endDate", v.to_string()));
        }
        query.push(("hashRate", hash_rate.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &start_date {
            query.push(("startDate", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        query.push(("toPoolUser", to_pool_user.to_string()));
        query.push(("userName", user_name.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Cancel Hashrate Resale configuration (USER_DATA)

Weight(IP): 5

Sends a `POST` request to `/sapi/v1/mining/hash-transfer/config/cancel`

Arguments:
- `config_id`: Mining ID
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
- `user_name`: Mining Account
*/
    pub async fn mining_hash_transfer_config_cancel<'a>(
        &'a self,
        config_id: &'a str,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
        user_name: &'a str,
    ) -> Result<
        ResponseValue<types::MiningHashTransferConfigCancelResponse>,
        Error<types::Error>,
    > {
        let url = format!(
            "{}/sapi/v1/mining/hash-transfer/config/cancel", self.baseurl,
        );
        let mut query = Vec::with_capacity(5usize);
        query.push(("configId", config_id.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        query.push(("userName", user_name.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Statistic List (USER_DATA)

Weight(IP): 5

Sends a `GET` request to `/sapi/v1/mining/statistics/user/status`

Arguments:
- `algo`: Algorithm(sha256)
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
- `user_name`: Mining Account
*/
    pub async fn mining_statistics_user_status<'a>(
        &'a self,
        algo: &'a str,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
        user_name: &'a str,
    ) -> Result<
        ResponseValue<types::MiningStatisticsUserStatusResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/mining/statistics/user/status", self.baseurl,);
        let mut query = Vec::with_capacity(5usize);
        query.push(("algo", algo.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        query.push(("userName", user_name.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Account List (USER_DATA)

Weight(IP): 5

Sends a `GET` request to `/sapi/v1/mining/statistics/user/list`

Arguments:
- `algo`: Algorithm(sha256)
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
- `user_name`: Mining Account
*/
    pub async fn mining_statistics_user_list<'a>(
        &'a self,
        algo: &'a str,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
        user_name: &'a str,
    ) -> Result<
        ResponseValue<types::MiningStatisticsUserListResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/mining/statistics/user/list", self.baseurl,);
        let mut query = Vec::with_capacity(5usize);
        query.push(("algo", algo.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        query.push(("userName", user_name.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Mining Account Earning (USER_DATA)

Weight(IP): 5

Sends a `GET` request to `/sapi/v1/mining/payment/uid`

Arguments:
- `algo`: Algorithm(sha256)
- `end_date`: Search date, millisecond timestamp, while empty query all
- `page_index`: Page number, default is first page, start form 1
- `page_size`: Number of pages, minimum 10, maximum 200
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `start_date`: Search date, millisecond timestamp, while empty query all
- `timestamp`: UTC timestamp in ms
*/
    pub async fn mining_payment_uid<'a>(
        &'a self,
        algo: &'a str,
        end_date: Option<&'a str>,
        page_index: Option<i32>,
        page_size: Option<&'a str>,
        recv_window: Option<i64>,
        signature: &'a str,
        start_date: Option<&'a str>,
        timestamp: i64,
    ) -> Result<ResponseValue<types::MiningPaymentUidResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/mining/payment/uid", self.baseurl,);
        let mut query = Vec::with_capacity(8usize);
        query.push(("algo", algo.to_string()));
        if let Some(v) = &end_date {
            query.push(("endDate", v.to_string()));
        }
        if let Some(v) = &page_index {
            query.push(("pageIndex", v.to_string()));
        }
        if let Some(v) = &page_size {
            query.push(("pageSize", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &start_date {
            query.push(("startDate", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get Future Account Transaction History List (USER_DATA)

Weight(IP): 10

Sends a `GET` request to `/sapi/v1/futures/transfer`

Arguments:
- `asset`
- `current`: Current querying page. Start from 1. Default:1
- `end_time`: UTC timestamp in ms
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `size`: Default:10 Max:100
- `start_time`: UTC timestamp in ms
- `timestamp`: UTC timestamp in ms
*/
    pub async fn get_future_account_transaction_history<'a>(
        &'a self,
        asset: &'a str,
        current: Option<i32>,
        end_time: Option<i64>,
        recv_window: Option<i64>,
        signature: &'a str,
        size: Option<i32>,
        start_time: i64,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::GetFutureAccountTransactionHistoryResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/futures/transfer", self.baseurl,);
        let mut query = Vec::with_capacity(8usize);
        query.push(("asset", asset.to_string()));
        if let Some(v) = &current {
            query.push(("current", v.to_string()));
        }
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &size {
            query.push(("size", v.to_string()));
        }
        query.push(("startTime", start_time.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**New Future Account Transfer (USER_DATA)

Execute transfer between spot account and futures account.

Weight(IP): 1

Sends a `POST` request to `/sapi/v1/futures/transfer`

Arguments:
- `amount`
- `asset`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
- `type_`: 1: transfer from spot account to USDT- futures account. 2: transfer from USDT- futures account to spot account. 3: transfer from spot account to COIN- futures account. 4: transfer from COIN- futures account to spot account.
*/
    pub async fn futures_transfer<'a>(
        &'a self,
        amount: f64,
        asset: &'a str,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
        type_: i64,
    ) -> Result<ResponseValue<types::FuturesTransferResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/futures/transfer", self.baseurl,);
        let mut query = Vec::with_capacity(6usize);
        query.push(("amount", amount.to_string()));
        query.push(("asset", asset.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        query.push(("type", type_.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get Future TickLevel Orderbook Historical Data Download Link (USER_DATA)

Weight(IP): 1

Sends a `GET` request to `/sapi/v1/futures/histDataLink`

Arguments:
- `data_type`
- `end_time`: UTC timestamp in ms
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `start_time`: UTC timestamp in ms
- `symbol`
- `timestamp`: UTC timestamp in ms
*/
    pub async fn futures_hist_data_link<'a>(
        &'a self,
        data_type: types::FuturesHistDataLinkDataType,
        end_time: Option<i64>,
        recv_window: Option<i64>,
        signature: &'a str,
        start_time: Option<i64>,
        symbol: &'a str,
        timestamp: i64,
    ) -> Result<ResponseValue<types::FuturesHistDataLinkResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/futures/histDataLink", self.baseurl,);
        let mut query = Vec::with_capacity(7usize);
        query.push(("dataType", data_type.to_string()));
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        query.push(("symbol", symbol.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Volume Participation(VP) New Order (TRADE)

Send in a VP new order. Only support on USD-M Contracts.

- You need to enable `Futures Trading Permission` for the api key which requests this endpoint.
- Base URL: https://api.binance.com

- Total Algo open orders max allowed: 10 orders.
- Leverage of symbols and position mode will be the same as your futures account settings. You can set up through the trading page or fapi.
- Receiving "success": true does not mean that your order will be executed. Please use the query order endpoints(GET sapi/v1/algo/futures/openOrders or GET sapi/v1/algo/futures/historicalOrders) to check the order status. For example: Your futures balance is insufficient, or open position with reduce only or position side is inconsistent with your own setting. In these cases you will receive "success": true, but the order status will be expired after we check it.

Weight(UID): 3000

Sends a `POST` request to `/sapi/v1/algo/futures/newOrderVp`

Arguments:
- `client_algo_id`: A unique id among Algo orders (length should be 32 characters) If it is not sent, we will give default value
- `limit_price`: Limit price of the order; If it is not sent, will place order by market price by default
- `position_side`: Default BOTH for One-way Mode ; LONG or SHORT for Hedge Mode. It must be sent in Hedge Mode.
- `quantity`: Quantity of base asset; The notional (quantity * mark price(base asset)) must be more than the equivalent of 10,000 USDT and less than the equivalent of 1,000,000 USDT
- `recv_window`: The value cannot be greater than 60000
- `reduce_only`: 'true' or 'false'. Default 'false'; Cannot be sent in Hedge Mode; Cannot be sent when you open a position
- `side`
- `signature`: Signature
- `symbol`: Trading symbol, e.g. BNBUSDT
- `timestamp`: UTC timestamp in ms
- `urgency`: Represent the relative speed of the current execution; ENUM: LOW, MEDIUM, HIGH
*/
    pub async fn algo_futures_new_order_vp<'a>(
        &'a self,
        client_algo_id: Option<&'a str>,
        limit_price: Option<f64>,
        position_side: Option<types::AlgoFuturesNewOrderVpPositionSide>,
        quantity: f64,
        recv_window: Option<i64>,
        reduce_only: Option<bool>,
        side: types::AlgoFuturesNewOrderVpSide,
        signature: &'a str,
        symbol: &'a str,
        timestamp: i64,
        urgency: types::AlgoFuturesNewOrderVpUrgency,
    ) -> Result<
        ResponseValue<types::AlgoFuturesNewOrderVpResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/algo/futures/newOrderVp", self.baseurl,);
        let mut query = Vec::with_capacity(11usize);
        if let Some(v) = &client_algo_id {
            query.push(("clientAlgoId", v.to_string()));
        }
        if let Some(v) = &limit_price {
            query.push(("limitPrice", v.to_string()));
        }
        if let Some(v) = &position_side {
            query.push(("positionSide", v.to_string()));
        }
        query.push(("quantity", quantity.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        if let Some(v) = &reduce_only {
            query.push(("reduceOnly", v.to_string()));
        }
        query.push(("side", side.to_string()));
        query.push(("signature", signature.to_string()));
        query.push(("symbol", symbol.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        query.push(("urgency", urgency.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Time-Weighted Average Price(Twap) New Order (TRADE)

Send in a Twap new order. Only support on USD-M Contracts.

You need to enable Futures Trading Permission for the api key which requests this endpoint.
Base URL: https://api.binance.com

- Total Algo open orders max allowed: 10 orders.
- Leverage of symbols and position mode will be the same as your futures account settings. You can set up through the trading page or fapi.
- Receiving "success": true does not mean that your order will be executed. Please use the query order endpoints(GET sapi/v1/algo/futures/openOrders or GET sapi/v1/algo/futures/historicalOrders) to check the order status. For example: Your futures balance is insufficient, or open position with reduce only or position side is inconsistent with your own setting. In these cases you will receive "success": true, but the order status will be expired after we check it.
- quantity * 60 / duration should be larger than minQty
- duration cannot be less than 5 mins or more than 24 hours.
- For delivery contracts, TWAP end time should be one hour earlier than the delivery time of the symbol.

Weight(UID): 3000

Sends a `POST` request to `/sapi/v1/algo/futures/newOrderTwap`

Arguments:
- `client_algo_id`: A unique id among Algo orders (length should be 32 characters) If it is not sent, we will give default value
- `duration`: Duration for TWAP orders in seconds. [300, 86400];Less than 5min => defaults to 5 min; Greater than 24h => defaults to 24h
- `limit_price`: Limit price of the order; If it is not sent, will place order by market price by default
- `position_side`: Default BOTH for One-way Mode ; LONG or SHORT for Hedge Mode. It must be sent in Hedge Mode.
- `quantity`: Quantity of base asset; The notional (quantity * mark price(base asset)) must be more than the equivalent of 10,000 USDT and less than the equivalent of 1,000,000 USDT
- `recv_window`: The value cannot be greater than 60000
- `reduce_only`: 'true' or 'false'. Default 'false'; Cannot be sent in Hedge Mode; Cannot be sent when you open a position
- `side`
- `signature`: Signature
- `symbol`: Trading symbol, e.g. BNBUSDT
- `timestamp`: UTC timestamp in ms
*/
    pub async fn algo_futures_new_order_twap<'a>(
        &'a self,
        client_algo_id: Option<&'a str>,
        duration: i64,
        limit_price: Option<f64>,
        position_side: Option<types::AlgoFuturesNewOrderTwapPositionSide>,
        quantity: f64,
        recv_window: Option<i64>,
        reduce_only: Option<bool>,
        side: types::AlgoFuturesNewOrderTwapSide,
        signature: &'a str,
        symbol: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::AlgoFuturesNewOrderTwapResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/algo/futures/newOrderTwap", self.baseurl,);
        let mut query = Vec::with_capacity(11usize);
        if let Some(v) = &client_algo_id {
            query.push(("clientAlgoId", v.to_string()));
        }
        query.push(("duration", duration.to_string()));
        if let Some(v) = &limit_price {
            query.push(("limitPrice", v.to_string()));
        }
        if let Some(v) = &position_side {
            query.push(("positionSide", v.to_string()));
        }
        query.push(("quantity", quantity.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        if let Some(v) = &reduce_only {
            query.push(("reduceOnly", v.to_string()));
        }
        query.push(("side", side.to_string()));
        query.push(("signature", signature.to_string()));
        query.push(("symbol", symbol.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Cancel Algo Order(TRADE)

Cancel an active order.
- You need to enable Futures Trading Permission for the api key which requests this endpoint.
- Base URL: https://api.binance.com

Weight(IP): 1

Sends a `DELETE` request to `/sapi/v1/algo/futures/order`

Arguments:
- `algo_id`: Eg. 14511
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn cancel_algo_futures_order<'a>(
        &'a self,
        algo_id: i64,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::CancelAlgoFuturesOrderResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/algo/futures/order", self.baseurl,);
        let mut query = Vec::with_capacity(4usize);
        query.push(("algoId", algo_id.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .delete(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Query Current Algo Open Orders (USER_DATA)

- You need to enable Futures Trading Permission for the api key which requests this endpoint.
- Base URL: https://api.binance.com

Weight(IP): 1

Sends a `GET` request to `/sapi/v1/algo/futures/openOrders`

Arguments:
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn algo_futures_open_orders<'a>(
        &'a self,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::AlgoFuturesOpenOrdersResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/algo/futures/openOrders", self.baseurl,);
        let mut query = Vec::with_capacity(3usize);
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Query Historical Algo Orders (USER_DATA)

- You need to enable Futures Trading Permission for the api key which requests this endpoint.
- Base URL: https://api.binance.com

Weight(IP): 1

Sends a `GET` request to `/sapi/v1/algo/futures/historicalOrders`

Arguments:
- `end_time`: UTC timestamp in ms
- `page`: Default 1
- `page_size`: Page size, minimum 1, maximum 100, default 100
- `recv_window`: The value cannot be greater than 60000
- `side`
- `signature`: Signature
- `start_time`: UTC timestamp in ms
- `symbol`: Trading symbol, e.g. BNBUSDT
- `timestamp`: UTC timestamp in ms
*/
    pub async fn algo_futures_historical_orders<'a>(
        &'a self,
        end_time: Option<i64>,
        page: Option<i32>,
        page_size: Option<&'a str>,
        recv_window: Option<i64>,
        side: Option<types::AlgoFuturesHistoricalOrdersSide>,
        signature: &'a str,
        start_time: Option<i64>,
        symbol: Option<&'a str>,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::AlgoFuturesHistoricalOrdersResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/algo/futures/historicalOrders", self.baseurl,);
        let mut query = Vec::with_capacity(9usize);
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        if let Some(v) = &page {
            query.push(("page", v.to_string()));
        }
        if let Some(v) = &page_size {
            query.push(("pageSize", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        if let Some(v) = &side {
            query.push(("side", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        if let Some(v) = &symbol {
            query.push(("symbol", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Query Sub Orders (USER_DATA)

- You need to enable Futures Trading Permission for the api key which requests this endpoint.
- Base URL: https://api.binance.com

Weight(IP): 1

Sends a `GET` request to `/sapi/v1/algo/futures/subOrders`

Arguments:
- `algo_id`
- `page`: Default 1
- `page_size`: Page size, minimum 1, maximum 100, default 100
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn algo_futures_sub_orders<'a>(
        &'a self,
        algo_id: i64,
        page: Option<i32>,
        page_size: Option<&'a str>,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::AlgoFuturesSubOrdersResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/algo/futures/subOrders", self.baseurl,);
        let mut query = Vec::with_capacity(6usize);
        query.push(("algoId", algo_id.to_string()));
        if let Some(v) = &page {
            query.push(("page", v.to_string()));
        }
        if let Some(v) = &page_size {
            query.push(("pageSize", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Time-Weighted Average Price (Twap) New Order

Place a new spot TWAP order with Algo service.

Weight(UID): 3000

Sends a `POST` request to `/sapi/v1/algo/spot/newOrderTwap`

Arguments:
- `client_algo_id`
- `duration`
- `limit_price`
- `quantity`
- `recv_window`: The value cannot be greater than 60000
- `side`
- `signature`: Signature
- `symbol`: Trading symbol, e.g. BNBUSDT
- `timestamp`: UTC timestamp in ms
*/
    pub async fn algo_spot_new_order_twap<'a>(
        &'a self,
        client_algo_id: Option<&'a str>,
        duration: i32,
        limit_price: Option<f32>,
        quantity: f64,
        recv_window: Option<i64>,
        side: types::AlgoSpotNewOrderTwapSide,
        signature: &'a str,
        symbol: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::AlgoSpotNewOrderTwapResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/algo/spot/newOrderTwap", self.baseurl,);
        let mut query = Vec::with_capacity(9usize);
        if let Some(v) = &client_algo_id {
            query.push(("clientAlgoId", v.to_string()));
        }
        query.push(("duration", duration.to_string()));
        if let Some(v) = &limit_price {
            query.push(("limitPrice", v.to_string()));
        }
        query.push(("quantity", quantity.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("side", side.to_string()));
        query.push(("signature", signature.to_string()));
        query.push(("symbol", symbol.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Cancel Algo Order

Cancel an open TWAP order

Weight(IP): 1

Sends a `DELETE` request to `/sapi/v1/algo/spot/order`

Arguments:
- `algo_id`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn cancel_algo_spot_order<'a>(
        &'a self,
        algo_id: i64,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<ResponseValue<types::CancelAlgoSpotOrderResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/algo/spot/order", self.baseurl,);
        let mut query = Vec::with_capacity(4usize);
        query.push(("algoId", algo_id.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .delete(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Query Current Algo Open Orders

Get all open SPOT TWAP orders

Weight(IP): 1

Sends a `GET` request to `/sapi/v1/algo/spot/openOrders`

Arguments:
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn algo_spot_open_orders<'a>(
        &'a self,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<ResponseValue<types::AlgoSpotOpenOrdersResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/algo/spot/openOrders", self.baseurl,);
        let mut query = Vec::with_capacity(3usize);
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Query Historical Algo Orders

Get all historical SPOT TWAP orders

Weight(IP): 1

Sends a `GET` request to `/sapi/v1/algo/spot/historicalOrders`

Arguments:
- `end_time`: UTC timestamp in ms
- `page`: Default 1
- `page_size`: Number of pages, minimum 10, maximum 200
- `recv_window`: The value cannot be greater than 60000
- `side`
- `signature`: Signature
- `start_time`: UTC timestamp in ms
- `symbol`: Trading symbol, e.g. BNBUSDT
- `timestamp`: UTC timestamp in ms
*/
    pub async fn algo_spot_historical_orders<'a>(
        &'a self,
        end_time: Option<i64>,
        page: Option<i32>,
        page_size: Option<&'a str>,
        recv_window: Option<i64>,
        side: types::AlgoSpotHistoricalOrdersSide,
        signature: &'a str,
        start_time: Option<i64>,
        symbol: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::AlgoSpotHistoricalOrdersResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/algo/spot/historicalOrders", self.baseurl,);
        let mut query = Vec::with_capacity(9usize);
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        if let Some(v) = &page {
            query.push(("page", v.to_string()));
        }
        if let Some(v) = &page_size {
            query.push(("pageSize", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("side", side.to_string()));
        query.push(("signature", signature.to_string()));
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        query.push(("symbol", symbol.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Query Sub Orders

Get respective sub orders for a specified algoId

Weight(IP): 1

Sends a `GET` request to `/sapi/v1/algo/spot/subOrders`

Arguments:
- `algo_id`
- `page`: Default 1
- `page_size`: Number of pages, minimum 10, maximum 200
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn algo_spot_sub_orders<'a>(
        &'a self,
        algo_id: i64,
        page: Option<i32>,
        page_size: Option<&'a str>,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<ResponseValue<types::AlgoSpotSubOrdersResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/algo/spot/subOrders", self.baseurl,);
        let mut query = Vec::with_capacity(6usize);
        query.push(("algoId", algo_id.to_string()));
        if let Some(v) = &page {
            query.push(("page", v.to_string()));
        }
        if let Some(v) = &page_size {
            query.push(("pageSize", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Portfolio Margin Account (USER_DATA)

Get the account info

'Weight(IP): 1'

Sends a `GET` request to `/sapi/v1/portfolio/account`

Arguments:
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn portfolio_account<'a>(
        &'a self,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<ResponseValue<types::PortfolioAccountResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/portfolio/account", self.baseurl,);
        let mut query = Vec::with_capacity(3usize);
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Portfolio Margin Collateral Rate (MARKET_DATA)

Portfolio Margin Collateral Rate.

Weight(IP): 50

Sends a `GET` request to `/sapi/v1/portfolio/collateralRate`

*/
    pub async fn portfolio_collateral_rate<'a>(
        &'a self,
    ) -> Result<
        ResponseValue<Vec<types::PortfolioCollateralRateResponseItem>>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/portfolio/collateralRate", self.baseurl,);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Portfolio Margin Bankruptcy Loan Amount (USER_DATA)

Query Portfolio Margin Bankruptcy Loan Amount.

Weight(UID): 500

Sends a `GET` request to `/sapi/v1/portfolio/pmLoan`

Arguments:
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn portfolio_pm_loan<'a>(
        &'a self,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<ResponseValue<types::PortfolioPmLoanResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/portfolio/pmLoan", self.baseurl,);
        let mut query = Vec::with_capacity(3usize);
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Portfolio Margin Bankruptcy Loan Repay (USER_DATA)

Repay Portfolio Margin Bankruptcy Loan.

Weight(UID): 3000

Sends a `POST` request to `/sapi/v1/portfolio/repay`

Arguments:
- `from`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn portfolio_repay<'a>(
        &'a self,
        from: Option<&'a str>,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<ResponseValue<types::PortfolioRepayResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/portfolio/repay", self.baseurl,);
        let mut query = Vec::with_capacity(4usize);
        if let Some(v) = &from {
            query.push(("from", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Query Classic Portfolio Margin Negative Balance Interest History (USER_DATA)

Query interest history of negative balance for portfolio margin.

Weight(IP): 50

Sends a `GET` request to `/sapi/v1/portfolio/interest-history`

Arguments:
- `asset`
- `end_time`: UTC timestamp in ms
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `size`: Default:10 Max:100
- `start_time`: UTC timestamp in ms
- `timestamp`: UTC timestamp in ms
*/
    pub async fn portfolio_interest_history<'a>(
        &'a self,
        asset: &'a str,
        end_time: Option<i64>,
        recv_window: Option<i64>,
        signature: &'a str,
        size: Option<i32>,
        start_time: Option<i64>,
        timestamp: i64,
    ) -> Result<
        ResponseValue<Vec<types::PortfolioInterestHistoryResponseItem>>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/portfolio/interest-history", self.baseurl,);
        let mut query = Vec::with_capacity(7usize);
        query.push(("asset", asset.to_string()));
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &size {
            query.push(("size", v.to_string()));
        }
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Query Portfolio Margin Asset Index Price (MARKET_DATA)

Query Portfolio Margin Asset Index Price

Weight(IP):
- 1 if send asset
- 50 if not send asset

Sends a `GET` request to `/sapi/v1/portfolio/asset-index-price`

*/
    pub async fn portfolio_asset_index_price<'a>(
        &'a self,
        asset: Option<&'a str>,
    ) -> Result<
        ResponseValue<Vec<types::PortfolioAssetIndexPriceResponseItem>>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/portfolio/asset-index-price", self.baseurl,);
        let mut query = Vec::with_capacity(1usize);
        if let Some(v) = &asset {
            query.push(("asset", v.to_string()));
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Fund Auto-collection (USER_DATA)

Transfers all assets from Futures Account to Margin account

Weight(IP): 1500

Sends a `POST` request to `/sapi/v1/portfolio/auto-collection`

Arguments:
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn portfolio_auto_collection<'a>(
        &'a self,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::PortfolioAutoCollectionResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/portfolio/auto-collection", self.baseurl,);
        let mut query = Vec::with_capacity(3usize);
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**BNB Transfer (USER_DATA)

BNB transfer can be between Margin Account and USDM Account

Weight(IP): 1500

Sends a `POST` request to `/sapi/v1/portfolio/bnb-transfer`

Arguments:
- `amount`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
- `transfer_side`
*/
    pub async fn portfolio_bnb_transfer<'a>(
        &'a self,
        amount: f64,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
        transfer_side: types::PortfolioBnbTransferTransferSide,
    ) -> Result<
        ResponseValue<types::PortfolioBnbTransferResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/portfolio/bnb-transfer", self.baseurl,);
        let mut query = Vec::with_capacity(5usize);
        query.push(("amount", amount.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        query.push(("transferSide", transfer_side.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get Auto-repay-futures Status (USER_DATA)

Query Auto-repay-futures Status

Weight(IP): 30

Sends a `GET` request to `/sapi/v1/portfolio/repay-futures-switch`

Arguments:
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn get_auto_repay_futures_status<'a>(
        &'a self,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::GetAutoRepayFuturesStatusResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/portfolio/repay-futures-switch", self.baseurl,);
        let mut query = Vec::with_capacity(3usize);
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Change Auto-repay-futures Status (USER_DATA)

Change Auto-repay-futures Status

Weight(IP): 1500

Sends a `POST` request to `/sapi/v1/portfolio/repay-futures-switch`

Arguments:
- `auto_repay`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn portfolio_repay_futures_switch<'a>(
        &'a self,
        auto_repay: bool,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::PortfolioRepayFuturesSwitchResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/portfolio/repay-futures-switch", self.baseurl,);
        let mut query = Vec::with_capacity(4usize);
        query.push(("autoRepay", auto_repay.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Repay futures Negative Balance (USER_DATA)

Repay futures Negative Balance

Weight(IP): 1500

Sends a `POST` request to `/sapi/v1/portfolio/repay-futures-negative-balance`

Arguments:
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn portfolio_repay_futures_negative_balance<'a>(
        &'a self,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::PortfolioRepayFuturesNegativeBalanceResponse>,
        Error<types::Error>,
    > {
        let url = format!(
            "{}/sapi/v1/portfolio/repay-futures-negative-balance", self.baseurl,
        );
        let mut query = Vec::with_capacity(3usize);
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get Portfolio Margin Asset Leverage (USER_DATA)

Weight(IP): 50

Sends a `GET` request to `/sapi/v1/portfolio/margin-asset-leverage`

*/
    pub async fn portfolio_margin_asset_leverage<'a>(
        &'a self,
    ) -> Result<
        ResponseValue<Vec<types::PortfolioMarginAssetLeverageResponseItem>>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/portfolio/margin-asset-leverage", self.baseurl,);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Fund Collection by Asset (USER_DATA)

Transfers specific asset from Futures Account to Margin account

Weight(IP): 60

Sends a `POST` request to `/sapi/v1/portfolio/asset-collection`

Arguments:
- `asset`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn portfolio_asset_collection<'a>(
        &'a self,
        asset: &'a str,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::PortfolioAssetCollectionResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/portfolio/asset-collection", self.baseurl,);
        let mut query = Vec::with_capacity(4usize);
        query.push(("asset", asset.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**BLVT Info (MARKET_DATA)

Weight(IP): 1

Sends a `GET` request to `/sapi/v1/blvt/tokenInfo`

Arguments:
- `token_name`: BTCDOWN, BTCUP
*/
    pub async fn blvt_token_info<'a>(
        &'a self,
        token_name: Option<&'a str>,
    ) -> Result<
        ResponseValue<Vec<types::BlvtTokenInfoResponseItem>>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/blvt/tokenInfo", self.baseurl,);
        let mut query = Vec::with_capacity(1usize);
        if let Some(v) = &token_name {
            query.push(("tokenName", v.to_string()));
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Subscribe BLVT (USER_DATA)

Weight(IP): 1

Sends a `POST` request to `/sapi/v1/blvt/subscribe`

Arguments:
- `cost`: Spot balance
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
- `token_name`: BTCDOWN, BTCUP
*/
    pub async fn blvt_subscribe<'a>(
        &'a self,
        cost: f64,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
        token_name: &'a str,
    ) -> Result<ResponseValue<types::BlvtSubscribeResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/blvt/subscribe", self.baseurl,);
        let mut query = Vec::with_capacity(5usize);
        query.push(("cost", cost.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        query.push(("tokenName", token_name.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Query Subscription Record (USER_DATA)

- Only the data of the latest 90 days is available

Weight(IP): 1

Sends a `GET` request to `/sapi/v1/blvt/subscribe/record`

Arguments:
- `end_time`: UTC timestamp in ms
- `id`
- `limit`: Default 500; max 1000.
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `start_time`: UTC timestamp in ms
- `timestamp`: UTC timestamp in ms
- `token_name`: BTCDOWN, BTCUP
*/
    pub async fn blvt_subscribe_record<'a>(
        &'a self,
        end_time: Option<i64>,
        id: Option<i64>,
        limit: Option<i32>,
        recv_window: Option<i64>,
        signature: &'a str,
        start_time: Option<i64>,
        timestamp: i64,
        token_name: Option<&'a str>,
    ) -> Result<ResponseValue<types::BlvtSubscribeRecordResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/blvt/subscribe/record", self.baseurl,);
        let mut query = Vec::with_capacity(8usize);
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        if let Some(v) = &id {
            query.push(("id", v.to_string()));
        }
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        if let Some(v) = &token_name {
            query.push(("tokenName", v.to_string()));
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Redeem BLVT (USER_DATA)

Weight(IP): 1

Sends a `POST` request to `/sapi/v1/blvt/redeem`

Arguments:
- `amount`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
- `token_name`: BTCDOWN, BTCUP
*/
    pub async fn blvt_redeem<'a>(
        &'a self,
        amount: f64,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
        token_name: &'a str,
    ) -> Result<ResponseValue<types::BlvtRedeemResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/blvt/redeem", self.baseurl,);
        let mut query = Vec::with_capacity(5usize);
        query.push(("amount", amount.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        query.push(("tokenName", token_name.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Redemption Record (USER_DATA)

- Only the data of the latest 90 days is available

Weight(IP): 1

Sends a `GET` request to `/sapi/v1/blvt/redeem/record`

Arguments:
- `end_time`: UTC timestamp in ms
- `id`
- `limit`: default 1000, max 1000
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `start_time`: UTC timestamp in ms
- `timestamp`: UTC timestamp in ms
- `token_name`: BTCDOWN, BTCUP
*/
    pub async fn blvt_redeem_record<'a>(
        &'a self,
        end_time: Option<i64>,
        id: Option<i64>,
        limit: Option<i32>,
        recv_window: Option<i64>,
        signature: &'a str,
        start_time: Option<i64>,
        timestamp: i64,
        token_name: Option<&'a str>,
    ) -> Result<
        ResponseValue<Vec<types::BlvtRedeemRecordResponseItem>>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/blvt/redeem/record", self.baseurl,);
        let mut query = Vec::with_capacity(8usize);
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        if let Some(v) = &id {
            query.push(("id", v.to_string()));
        }
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        if let Some(v) = &token_name {
            query.push(("tokenName", v.to_string()));
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**BLVT User Limit Info (USER_DATA)

Weight(IP): 1

Sends a `GET` request to `/sapi/v1/blvt/userLimit`

Arguments:
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
- `token_name`: BTCDOWN, BTCUP
*/
    pub async fn blvt_user_limit<'a>(
        &'a self,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
        token_name: Option<&'a str>,
    ) -> Result<
        ResponseValue<Vec<types::BlvtUserLimitResponseItem>>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/blvt/userLimit", self.baseurl,);
        let mut query = Vec::with_capacity(4usize);
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        if let Some(v) = &token_name {
            query.push(("tokenName", v.to_string()));
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**List All Swap Pools (MARKET_DATA)

Get metadata about all swap pools.

Weight(IP): 1

Sends a `GET` request to `/sapi/v1/bswap/pools`

*/
    pub async fn bswap_pools<'a>(
        &'a self,
    ) -> Result<ResponseValue<Vec<types::BswapPoolsResponseItem>>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/bswap/pools", self.baseurl,);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Liquidity information of a pool (USER_DATA)

Get liquidity information and user share of a pool.

Weight(IP):
- `1` for one pool;
- `10` when the poolId parameter is omitted;

Sends a `GET` request to `/sapi/v1/bswap/liquidity`

Arguments:
- `pool_id`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn bswap_liquidity<'a>(
        &'a self,
        pool_id: Option<i64>,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<Vec<types::BswapLiquidityResponseItem>>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/bswap/liquidity", self.baseurl,);
        let mut query = Vec::with_capacity(4usize);
        if let Some(v) = &pool_id {
            query.push(("poolId", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Add Liquidity (TRADE)

Add liquidity to a pool.

Weight(UID): 1000 (Additional: 3 times one second)

Sends a `POST` request to `/sapi/v1/bswap/liquidityAdd`

Arguments:
- `asset`
- `pool_id`
- `quantity`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
- `type_`: * `Single` - to add a single token
* `Combination` - to add dual tokens
*/
    pub async fn bswap_liquidity_add<'a>(
        &'a self,
        asset: &'a str,
        pool_id: i64,
        quantity: f64,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
        type_: Option<types::BswapLiquidityAddType>,
    ) -> Result<ResponseValue<types::BswapLiquidityAddResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/bswap/liquidityAdd", self.baseurl,);
        let mut query = Vec::with_capacity(7usize);
        query.push(("asset", asset.to_string()));
        query.push(("poolId", pool_id.to_string()));
        query.push(("quantity", quantity.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        if let Some(v) = &type_ {
            query.push(("type", v.to_string()));
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Remove Liquidity (TRADE)

Remove liquidity from a pool, `type` include `SINGLE` and `COMBINATION`, asset is mandatory for single asset removal

Weight(UID): 1000 (Additional: 3 times one second)

Sends a `POST` request to `/sapi/v1/bswap/liquidityRemove`

Arguments:
- `asset`: Mandatory for single asset removal
- `pool_id`
- `recv_window`: The value cannot be greater than 60000
- `share_amount`
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
- `type_`: * `SINGLE` - for single asset removal
* `COMBINATION` - for combination of all coins removal
*/
    pub async fn bswap_liquidity_remove<'a>(
        &'a self,
        asset: Option<&'a str>,
        pool_id: i64,
        recv_window: Option<i64>,
        share_amount: f64,
        signature: &'a str,
        timestamp: i64,
        type_: types::BswapLiquidityRemoveType,
    ) -> Result<
        ResponseValue<types::BswapLiquidityRemoveResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/bswap/liquidityRemove", self.baseurl,);
        let mut query = Vec::with_capacity(7usize);
        if let Some(v) = &asset {
            query.push(("asset", v.to_string()));
        }
        query.push(("poolId", pool_id.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("shareAmount", share_amount.to_string()));
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        query.push(("type", type_.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Liquidity Operation Record (USER_DATA)

Get liquidity operation (add/remove) records.

Weight(UID): 3000

Sends a `GET` request to `/sapi/v1/bswap/liquidityOps`

Arguments:
- `end_time`: UTC timestamp in ms
- `limit`: Default 500; max 1000.
- `operation`
- `operation_id`
- `pool_id`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `start_time`: UTC timestamp in ms
- `timestamp`: UTC timestamp in ms
*/
    pub async fn bswap_liquidity_ops<'a>(
        &'a self,
        end_time: Option<i64>,
        limit: Option<i32>,
        operation: Option<types::BswapLiquidityOpsOperation>,
        operation_id: Option<i64>,
        pool_id: Option<i64>,
        recv_window: Option<i64>,
        signature: &'a str,
        start_time: Option<i64>,
        timestamp: i64,
    ) -> Result<
        ResponseValue<Vec<types::BswapLiquidityOpsResponseItem>>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/bswap/liquidityOps", self.baseurl,);
        let mut query = Vec::with_capacity(9usize);
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }
        if let Some(v) = &operation {
            query.push(("operation", v.to_string()));
        }
        if let Some(v) = &operation_id {
            query.push(("operationId", v.to_string()));
        }
        if let Some(v) = &pool_id {
            query.push(("poolId", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Request Quote (USER_DATA)

Request a quote for swap quote asset (selling asset) for base asset (buying asset), essentially price/exchange rates.

quoteQty is quantity of quote asset (to sell).

Please be noted the quote is for reference only, the actual price will change as the liquidity changes, it's recommended to swap immediate after request a quote for slippage prevention.

Weight(UID): 150

Sends a `GET` request to `/sapi/v1/bswap/quote`

Arguments:
- `base_asset`
- `quote_asset`
- `quote_qty`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn bswap_quote<'a>(
        &'a self,
        base_asset: &'a str,
        quote_asset: &'a str,
        quote_qty: f64,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<ResponseValue<types::BswapQuoteResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/bswap/quote", self.baseurl,);
        let mut query = Vec::with_capacity(6usize);
        query.push(("baseAsset", base_asset.to_string()));
        query.push(("quoteAsset", quote_asset.to_string()));
        query.push(("quoteQty", quote_qty.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Swap History (USER_DATA)

Get swap history.

Weight(UID): 3000

Sends a `GET` request to `/sapi/v1/bswap/swap`

Arguments:
- `base_asset`
- `end_time`: UTC timestamp in ms
- `limit`: default 3, max 100
- `quote_asset`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `start_time`: UTC timestamp in ms
- `status`: * `0` - pending for swap
* `1` - success
* `2` - failed
- `swap_id`
- `timestamp`: UTC timestamp in ms
*/
    pub async fn swap_history<'a>(
        &'a self,
        base_asset: Option<&'a str>,
        end_time: Option<i64>,
        limit: Option<i32>,
        quote_asset: Option<&'a str>,
        recv_window: Option<i64>,
        signature: &'a str,
        start_time: Option<i64>,
        status: Option<i32>,
        swap_id: Option<i64>,
        timestamp: i64,
    ) -> Result<
        ResponseValue<Vec<types::SwapHistoryResponseItem>>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/bswap/swap", self.baseurl,);
        let mut query = Vec::with_capacity(10usize);
        if let Some(v) = &base_asset {
            query.push(("baseAsset", v.to_string()));
        }
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }
        if let Some(v) = &quote_asset {
            query.push(("quoteAsset", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        if let Some(v) = &status {
            query.push(("status", v.to_string()));
        }
        if let Some(v) = &swap_id {
            query.push(("swapId", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Swap (TRADE)

Swap `quoteAsset` for `baseAsset`.

Weight(UID): 1000 (Additional: 3 times one second)

Sends a `POST` request to `/sapi/v1/bswap/swap`

Arguments:
- `base_asset`
- `quote_asset`
- `quote_qty`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn bswap_swap<'a>(
        &'a self,
        base_asset: &'a str,
        quote_asset: &'a str,
        quote_qty: f64,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<ResponseValue<types::BswapSwapResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/bswap/swap", self.baseurl,);
        let mut query = Vec::with_capacity(6usize);
        query.push(("baseAsset", base_asset.to_string()));
        query.push(("quoteAsset", quote_asset.to_string()));
        query.push(("quoteQty", quote_qty.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Pool Configure (USER_DATA)

Weight(IP): 150

Sends a `GET` request to `/sapi/v1/bswap/poolConfigure`

Arguments:
- `pool_id`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn bswap_pool_configure<'a>(
        &'a self,
        pool_id: Option<i64>,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<Vec<types::BswapPoolConfigureResponseItem>>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/bswap/poolConfigure", self.baseurl,);
        let mut query = Vec::with_capacity(4usize);
        if let Some(v) = &pool_id {
            query.push(("poolId", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Add Liquidity Preview (USER_DATA)

Calculate expected share amount for adding liquidity in single or dual token.

Weight(IP): 150

Sends a `GET` request to `/sapi/v1/bswap/addLiquidityPreview`

Arguments:
- `pool_id`
- `quote_asset`
- `quote_qty`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
- `type_`: * `SINGLE` - for adding a single token
* `COMBINATION` - for adding dual tokens
*/
    pub async fn bswap_add_liquidity_preview<'a>(
        &'a self,
        pool_id: i64,
        quote_asset: &'a str,
        quote_qty: f64,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
        type_: types::BswapAddLiquidityPreviewType,
    ) -> Result<
        ResponseValue<types::BswapAddLiquidityPreviewResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/bswap/addLiquidityPreview", self.baseurl,);
        let mut query = Vec::with_capacity(7usize);
        query.push(("poolId", pool_id.to_string()));
        query.push(("quoteAsset", quote_asset.to_string()));
        query.push(("quoteQty", quote_qty.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        query.push(("type", type_.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Remove Liquidity Preview (USER_DATA)

Calculate the expected asset amount of single token redemption or dual token redemption.

Weight(IP): 150

Sends a `GET` request to `/sapi/v1/bswap/removeLiquidityPreview`

Arguments:
- `pool_id`
- `quote_asset`
- `recv_window`: The value cannot be greater than 60000
- `share_amount`
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
- `type_`: * `SINGLE` - remove and obtain a single token
* `COMBINATION` - remove and obtain dual token
*/
    pub async fn bswap_remove_liquidity_preview<'a>(
        &'a self,
        pool_id: i64,
        quote_asset: &'a str,
        recv_window: Option<i64>,
        share_amount: f64,
        signature: &'a str,
        timestamp: i64,
        type_: types::BswapRemoveLiquidityPreviewType,
    ) -> Result<
        ResponseValue<types::BswapRemoveLiquidityPreviewResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/bswap/removeLiquidityPreview", self.baseurl,);
        let mut query = Vec::with_capacity(7usize);
        query.push(("poolId", pool_id.to_string()));
        query.push(("quoteAsset", quote_asset.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("shareAmount", share_amount.to_string()));
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        query.push(("type", type_.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get Unclaimed Rewards Record (USER_DATA)

Get unclaimed rewards record.

Weight(UID): 1000

Sends a `GET` request to `/sapi/v1/bswap/unclaimedRewards`

Arguments:
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
- `type_`: 0: Swap rewards, 1: Liquidity rewards, default to 0
*/
    pub async fn bswap_unclaimed_rewards<'a>(
        &'a self,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
        type_: Option<i32>,
    ) -> Result<
        ResponseValue<types::BswapUnclaimedRewardsResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/bswap/unclaimedRewards", self.baseurl,);
        let mut query = Vec::with_capacity(4usize);
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        if let Some(v) = &type_ {
            query.push(("type", v.to_string()));
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Claim rewards (TRADE)

Claim swap rewards or liquidity rewards

Weight(UID): 1000

Sends a `POST` request to `/sapi/v1/bswap/claimRewards`

Arguments:
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
- `type_`: 0: Swap rewards, 1: Liquidity rewards, default to 0
*/
    pub async fn bswap_claim_rewards<'a>(
        &'a self,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
        type_: Option<i32>,
    ) -> Result<ResponseValue<types::BswapClaimRewardsResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/bswap/claimRewards", self.baseurl,);
        let mut query = Vec::with_capacity(4usize);
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        if let Some(v) = &type_ {
            query.push(("type", v.to_string()));
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get Claimed History (USER_DATA)

Get history of claimed rewards.

Weight(UID): 1000

Sends a `GET` request to `/sapi/v1/bswap/claimedHistory`

Arguments:
- `asset_rewards`
- `end_time`: UTC timestamp in ms
- `limit`: Default 3, max 100
- `pool_id`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `start_time`: UTC timestamp in ms
- `timestamp`: UTC timestamp in ms
- `type_`: 0: Swap rewards, 1: Liquidity rewards, default to 0
*/
    pub async fn bswap_claimed_history<'a>(
        &'a self,
        asset_rewards: Option<&'a str>,
        end_time: Option<i64>,
        limit: Option<i32>,
        pool_id: Option<i64>,
        recv_window: Option<i64>,
        signature: &'a str,
        start_time: Option<i64>,
        timestamp: i64,
        type_: Option<i32>,
    ) -> Result<
        ResponseValue<Vec<types::BswapClaimedHistoryResponseItem>>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/bswap/claimedHistory", self.baseurl,);
        let mut query = Vec::with_capacity(9usize);
        if let Some(v) = &asset_rewards {
            query.push(("assetRewards", v.to_string()));
        }
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }
        if let Some(v) = &pool_id {
            query.push(("poolId", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        if let Some(v) = &type_ {
            query.push(("type", v.to_string()));
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get C2C Trade History (USER_DATA)

- If startTimestamp and endTimestamp are not sent, the recent 30-day data will be returned.
- The max interval between startTimestamp and endTimestamp is 30 days.

Weight(IP): 1

Sends a `GET` request to `/sapi/v1/c2c/orderMatch/listUserOrderHistory`

Arguments:
- `end_timestamp`: UTC timestamp in ms
- `page`: Default 1
- `recv_window`: The value cannot be greater than 60000
- `rows`: default 100, max 100
- `signature`: Signature
- `start_timestamp`: UTC timestamp in ms
- `timestamp`: UTC timestamp in ms
- `trade_type`
*/
    pub async fn c2c_order_match_list_user_order_history<'a>(
        &'a self,
        end_timestamp: Option<i64>,
        page: Option<i32>,
        recv_window: Option<i64>,
        rows: Option<i32>,
        signature: &'a str,
        start_timestamp: Option<i64>,
        timestamp: i64,
        trade_type: types::C2cOrderMatchListUserOrderHistoryTradeType,
    ) -> Result<
        ResponseValue<types::C2cOrderMatchListUserOrderHistoryResponse>,
        Error<types::Error>,
    > {
        let url = format!(
            "{}/sapi/v1/c2c/orderMatch/listUserOrderHistory", self.baseurl,
        );
        let mut query = Vec::with_capacity(8usize);
        if let Some(v) = &end_timestamp {
            query.push(("endTimestamp", v.to_string()));
        }
        if let Some(v) = &page {
            query.push(("page", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        if let Some(v) = &rows {
            query.push(("rows", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &start_timestamp {
            query.push(("startTimestamp", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        query.push(("tradeType", trade_type.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get VIP Loan Ongoing Orders (USER_DATA)

VIP loan is available for VIP users only.

Weight(IP): 400

Sends a `GET` request to `/sapi/v1/loan/vip/ongoing/orders`

Arguments:
- `collateral_account_id`
- `collateral_coin`: Coin used as collateral
- `current`: Current querying page. Start from 1. Default:1
- `limit`: Default 10; max 100.
- `loan_coin`: Coin loaned
- `order_id`: Order id
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn loan_vip_ongoing_orders<'a>(
        &'a self,
        collateral_account_id: Option<i64>,
        collateral_coin: Option<&'a str>,
        current: Option<i32>,
        limit: Option<i32>,
        loan_coin: Option<&'a str>,
        order_id: Option<i64>,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::LoanVipOngoingOrdersResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/loan/vip/ongoing/orders", self.baseurl,);
        let mut query = Vec::with_capacity(9usize);
        if let Some(v) = &collateral_account_id {
            query.push(("collateralAccountId", v.to_string()));
        }
        if let Some(v) = &collateral_coin {
            query.push(("collateralCoin", v.to_string()));
        }
        if let Some(v) = &current {
            query.push(("current", v.to_string()));
        }
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }
        if let Some(v) = &loan_coin {
            query.push(("loanCoin", v.to_string()));
        }
        if let Some(v) = &order_id {
            query.push(("orderId", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**VIP Loan Repay (TRADE)

VIP loan is available for VIP users only.

Weight(UID): 6000

Sends a `POST` request to `/sapi/v1/loan/vip/repay`

Arguments:
- `amount`
- `order_id`: Order id
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn loan_vip_repay<'a>(
        &'a self,
        amount: f64,
        order_id: Option<i64>,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<ResponseValue<types::LoanVipRepayResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/loan/vip/repay", self.baseurl,);
        let mut query = Vec::with_capacity(5usize);
        query.push(("amount", amount.to_string()));
        if let Some(v) = &order_id {
            query.push(("orderId", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get VIP Loan Repayment History (USER_DATA)

VIP loan is available for VIP users only.

Weight(IP): 400

Sends a `GET` request to `/sapi/v1/loan/vip/repay/history`

Arguments:
- `current`: Current querying page. Start from 1. Default:1
- `end_time`: UTC timestamp in ms
- `limit`: Default 10; max 100.
- `loan_coin`: Coin loaned
- `order_id`: Order id
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `start_time`: UTC timestamp in ms
- `timestamp`: UTC timestamp in ms
*/
    pub async fn loan_vip_repay_history<'a>(
        &'a self,
        current: Option<i32>,
        end_time: Option<i64>,
        limit: Option<i32>,
        loan_coin: Option<&'a str>,
        order_id: Option<i64>,
        recv_window: Option<i64>,
        signature: &'a str,
        start_time: Option<i64>,
        timestamp: i64,
    ) -> Result<ResponseValue<types::LoanVipRepayHistoryResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/loan/vip/repay/history", self.baseurl,);
        let mut query = Vec::with_capacity(9usize);
        if let Some(v) = &current {
            query.push(("current", v.to_string()));
        }
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }
        if let Some(v) = &loan_coin {
            query.push(("loanCoin", v.to_string()));
        }
        if let Some(v) = &order_id {
            query.push(("orderId", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Check Locked Value of VIP Collateral Account (USER_DATA)

VIP loan is available for VIP users only.

Weight(IP): 6000

Sends a `GET` request to `/sapi/v1/loan/vip/collateral/account`

Arguments:
- `collateral_account_id`
- `order_id`: Order id
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn loan_vip_collateral_account<'a>(
        &'a self,
        collateral_account_id: Option<i64>,
        order_id: Option<i64>,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::LoanVipCollateralAccountResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/loan/vip/collateral/account", self.baseurl,);
        let mut query = Vec::with_capacity(5usize);
        if let Some(v) = &collateral_account_id {
            query.push(("collateralAccountId", v.to_string()));
        }
        if let Some(v) = &order_id {
            query.push(("orderId", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**VIP Loan Borrow

VIP loan is available for VIP users only.

Weight(UID): 6000

Sends a `POST` request to `/sapi/v1/loan/vip/borrow`

Arguments:
- `collateral_account_id`
- `collateral_coin`
- `is_flexible_rate`
- `loan_account_id`
- `loan_amount`
- `loan_coin`: Coin loaned
- `loan_term`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn loan_vip_borrow<'a>(
        &'a self,
        collateral_account_id: &'a str,
        collateral_coin: &'a str,
        is_flexible_rate: types::LoanVipBorrowIsFlexibleRate,
        loan_account_id: i64,
        loan_amount: f32,
        loan_coin: Option<&'a str>,
        loan_term: Option<i64>,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<ResponseValue<types::LoanVipBorrowResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/loan/vip/borrow", self.baseurl,);
        let mut query = Vec::with_capacity(10usize);
        query.push(("collateralAccountId", collateral_account_id.to_string()));
        query.push(("collateralCoin", collateral_coin.to_string()));
        query.push(("isFlexibleRate", is_flexible_rate.to_string()));
        query.push(("loanAccountId", loan_account_id.to_string()));
        query.push(("loanAmount", loan_amount.to_string()));
        if let Some(v) = &loan_coin {
            query.push(("loanCoin", v.to_string()));
        }
        if let Some(v) = &loan_term {
            query.push(("loanTerm", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get Loanable Assets Data

Get interest rate and borrow limit of loanable assets. The borrow limit is shown in USD value.

Weight(IP): 400

Sends a `GET` request to `/sapi/v1/loan/vip/loanable/data`

Arguments:
- `loan_coin`: Coin loaned
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
- `vip_level`: Defaults to user's vip level
*/
    pub async fn loan_vip_loanable_data<'a>(
        &'a self,
        loan_coin: Option<&'a str>,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
        vip_level: Option<i32>,
    ) -> Result<ResponseValue<types::LoanVipLoanableDataResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/loan/vip/loanable/data", self.baseurl,);
        let mut query = Vec::with_capacity(5usize);
        if let Some(v) = &loan_coin {
            query.push(("loanCoin", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        if let Some(v) = &vip_level {
            query.push(("vipLevel", v.to_string()));
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get Collateral Asset Data (USER_DATA)

Get collateral asset data.

Weight(IP): 400

Sends a `GET` request to `/sapi/v1/loan/vip/collateral/data`

Arguments:
- `collateral_coin`: Coin used as collateral
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn loan_vip_collateral_data<'a>(
        &'a self,
        collateral_coin: Option<&'a str>,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::LoanVipCollateralDataResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/loan/vip/collateral/data", self.baseurl,);
        let mut query = Vec::with_capacity(4usize);
        if let Some(v) = &collateral_coin {
            query.push(("collateralCoin", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Query Application Status (USER_DATA)

Get Application Status

Weight(UID): 400

Sends a `GET` request to `/sapi/v1/loan/vip/request/data`

Arguments:
- `current`: Current querying page. Start from 1. Default:1
- `limit`: Default 500; max 1000.
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn loan_vip_request_data<'a>(
        &'a self,
        current: Option<i32>,
        limit: Option<i32>,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<ResponseValue<types::LoanVipRequestDataResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/loan/vip/request/data", self.baseurl,);
        let mut query = Vec::with_capacity(5usize);
        if let Some(v) = &current {
            query.push(("current", v.to_string()));
        }
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get Borrow Interest Rate (USER_DATA)

Get borrow interest rate.

Weight(UID): 400

Sends a `GET` request to `/sapi/v1/loan/vip/request/interestRate`

Arguments:
- `loan_coin`: Max 10 assets, Multiple split by ","
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn loan_vip_request_interest_rate<'a>(
        &'a self,
        loan_coin: Option<&'a str>,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<Vec<types::LoanVipRequestInterestRateResponseItem>>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/loan/vip/request/interestRate", self.baseurl,);
        let mut query = Vec::with_capacity(4usize);
        if let Some(v) = &loan_coin {
            query.push(("loanCoin", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**VIP Loan Renew

VIP loan is available for VIP users only.

Weight(UID): 6000

Sends a `POST` request to `/sapi/v1/loan/vip/renew`

Arguments:
- `loan_term`
- `order_id`: Order id
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn loan_vip_renew<'a>(
        &'a self,
        loan_term: Option<i64>,
        order_id: Option<i64>,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<ResponseValue<types::LoanVipRenewResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/loan/vip/renew", self.baseurl,);
        let mut query = Vec::with_capacity(5usize);
        if let Some(v) = &loan_term {
            query.push(("loanTerm", v.to_string()));
        }
        if let Some(v) = &order_id {
            query.push(("orderId", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get Crypto Loans Income History (USER_DATA)

- If startTime and endTime are not sent, the recent 7-day data will be returned.
- The max interval between startTime and endTime is 30 days.

Weight(UID): 6000

Sends a `GET` request to `/sapi/v1/loan/income`

Arguments:
- `asset`
- `end_time`: UTC timestamp in ms
- `limit`: default 20, max 100
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `start_time`: UTC timestamp in ms
- `timestamp`: UTC timestamp in ms
- `type_`: All types will be returned by default.
  * `borrowIn`
  * `collateralSpent`
  * `repayAmount`
  * `collateralReturn` - Collateral return after repayment
  * `addCollateral`
  * `removeCollateral`
  * `collateralReturnAfterLiquidation`
*/
    pub async fn loan_income<'a>(
        &'a self,
        asset: Option<&'a str>,
        end_time: Option<i64>,
        limit: Option<i32>,
        recv_window: Option<i64>,
        signature: &'a str,
        start_time: Option<i64>,
        timestamp: i64,
        type_: Option<types::LoanIncomeType>,
    ) -> Result<ResponseValue<Vec<types::LoanIncomeResponseItem>>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/loan/income", self.baseurl,);
        let mut query = Vec::with_capacity(8usize);
        if let Some(v) = &asset {
            query.push(("asset", v.to_string()));
        }
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        if let Some(v) = &type_ {
            query.push(("type", v.to_string()));
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Crypto Loan Borrow (TRADE)

Weight(UID): 6000

Sends a `POST` request to `/sapi/v1/loan/borrow`

Arguments:
- `collateral_amount`
- `collateral_coin`: Coin used as collateral
- `loan_amount`: Loan amount
- `loan_coin`: Coin loaned
- `loan_term`: 7/14/30/90/180 days
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn loan_borrow<'a>(
        &'a self,
        collateral_amount: Option<f32>,
        collateral_coin: &'a str,
        loan_amount: Option<f32>,
        loan_coin: &'a str,
        loan_term: i32,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<ResponseValue<types::LoanBorrowResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/loan/borrow", self.baseurl,);
        let mut query = Vec::with_capacity(8usize);
        if let Some(v) = &collateral_amount {
            query.push(("collateralAmount", v.to_string()));
        }
        query.push(("collateralCoin", collateral_coin.to_string()));
        if let Some(v) = &loan_amount {
            query.push(("loanAmount", v.to_string()));
        }
        query.push(("loanCoin", loan_coin.to_string()));
        query.push(("loanTerm", loan_term.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get Crypto Loans Borrow History (USER_DATA)

- If startTime and endTime are not sent, the recent 90-day data will be returned.
- The max interval between startTime and endTime is 180 days.

Weight(IP): 400

Sends a `GET` request to `/sapi/v1/loan/borrow/history`

Arguments:
- `collateral_coin`: Coin used as collateral
- `current`: Current querying page. Start from 1. Default:1
- `end_time`: UTC timestamp in ms
- `limit`: default 10, max 100
- `loan_coin`: Coin loaned
- `order_id`: orderId in POST /sapi/v1/loan/borrow
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `start_time`: UTC timestamp in ms
- `timestamp`: UTC timestamp in ms
*/
    pub async fn loan_borrow_history<'a>(
        &'a self,
        collateral_coin: Option<&'a str>,
        current: Option<i32>,
        end_time: Option<i64>,
        limit: Option<i64>,
        loan_coin: Option<&'a str>,
        order_id: Option<i64>,
        recv_window: Option<i64>,
        signature: &'a str,
        start_time: Option<i64>,
        timestamp: i64,
    ) -> Result<ResponseValue<types::LoanBorrowHistoryResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/loan/borrow/history", self.baseurl,);
        let mut query = Vec::with_capacity(10usize);
        if let Some(v) = &collateral_coin {
            query.push(("collateralCoin", v.to_string()));
        }
        if let Some(v) = &current {
            query.push(("current", v.to_string()));
        }
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }
        if let Some(v) = &loan_coin {
            query.push(("loanCoin", v.to_string()));
        }
        if let Some(v) = &order_id {
            query.push(("orderId", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get Loan Ongoing Orders (USER_DATA)

Weight(IP): 300

Sends a `GET` request to `/sapi/v1/loan/ongoing/orders`

Arguments:
- `collateral_coin`: Coin used as collateral
- `current`: Current querying page. Start from 1; default:1, max:1000
- `limit`: default 10, max 100
- `loan_coin`: Coin loaned
- `order_id`: orderId in POST /sapi/v1/loan/borrow
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn loan_ongoing_orders<'a>(
        &'a self,
        collateral_coin: Option<&'a str>,
        current: Option<i32>,
        limit: Option<i64>,
        loan_coin: Option<&'a str>,
        order_id: Option<i64>,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<ResponseValue<types::LoanOngoingOrdersResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/loan/ongoing/orders", self.baseurl,);
        let mut query = Vec::with_capacity(8usize);
        if let Some(v) = &collateral_coin {
            query.push(("collateralCoin", v.to_string()));
        }
        if let Some(v) = &current {
            query.push(("current", v.to_string()));
        }
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }
        if let Some(v) = &loan_coin {
            query.push(("loanCoin", v.to_string()));
        }
        if let Some(v) = &order_id {
            query.push(("orderId", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Crypto Loan Repay (TRADE)

Weight(UID): 6000

Sends a `POST` request to `/sapi/v1/loan/repay`

Arguments:
- `amount`: Repayment Amount
- `collateral_return`: Default: TRUE. TRUE: Return extra collateral to spot account; FALSE: Keep extra collateral in the order.
- `order_id`: Order ID
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
- `type_`: Default: 1. 1 for 'repay with borrowed coin'; 2 for 'repay with collateral'.
*/
    pub async fn loan_repay<'a>(
        &'a self,
        amount: f64,
        collateral_return: Option<bool>,
        order_id: i64,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
        type_: Option<i32>,
    ) -> Result<ResponseValue<types::LoanRepayResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/loan/repay", self.baseurl,);
        let mut query = Vec::with_capacity(7usize);
        query.push(("amount", amount.to_string()));
        if let Some(v) = &collateral_return {
            query.push(("collateralReturn", v.to_string()));
        }
        query.push(("orderId", order_id.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        if let Some(v) = &type_ {
            query.push(("type", v.to_string()));
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get Loan Repayment History (USER_DATA)

If startTime and endTime are not sent, the recent 90-day data will be returned.
The max interval between startTime and endTime is 180 days.

Weight(IP): 400

Sends a `GET` request to `/sapi/v1/loan/repay/history`

Arguments:
- `collateral_coin`: Coin used as collateral
- `current`: Current querying page. Start from 1. Default:1
- `end_time`: UTC timestamp in ms
- `limit`: default 10, max 100
- `loan_coin`: Coin loaned
- `order_id`: Order ID
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `start_time`: UTC timestamp in ms
- `timestamp`: UTC timestamp in ms
*/
    pub async fn loan_repay_history<'a>(
        &'a self,
        collateral_coin: Option<&'a str>,
        current: Option<i32>,
        end_time: Option<i64>,
        limit: Option<i64>,
        loan_coin: Option<&'a str>,
        order_id: Option<i64>,
        recv_window: Option<i64>,
        signature: &'a str,
        start_time: Option<i64>,
        timestamp: i64,
    ) -> Result<ResponseValue<types::LoanRepayHistoryResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/loan/repay/history", self.baseurl,);
        let mut query = Vec::with_capacity(10usize);
        if let Some(v) = &collateral_coin {
            query.push(("collateralCoin", v.to_string()));
        }
        if let Some(v) = &current {
            query.push(("current", v.to_string()));
        }
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }
        if let Some(v) = &loan_coin {
            query.push(("loanCoin", v.to_string()));
        }
        if let Some(v) = &order_id {
            query.push(("orderId", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Crypto Loan Adjust LTV (TRADE)

Weight(UID): 6000

Sends a `POST` request to `/sapi/v1/loan/adjust/ltv`

Arguments:
- `amount`: Amount
- `direction`: 'ADDITIONAL', 'REDUCED'
- `order_id`: Order ID
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn loan_adjust_ltv<'a>(
        &'a self,
        amount: f64,
        direction: types::LoanAdjustLtvDirection,
        order_id: i64,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<ResponseValue<types::LoanAdjustLtvResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/loan/adjust/ltv", self.baseurl,);
        let mut query = Vec::with_capacity(6usize);
        query.push(("amount", amount.to_string()));
        query.push(("direction", direction.to_string()));
        query.push(("orderId", order_id.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get Loan LTV Adjustment History (USER_DATA)

If startTime and endTime are not sent, the recent 90-day data will be returned.
The max interval between startTime and endTime is 180 days.

Weight(IP): 400

Sends a `GET` request to `/sapi/v1/loan/ltv/adjustment/history`

Arguments:
- `collateral_coin`: Coin used as collateral
- `current`: Current querying page. Start from 1. Default:1
- `end_time`: UTC timestamp in ms
- `limit`: default 10, max 100
- `loan_coin`: Coin loaned
- `order_id`: Order ID
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `start_time`: UTC timestamp in ms
- `timestamp`: UTC timestamp in ms
*/
    pub async fn loan_ltv_adjustment_history<'a>(
        &'a self,
        collateral_coin: Option<&'a str>,
        current: Option<i32>,
        end_time: Option<i64>,
        limit: Option<i64>,
        loan_coin: Option<&'a str>,
        order_id: Option<i64>,
        recv_window: Option<i64>,
        signature: &'a str,
        start_time: Option<i64>,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::LoanLtvAdjustmentHistoryResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/loan/ltv/adjustment/history", self.baseurl,);
        let mut query = Vec::with_capacity(10usize);
        if let Some(v) = &collateral_coin {
            query.push(("collateralCoin", v.to_string()));
        }
        if let Some(v) = &current {
            query.push(("current", v.to_string()));
        }
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }
        if let Some(v) = &loan_coin {
            query.push(("loanCoin", v.to_string()));
        }
        if let Some(v) = &order_id {
            query.push(("orderId", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get Loanable Assets Data (USER_DATA)

Get interest rate and borrow limit of loanable assets. The borrow limit is shown in USD value.

Weight(IP): 400

Sends a `GET` request to `/sapi/v1/loan/loanable/data`

Arguments:
- `loan_coin`: Coin loaned
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
- `vip_level`: Defaults to user's vip level
*/
    pub async fn loan_loanable_data<'a>(
        &'a self,
        loan_coin: Option<&'a str>,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
        vip_level: Option<i32>,
    ) -> Result<ResponseValue<types::LoanLoanableDataResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/loan/loanable/data", self.baseurl,);
        let mut query = Vec::with_capacity(5usize);
        if let Some(v) = &loan_coin {
            query.push(("loanCoin", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        if let Some(v) = &vip_level {
            query.push(("vipLevel", v.to_string()));
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get Collateral Assets Data (USER_DATA)

Get LTV information and collateral limit of collateral assets. The collateral limit is shown in USD value.

Weight(IP): 400

Sends a `GET` request to `/sapi/v1/loan/collateral/data`

Arguments:
- `collateral_coin`: Coin used as collateral
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
- `vip_level`: Defaults to user's vip level
*/
    pub async fn loan_collateral_data<'a>(
        &'a self,
        collateral_coin: Option<&'a str>,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
        vip_level: Option<i32>,
    ) -> Result<ResponseValue<types::LoanCollateralDataResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/loan/collateral/data", self.baseurl,);
        let mut query = Vec::with_capacity(5usize);
        if let Some(v) = &collateral_coin {
            query.push(("collateralCoin", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        if let Some(v) = &vip_level {
            query.push(("vipLevel", v.to_string()));
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Check Collateral Repay Rate (USER_DATA)

Get the the rate of collateral coin / loan coin when using collateral repay, the rate will be valid within 8 second.

Weight(IP): 6000

Sends a `GET` request to `/sapi/v1/loan/repay/collateral/rate`

Arguments:
- `collateral_coin`: Coin used as collateral
- `loan_coin`: Coin loaned
- `recv_window`: The value cannot be greater than 60000
- `repay_amount`: repay amount of loanCoin
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn loan_repay_collateral_rate<'a>(
        &'a self,
        collateral_coin: &'a str,
        loan_coin: &'a str,
        recv_window: Option<i64>,
        repay_amount: f32,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::LoanRepayCollateralRateResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/loan/repay/collateral/rate", self.baseurl,);
        let mut query = Vec::with_capacity(6usize);
        query.push(("collateralCoin", collateral_coin.to_string()));
        query.push(("loanCoin", loan_coin.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("repayAmount", repay_amount.to_string()));
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Crypto Loan Customize Margin Call (TRADE)

Customize margin call for ongoing orders only.

Weight(UID): 6000

Sends a `POST` request to `/sapi/v1/loan/customize/margin_call`

Arguments:
- `collateral_coin`: Coin used as collateral
- `margin_call`
- `order_id`: Mandatory when collateralCoin is empty. Send either orderId or collateralCoin, if both parameters are sent, take orderId only.
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn loan_customize_margin_call<'a>(
        &'a self,
        collateral_coin: Option<&'a str>,
        margin_call: f32,
        order_id: Option<i64>,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::LoanCustomizeMarginCallResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/loan/customize/margin_call", self.baseurl,);
        let mut query = Vec::with_capacity(6usize);
        if let Some(v) = &collateral_coin {
            query.push(("collateralCoin", v.to_string()));
        }
        query.push(("marginCall", margin_call.to_string()));
        if let Some(v) = &order_id {
            query.push(("orderId", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Borrow - Flexible Loan Borrow (TRADE)


Weight(UID): 6000

Sends a `POST` request to `/sapi/v1/loan/flexible/borrow`

Arguments:
- `collateral_amount`
- `collateral_coin`: Coin used as collateral
- `loan_amount`: Loan amount
- `loan_coin`: Coin loaned
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn loan_flexible_borrow<'a>(
        &'a self,
        collateral_amount: Option<f32>,
        collateral_coin: Option<&'a str>,
        loan_amount: Option<f32>,
        loan_coin: Option<&'a str>,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<ResponseValue<types::LoanFlexibleBorrowResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/loan/flexible/borrow", self.baseurl,);
        let mut query = Vec::with_capacity(7usize);
        if let Some(v) = &collateral_amount {
            query.push(("collateralAmount", v.to_string()));
        }
        if let Some(v) = &collateral_coin {
            query.push(("collateralCoin", v.to_string()));
        }
        if let Some(v) = &loan_amount {
            query.push(("loanAmount", v.to_string()));
        }
        if let Some(v) = &loan_coin {
            query.push(("loanCoin", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Borrow - Get Flexible Loan Ongoing Orders (USER_DATA)


Weight(IP): 300

Sends a `GET` request to `/sapi/v1/loan/flexible/ongoing/orders`

Arguments:
- `collateral_coin`: Coin used as collateral
- `current`: Current querying page. Start from 1. Default:1
- `limit`: Default 500; max 1000.
- `loan_coin`: Coin loaned
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn loan_flexible_ongoing_orders<'a>(
        &'a self,
        collateral_coin: Option<&'a str>,
        current: Option<i32>,
        limit: Option<i32>,
        loan_coin: Option<&'a str>,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::LoanFlexibleOngoingOrdersResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/loan/flexible/ongoing/orders", self.baseurl,);
        let mut query = Vec::with_capacity(7usize);
        if let Some(v) = &collateral_coin {
            query.push(("collateralCoin", v.to_string()));
        }
        if let Some(v) = &current {
            query.push(("current", v.to_string()));
        }
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }
        if let Some(v) = &loan_coin {
            query.push(("loanCoin", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Borrow - Get Flexible Loan Borrow History (USER_DATA)


Weight(IP): 400

Sends a `GET` request to `/sapi/v1/loan/flexible/borrow/history`

Arguments:
- `collateral_coin`: Coin used as collateral
- `current`: Current querying page. Start from 1. Default:1
- `end_time`: UTC timestamp in ms
- `limit`: Default 500; max 1000.
- `loan_coin`: Coin loaned
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `start_time`: UTC timestamp in ms
- `timestamp`: UTC timestamp in ms
*/
    pub async fn loan_flexible_borrow_history<'a>(
        &'a self,
        collateral_coin: Option<&'a str>,
        current: Option<i32>,
        end_time: Option<i64>,
        limit: Option<i32>,
        loan_coin: Option<&'a str>,
        recv_window: Option<i64>,
        signature: &'a str,
        start_time: Option<i64>,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::LoanFlexibleBorrowHistoryResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/loan/flexible/borrow/history", self.baseurl,);
        let mut query = Vec::with_capacity(9usize);
        if let Some(v) = &collateral_coin {
            query.push(("collateralCoin", v.to_string()));
        }
        if let Some(v) = &current {
            query.push(("current", v.to_string()));
        }
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }
        if let Some(v) = &loan_coin {
            query.push(("loanCoin", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Repay - Flexible Loan Repay (TRADE)


Weight(IP): 6000

Sends a `POST` request to `/sapi/v1/loan/flexible/repay`

Arguments:
- `collateral_coin`: Coin used as collateral
- `collateral_return`
- `full_repayment`
- `loan_coin`: Coin loaned
- `recv_window`: The value cannot be greater than 60000
- `repay_amount`: repay amount of loanCoin
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn loan_flexible_repay<'a>(
        &'a self,
        collateral_coin: Option<&'a str>,
        collateral_return: Option<bool>,
        full_repayment: Option<bool>,
        loan_coin: Option<&'a str>,
        recv_window: Option<i64>,
        repay_amount: f32,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<ResponseValue<types::LoanFlexibleRepayResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/loan/flexible/repay", self.baseurl,);
        let mut query = Vec::with_capacity(8usize);
        if let Some(v) = &collateral_coin {
            query.push(("collateralCoin", v.to_string()));
        }
        if let Some(v) = &collateral_return {
            query.push(("collateralReturn", v.to_string()));
        }
        if let Some(v) = &full_repayment {
            query.push(("fullRepayment", v.to_string()));
        }
        if let Some(v) = &loan_coin {
            query.push(("loanCoin", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("repayAmount", repay_amount.to_string()));
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Repay - Get Flexible Loan Repayment History (USER_DATA)


Weight(IP): 400

Sends a `GET` request to `/sapi/v1/loan/flexible/repay/history`

Arguments:
- `collateral_coin`: Coin used as collateral
- `current`: Current querying page. Start from 1. Default:1
- `end_time`: UTC timestamp in ms
- `limit`: Default 500; max 1000.
- `loan_coin`: Coin loaned
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `start_time`: UTC timestamp in ms
- `timestamp`: UTC timestamp in ms
*/
    pub async fn loan_flexible_repay_history<'a>(
        &'a self,
        collateral_coin: Option<&'a str>,
        current: Option<i32>,
        end_time: Option<i64>,
        limit: Option<i32>,
        loan_coin: Option<&'a str>,
        recv_window: Option<i64>,
        signature: &'a str,
        start_time: Option<i64>,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::LoanFlexibleRepayHistoryResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/loan/flexible/repay/history", self.baseurl,);
        let mut query = Vec::with_capacity(9usize);
        if let Some(v) = &collateral_coin {
            query.push(("collateralCoin", v.to_string()));
        }
        if let Some(v) = &current {
            query.push(("current", v.to_string()));
        }
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }
        if let Some(v) = &loan_coin {
            query.push(("loanCoin", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Adjust LTV - Flexible Loan Adjust LTV (TRADE)


Weight(UID): 6000

Sends a `POST` request to `/sapi/v1/loan/flexible/adjust/ltv`

Arguments:
- `adjustment_amount`
- `collateral_coin`: Coin used as collateral
- `direction`
- `loan_coin`: Coin loaned
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn loan_flexible_adjust_ltv<'a>(
        &'a self,
        adjustment_amount: f32,
        collateral_coin: Option<&'a str>,
        direction: types::LoanFlexibleAdjustLtvDirection,
        loan_coin: Option<&'a str>,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::LoanFlexibleAdjustLtvResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/loan/flexible/adjust/ltv", self.baseurl,);
        let mut query = Vec::with_capacity(7usize);
        query.push(("adjustmentAmount", adjustment_amount.to_string()));
        if let Some(v) = &collateral_coin {
            query.push(("collateralCoin", v.to_string()));
        }
        query.push(("direction", direction.to_string()));
        if let Some(v) = &loan_coin {
            query.push(("loanCoin", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Adjust LTV - Get Flexible Loan LTV Adjustment History (USER_DATA)


Weight(IP): 400

Sends a `GET` request to `/sapi/v1/loan/flexible/ltv/adjustment/history`

Arguments:
- `collateral_coin`: Coin used as collateral
- `current`: Current querying page. Start from 1. Default:1
- `end_time`: UTC timestamp in ms
- `limit`: Default 500; max 1000.
- `loan_coin`: Coin loaned
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `start_time`: UTC timestamp in ms
- `timestamp`: UTC timestamp in ms
*/
    pub async fn loan_flexible_ltv_adjustment_history<'a>(
        &'a self,
        collateral_coin: Option<&'a str>,
        current: Option<i32>,
        end_time: Option<i64>,
        limit: Option<i32>,
        loan_coin: Option<&'a str>,
        recv_window: Option<i64>,
        signature: &'a str,
        start_time: Option<i64>,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::LoanFlexibleLtvAdjustmentHistoryResponse>,
        Error<types::Error>,
    > {
        let url = format!(
            "{}/sapi/v1/loan/flexible/ltv/adjustment/history", self.baseurl,
        );
        let mut query = Vec::with_capacity(9usize);
        if let Some(v) = &collateral_coin {
            query.push(("collateralCoin", v.to_string()));
        }
        if let Some(v) = &current {
            query.push(("current", v.to_string()));
        }
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }
        if let Some(v) = &loan_coin {
            query.push(("loanCoin", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get Flexible Loan Assets Data (USER_DATA)

Get interest rate and borrow limit of flexible loanable assets. The borrow limit is shown in USD value.

Weight(IP): 400

Sends a `GET` request to `/sapi/v1/loan/flexible/loanable/data`

Arguments:
- `loan_coin`: Coin loaned
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn loan_flexible_loanable_data<'a>(
        &'a self,
        loan_coin: Option<&'a str>,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::LoanFlexibleLoanableDataResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/loan/flexible/loanable/data", self.baseurl,);
        let mut query = Vec::with_capacity(4usize);
        if let Some(v) = &loan_coin {
            query.push(("loanCoin", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get Flexible Loan Collateral Assets Data (USER_DATA)

Get LTV information and collateral limit of flexible loan's collateral assets. The collateral limit is shown in USD value.

Weight(IP): 400

Sends a `GET` request to `/sapi/v1/loan/flexible/collateral/data`

Arguments:
- `collateral_coin`: Coin used as collateral
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn loan_flexible_collateral_data<'a>(
        &'a self,
        collateral_coin: Option<&'a str>,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::LoanFlexibleCollateralDataResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/loan/flexible/collateral/data", self.baseurl,);
        let mut query = Vec::with_capacity(4usize);
        if let Some(v) = &collateral_coin {
            query.push(("collateralCoin", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get Pay Trade History (USER_DATA)

- If startTime and endTime are not sent, the recent 90 days' data will be returned.
- The max interval between startTime and endTime is 90 days.
- Support for querying orders within the last 18 months.

Weight(UID): 3000

Sends a `GET` request to `/sapi/v1/pay/transactions`

Arguments:
- `end_time`: UTC timestamp in ms
- `limit`: default 100, max 100
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `start_time`: UTC timestamp in ms
- `timestamp`: UTC timestamp in ms
*/
    pub async fn pay_transactions<'a>(
        &'a self,
        end_time: Option<i64>,
        limit: Option<i32>,
        recv_window: Option<i64>,
        signature: &'a str,
        start_time: Option<i64>,
        timestamp: i64,
    ) -> Result<ResponseValue<types::PayTransactionsResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/pay/transactions", self.baseurl,);
        let mut query = Vec::with_capacity(6usize);
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**List All Convert Pairs

Query for all convertible token pairs and the tokens respective upper/lower limits

Weight(IP): 3000

Sends a `GET` request to `/sapi/v1/convert/exchangeInfo`

Arguments:
- `from_asset`: User spends coin
- `to_asset`: User receives coin
*/
    pub async fn convert_exchange_info<'a>(
        &'a self,
        from_asset: Option<&'a str>,
        to_asset: Option<&'a str>,
    ) -> Result<
        ResponseValue<Vec<types::ConvertExchangeInfoResponseItem>>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/convert/exchangeInfo", self.baseurl,);
        let mut query = Vec::with_capacity(2usize);
        if let Some(v) = &from_asset {
            query.push(("fromAsset", v.to_string()));
        }
        if let Some(v) = &to_asset {
            query.push(("toAsset", v.to_string()));
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Query order quantity precision per asset (USER_DATA)

Query for supported asset precision information

Weight(IP): 100

Sends a `GET` request to `/sapi/v1/convert/assetInfo`

Arguments:
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn convert_asset_info<'a>(
        &'a self,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<Vec<types::ConvertAssetInfoResponseItem>>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/convert/assetInfo", self.baseurl,);
        let mut query = Vec::with_capacity(3usize);
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Send quote request (USER_DATA)

Request a quote for the requested token pairs

Weight(UID): 200

Sends a `POST` request to `/sapi/v1/convert/getQuote`

Arguments:
- `from_amount`: When specified, it is the amount you will be debited after the conversion
- `from_asset`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
- `to_amount`: When specified, it is the amount you will be debited after the conversion
- `to_asset`
- `valid_time`: 10s, 30s, 1m, 2m, default 10s
- `wallet_type`: SPOT or FUNDING. Default is SPOT
*/
    pub async fn convert_get_quote<'a>(
        &'a self,
        from_amount: Option<f32>,
        from_asset: &'a str,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
        to_amount: Option<f32>,
        to_asset: &'a str,
        valid_time: Option<&'a str>,
        wallet_type: Option<&'a str>,
    ) -> Result<ResponseValue<types::ConvertGetQuoteResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/convert/getQuote", self.baseurl,);
        let mut query = Vec::with_capacity(9usize);
        if let Some(v) = &from_amount {
            query.push(("fromAmount", v.to_string()));
        }
        query.push(("fromAsset", from_asset.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        if let Some(v) = &to_amount {
            query.push(("toAmount", v.to_string()));
        }
        query.push(("toAsset", to_asset.to_string()));
        if let Some(v) = &valid_time {
            query.push(("validTime", v.to_string()));
        }
        if let Some(v) = &wallet_type {
            query.push(("walletType", v.to_string()));
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Accept Quote (TRADE)

Accept the offered quote by quote ID.

Weight(UID): 500

Sends a `POST` request to `/sapi/v1/convert/acceptQuote`

Arguments:
- `quote_id`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn convert_accept_quote<'a>(
        &'a self,
        quote_id: &'a str,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<ResponseValue<types::ConvertAcceptQuoteResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/convert/acceptQuote", self.baseurl,);
        let mut query = Vec::with_capacity(4usize);
        query.push(("quoteId", quote_id.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Order status (USER_DATA)

Query order status by order ID.

Weight(UID): 100

Sends a `GET` request to `/sapi/v1/convert/orderStatus`

Arguments:
- `order_id`
- `quote_id`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn convert_order_status<'a>(
        &'a self,
        order_id: Option<&'a str>,
        quote_id: Option<&'a str>,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<ResponseValue<types::ConvertOrderStatusResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/convert/orderStatus", self.baseurl,);
        let mut query = Vec::with_capacity(5usize);
        if let Some(v) = &order_id {
            query.push(("orderId", v.to_string()));
        }
        if let Some(v) = &quote_id {
            query.push(("quoteId", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get Convert Trade History (USER_DATA)

- The max interval between startTime and endTime is 30 days.

Weight(UID): 3000

Sends a `GET` request to `/sapi/v1/convert/tradeFlow`

Arguments:
- `end_time`: UTC timestamp in ms
- `limit`: default 100, max 1000
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `start_time`: UTC timestamp in ms
- `timestamp`: UTC timestamp in ms
*/
    pub async fn convert_trade_flow<'a>(
        &'a self,
        end_time: i64,
        limit: Option<i32>,
        recv_window: Option<i64>,
        signature: &'a str,
        start_time: i64,
        timestamp: i64,
    ) -> Result<ResponseValue<types::ConvertTradeFlowResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/convert/tradeFlow", self.baseurl,);
        let mut query = Vec::with_capacity(6usize);
        query.push(("endTime", end_time.to_string()));
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("startTime", start_time.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get Spot Rebate History Records (USER_DATA)

- The max interval between startTime and endTime is 90 days.
- If startTime and endTime are not sent, the recent 7 days' data will be returned.
- The earliest startTime is supported on June 10, 2020

Weight(UID): 3000

Sends a `GET` request to `/sapi/v1/rebate/taxQuery`

Arguments:
- `end_time`: UTC timestamp in ms
- `page`: default 1
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `start_time`: UTC timestamp in ms
- `timestamp`: UTC timestamp in ms
*/
    pub async fn rebate_tax_query<'a>(
        &'a self,
        end_time: Option<i64>,
        page: Option<i32>,
        recv_window: Option<i64>,
        signature: &'a str,
        start_time: Option<i64>,
        timestamp: i64,
    ) -> Result<ResponseValue<types::RebateTaxQueryResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/rebate/taxQuery", self.baseurl,);
        let mut query = Vec::with_capacity(6usize);
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        if let Some(v) = &page {
            query.push(("page", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get NFT Transaction History (USER_DATA)

- The max interval between startTime and endTime is 90 days.
- If startTime and endTime are not sent, the recent 7 days' data will be returned.

Weight(UID): 3000

Sends a `GET` request to `/sapi/v1/nft/history/transactions`

Arguments:
- `end_time`: UTC timestamp in ms
- `limit`: Default 50, Max 50
- `order_type`: 0: purchase order, 1: sell order, 2: royalty income, 3: primary market order, 4: mint fee
- `page`: Default 1
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `start_time`: UTC timestamp in ms
- `timestamp`: UTC timestamp in ms
*/
    pub async fn nft_history_transactions<'a>(
        &'a self,
        end_time: Option<i64>,
        limit: Option<i32>,
        order_type: i32,
        page: Option<i32>,
        recv_window: Option<i64>,
        signature: &'a str,
        start_time: Option<i64>,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::NftHistoryTransactionsResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/nft/history/transactions", self.baseurl,);
        let mut query = Vec::with_capacity(8usize);
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }
        query.push(("orderType", order_type.to_string()));
        if let Some(v) = &page {
            query.push(("page", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get NFT Deposit History(USER_DATA)

- The max interval between startTime and endTime is 90 days.
- If startTime and endTime are not sent, the recent 7 days' data will be returned.

Weight(UID): 3000

Sends a `GET` request to `/sapi/v1/nft/history/deposit`

Arguments:
- `end_time`: UTC timestamp in ms
- `limit`: Default 50, Max 50
- `page`: Default 1
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `start_time`: UTC timestamp in ms
- `timestamp`: UTC timestamp in ms
*/
    pub async fn nft_history_deposit<'a>(
        &'a self,
        end_time: Option<i64>,
        limit: Option<i32>,
        page: Option<i32>,
        recv_window: Option<i64>,
        signature: &'a str,
        start_time: Option<i64>,
        timestamp: i64,
    ) -> Result<ResponseValue<types::NftHistoryDepositResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/nft/history/deposit", self.baseurl,);
        let mut query = Vec::with_capacity(7usize);
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }
        if let Some(v) = &page {
            query.push(("page", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get NFT Withdraw History (USER_DATA)

- The max interval between startTime and endTime is 90 days.
- If startTime and endTime are not sent, the recent 7 days' data will be returned.

Weight(UID): 3000

Sends a `GET` request to `/sapi/v1/nft/history/withdraw`

Arguments:
- `end_time`: UTC timestamp in ms
- `limit`: Default 50, Max 50
- `page`: Default 1
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `start_time`: UTC timestamp in ms
- `timestamp`: UTC timestamp in ms
*/
    pub async fn nft_history_withdraw<'a>(
        &'a self,
        end_time: Option<i64>,
        limit: Option<i32>,
        page: Option<i32>,
        recv_window: Option<i64>,
        signature: &'a str,
        start_time: Option<i64>,
        timestamp: i64,
    ) -> Result<ResponseValue<types::NftHistoryWithdrawResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/nft/history/withdraw", self.baseurl,);
        let mut query = Vec::with_capacity(7usize);
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }
        if let Some(v) = &page {
            query.push(("page", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get NFT Asset (USER_DATA)

Weight(UID): 3000

Sends a `GET` request to `/sapi/v1/nft/user/getAsset`

Arguments:
- `limit`: Default 50, Max 50
- `page`: Default 1
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn nft_user_get_asset<'a>(
        &'a self,
        limit: Option<i32>,
        page: Option<i32>,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<ResponseValue<types::NftUserGetAssetResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/nft/user/getAsset", self.baseurl,);
        let mut query = Vec::with_capacity(5usize);
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }
        if let Some(v) = &page {
            query.push(("page", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Create a Binance Code (USER_DATA)

This API is for creating a Binance Code. To get started with, please make sure:

- You have a Binance account
- You have passed kyc
- You have a sufficient balance in your Binance funding wallet
- You need Enable Withdrawals for the API Key which requests this endpoint.

Daily creation volume: 2 BTC / 24H Daily creation times: 200 Codes / 24H

Weight(IP): 1

Sends a `POST` request to `/sapi/v1/giftcard/createCode`

Arguments:
- `amount`: The amount of the coin
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
- `token`: The coin type contained in the Binance Code
*/
    pub async fn giftcard_create_code<'a>(
        &'a self,
        amount: f64,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
        token: &'a str,
    ) -> Result<ResponseValue<types::GiftcardCreateCodeResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/giftcard/createCode", self.baseurl,);
        let mut query = Vec::with_capacity(5usize);
        query.push(("amount", amount.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        query.push(("token", token.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Redeem a Binance Code (USER_DATA)

This API is for redeeming the Binance Code. Once redeemed, the coins will be deposited in your funding wallet.

Please note that if you enter the wrong code 5 times within 24 hours, you will no longer be able to redeem any Binance Code that day.

Weight(IP): 1

Sends a `POST` request to `/sapi/v1/giftcard/redeemCode`

Arguments:
- `code`: Binance Code
- `external_uid`: Each external unique ID represents a unique user on the partner platform. The function helps you to identify the redemption behavior of different users, such as redemption frequency and amount. It also helps risk and limit control of a single account, such as daily limit on redemption volume, frequency, and incorrect number of entries. This will also prevent a single user account reach the partner's daily redemption limits. We strongly recommend you to use this feature and transfer us the User ID of your users if you have different users redeeming Binance codes on your platform. To protect user data privacy, you may choose to transfer the user id in any desired format (max. 400 characters).
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn giftcard_redeem_code<'a>(
        &'a self,
        code: &'a str,
        external_uid: Option<&'a str>,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<ResponseValue<types::GiftcardRedeemCodeResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/giftcard/redeemCode", self.baseurl,);
        let mut query = Vec::with_capacity(5usize);
        query.push(("code", code.to_string()));
        if let Some(v) = &external_uid {
            query.push(("externalUid", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Verify a Binance Code (USER_DATA)

This API is for verifying whether the Binance Code is valid or not by entering Binance Code or reference number.

Please note that if you enter the wrong binance code 5 times within an hour, you will no longer be able to verify any binance code for that hour.

Weight(IP): 1

Sends a `GET` request to `/sapi/v1/giftcard/verify`

Arguments:
- `recv_window`: The value cannot be greater than 60000
- `reference_no`: reference number
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn giftcard_verify<'a>(
        &'a self,
        recv_window: Option<i64>,
        reference_no: &'a str,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<ResponseValue<types::GiftcardVerifyResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/giftcard/verify", self.baseurl,);
        let mut query = Vec::with_capacity(4usize);
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("referenceNo", reference_no.to_string()));
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Fetch RSA Public Key (USER_DATA)

This API is for fetching the RSA Public Key.
This RSA Public key will be used to encrypt the card code.
Please note that the RSA Public key fetched is valid only for the current day.

Weight(IP): 1

Sends a `GET` request to `/sapi/v1/giftcard/cryptography/rsa-public-key`

Arguments:
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn giftcard_cryptography_rsa_public_key<'a>(
        &'a self,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::GiftcardCryptographyRsaPublicKeyResponse>,
        Error<types::Error>,
    > {
        let url = format!(
            "{}/sapi/v1/giftcard/cryptography/rsa-public-key", self.baseurl,
        );
        let mut query = Vec::with_capacity(3usize);
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Buy a Binance Code (TRADE)

This API is for buying a fixed-value Binance Code, which means your Binance Code will be redeemable to a token that is different to the token that you are paying in. If the token youre paying and the redeemable token are the same, please use the Create Binance Code endpoint.
You can use supported crypto currency or fiat token as baseToken to buy Binance Code that is redeemable to your chosen faceToken.
Once successfully purchased, the amount of baseToken would be deducted from your funding wallet.

To get started with, please make sure:
- You have a Binance account
- You have passed kyc
- You have a sufficient balance in your Binance funding wallet
- You need Enable Withdrawals for the API Key which requests this endpoint.

Daily creation volume: 2 BTC / 24H Daily creation times: 200 Codes / 24H

Weight(IP): 1

Sends a `POST` request to `/sapi/v1/giftcard/buyCode`

Arguments:
- `base_token`: The token you want to pay, example BUSD
- `base_token_amount`: The base token asset quantity, example  1.002
- `face_token`: The token you want to buy, example BNB. If faceToken = baseToken, it's the same as createCode endpoint.
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn giftcard_buy_code<'a>(
        &'a self,
        base_token: &'a str,
        base_token_amount: f64,
        face_token: &'a str,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<ResponseValue<types::GiftcardBuyCodeResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/giftcard/buyCode", self.baseurl,);
        let mut query = Vec::with_capacity(6usize);
        query.push(("baseToken", base_token.to_string()));
        query.push(("baseTokenAmount", base_token_amount.to_string()));
        query.push(("faceToken", face_token.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Fetch Token Limit (USER_DATA)

This API is to help you verify which tokens are available for you to purchase fixed-value gift cards as mentioned in section 2 and it's limitation.

Weight(IP): 1

Sends a `GET` request to `/sapi/v1/giftcard/buyCode/token-limit`

Arguments:
- `base_token`: The token you want to pay, example BUSD
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn giftcard_buy_code_token_limit<'a>(
        &'a self,
        base_token: &'a str,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::GiftcardBuyCodeTokenLimitResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/giftcard/buyCode/token-limit", self.baseurl,);
        let mut query = Vec::with_capacity(4usize);
        query.push(("baseToken", base_token.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get target asset list (USER_DATA)

Weight(IP): 1

Sends a `GET` request to `/sapi/v1/lending/auto-invest/target-asset/list`

Arguments:
- `current`: Current querying page. Start from 1. Default:1
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `size`: Default:10 Max:100
- `target_asset`
- `timestamp`: UTC timestamp in ms
*/
    pub async fn lending_auto_invest_target_asset_list<'a>(
        &'a self,
        current: Option<i32>,
        recv_window: Option<i64>,
        signature: &'a str,
        size: Option<i32>,
        target_asset: Option<&'a str>,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::LendingAutoInvestTargetAssetListResponse>,
        Error<types::Error>,
    > {
        let url = format!(
            "{}/sapi/v1/lending/auto-invest/target-asset/list", self.baseurl,
        );
        let mut query = Vec::with_capacity(6usize);
        if let Some(v) = &current {
            query.push(("current", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &size {
            query.push(("size", v.to_string()));
        }
        if let Some(v) = &target_asset {
            query.push(("targetAsset", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get target asset ROI data (USER_DATA)

ROI return list for target asset

Weight(IP): 1

Sends a `GET` request to `/sapi/v1/lending/auto-invest/target-asset/roi/list`

Arguments:
- `his_roi_type`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `target_asset`
- `timestamp`: UTC timestamp in ms
*/
    pub async fn lending_auto_invest_target_asset_roi_list<'a>(
        &'a self,
        his_roi_type: &'a str,
        recv_window: Option<i64>,
        signature: &'a str,
        target_asset: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<Vec<types::LendingAutoInvestTargetAssetRoiListResponseItem>>,
        Error<types::Error>,
    > {
        let url = format!(
            "{}/sapi/v1/lending/auto-invest/target-asset/roi/list", self.baseurl,
        );
        let mut query = Vec::with_capacity(5usize);
        query.push(("hisRoiType", his_roi_type.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("targetAsset", target_asset.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Query all source asset and target asset (USER_DATA)

Query all source assets and target assets

Weight(IP): 1

Sends a `GET` request to `/sapi/v1/lending/auto-invest/all/asset`

Arguments:
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn lending_auto_invest_all_asset<'a>(
        &'a self,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::LendingAutoInvestAllAssetResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/lending/auto-invest/all/asset", self.baseurl,);
        let mut query = Vec::with_capacity(3usize);
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Query source asset list (USER_DATA)

Query Source Asset to be used for investment

Weight(IP): 1

Sends a `GET` request to `/sapi/v1/lending/auto-invest/source-asset/list`

Arguments:
- `flexible_allowed_to_use`
- `index_id`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `target_asset`
- `timestamp`: UTC timestamp in ms
- `usage_type`
*/
    pub async fn lending_auto_invest_source_asset_list<'a>(
        &'a self,
        flexible_allowed_to_use: Option<bool>,
        index_id: Option<i64>,
        recv_window: Option<i64>,
        signature: &'a str,
        target_asset: Option<&'a str>,
        timestamp: i64,
        usage_type: &'a str,
    ) -> Result<
        ResponseValue<types::LendingAutoInvestSourceAssetListResponse>,
        Error<types::Error>,
    > {
        let url = format!(
            "{}/sapi/v1/lending/auto-invest/source-asset/list", self.baseurl,
        );
        let mut query = Vec::with_capacity(7usize);
        if let Some(v) = &flexible_allowed_to_use {
            query.push(("flexibleAllowedToUse", v.to_string()));
        }
        if let Some(v) = &index_id {
            query.push(("indexId", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &target_asset {
            query.push(("targetAsset", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        query.push(("usageType", usage_type.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get Simple Earn Flexible Product List (USER_DATA)

Get available Simple Earn flexible product list

Weight(IP): 150

Sends a `GET` request to `/sapi/v1/simple-earn/flexible/list`

Arguments:
- `asset`
- `current`: Current querying page. Start from 1. Default:1
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `size`: Default:10 Max:100
- `timestamp`: UTC timestamp in ms
*/
    pub async fn simple_earn_flexible_list<'a>(
        &'a self,
        asset: Option<&'a str>,
        current: Option<i32>,
        recv_window: Option<i64>,
        signature: &'a str,
        size: Option<i32>,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::SimpleEarnFlexibleListResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/simple-earn/flexible/list", self.baseurl,);
        let mut query = Vec::with_capacity(6usize);
        if let Some(v) = &asset {
            query.push(("asset", v.to_string()));
        }
        if let Some(v) = &current {
            query.push(("current", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &size {
            query.push(("size", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get Simple Earn Locked Product List (USER_DATA)

Weight(IP): 150

Sends a `GET` request to `/sapi/v1/simple-earn/locked/list`

Arguments:
- `asset`
- `current`: Current querying page. Start from 1. Default:1
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `size`: Default:10 Max:100
- `timestamp`: UTC timestamp in ms
*/
    pub async fn simple_earn_locked_list<'a>(
        &'a self,
        asset: Option<&'a str>,
        current: Option<i32>,
        recv_window: Option<i64>,
        signature: &'a str,
        size: Option<i32>,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::SimpleEarnLockedListResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/simple-earn/locked/list", self.baseurl,);
        let mut query = Vec::with_capacity(6usize);
        if let Some(v) = &asset {
            query.push(("asset", v.to_string()));
        }
        if let Some(v) = &current {
            query.push(("current", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &size {
            query.push(("size", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Subscribe Flexible Product (TRADE)

Weight(IP): 1

Rate Limit: 1/3s per account

Sends a `POST` request to `/sapi/v1/simple-earn/flexible/subscribe`

Arguments:
- `amount`
- `auto_subscribe`: true or false, default true.
- `product_id`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `source_account`: SPOT,FUND,ALL, default SPOT
- `timestamp`: UTC timestamp in ms
*/
    pub async fn simple_earn_flexible_subscribe<'a>(
        &'a self,
        amount: f64,
        auto_subscribe: Option<bool>,
        product_id: &'a str,
        recv_window: Option<i64>,
        signature: &'a str,
        source_account: Option<&'a str>,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::SimpleEarnFlexibleSubscribeResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/simple-earn/flexible/subscribe", self.baseurl,);
        let mut query = Vec::with_capacity(7usize);
        query.push(("amount", amount.to_string()));
        if let Some(v) = &auto_subscribe {
            query.push(("autoSubscribe", v.to_string()));
        }
        query.push(("productId", product_id.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &source_account {
            query.push(("sourceAccount", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Subscribe Locked Product (TRADE)

Weight(IP): 1

Rate Limit: 1/3s per account

Sends a `POST` request to `/sapi/v1/simple-earn/locked/subscribe`

Arguments:
- `amount`
- `auto_subscribe`: true or false, default true.
- `project_id`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `source_account`: SPOT,FUND,ALL, default SPOT
- `timestamp`: UTC timestamp in ms
*/
    pub async fn simple_earn_locked_subscribe<'a>(
        &'a self,
        amount: f64,
        auto_subscribe: Option<bool>,
        project_id: &'a str,
        recv_window: Option<i64>,
        signature: &'a str,
        source_account: Option<&'a str>,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::SimpleEarnLockedSubscribeResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/simple-earn/locked/subscribe", self.baseurl,);
        let mut query = Vec::with_capacity(7usize);
        query.push(("amount", amount.to_string()));
        if let Some(v) = &auto_subscribe {
            query.push(("autoSubscribe", v.to_string()));
        }
        query.push(("projectId", project_id.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &source_account {
            query.push(("sourceAccount", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Redeem Flexible Product (TRADE)

Weight(IP): 1

Rate Limit: 1/3s per account

Sends a `POST` request to `/sapi/v1/simple-earn/flexible/redeem`

Arguments:
- `amount`: if redeemAll is false, amount is mandatory
- `dest_account`: SPOT,FUND,ALL, default SPOT
- `product_id`
- `recv_window`: The value cannot be greater than 60000
- `redeem_all`: true or false, default to false
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn simple_earn_flexible_redeem<'a>(
        &'a self,
        amount: Option<f64>,
        dest_account: Option<&'a str>,
        product_id: &'a str,
        recv_window: Option<i64>,
        redeem_all: Option<bool>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::SimpleEarnFlexibleRedeemResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/simple-earn/flexible/redeem", self.baseurl,);
        let mut query = Vec::with_capacity(7usize);
        if let Some(v) = &amount {
            query.push(("amount", v.to_string()));
        }
        if let Some(v) = &dest_account {
            query.push(("destAccount", v.to_string()));
        }
        query.push(("productId", product_id.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        if let Some(v) = &redeem_all {
            query.push(("redeemAll", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Redeem Locked Product (TRADE)

Weight(IP): 1

Rate Limit: 1/3s per account

Sends a `POST` request to `/sapi/v1/simple-earn/locked/redeem`

Arguments:
- `position_id`: 1234
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn simple_earn_locked_redeem<'a>(
        &'a self,
        position_id: &'a str,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::SimpleEarnLockedRedeemResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/simple-earn/locked/redeem", self.baseurl,);
        let mut query = Vec::with_capacity(4usize);
        query.push(("positionId", position_id.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get Flexible Product Position (USER_DATA)

Weight(IP): 150

Sends a `GET` request to `/sapi/v1/simple-earn/flexible/position`

Arguments:
- `asset`
- `current`: Current querying page. Start from 1. Default:1
- `product_id`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `size`: Default:10 Max:100
- `timestamp`: UTC timestamp in ms
*/
    pub async fn simple_earn_flexible_position<'a>(
        &'a self,
        asset: Option<&'a str>,
        current: Option<i32>,
        product_id: Option<&'a str>,
        recv_window: Option<i64>,
        signature: &'a str,
        size: Option<i32>,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::SimpleEarnFlexiblePositionResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/simple-earn/flexible/position", self.baseurl,);
        let mut query = Vec::with_capacity(7usize);
        if let Some(v) = &asset {
            query.push(("asset", v.to_string()));
        }
        if let Some(v) = &current {
            query.push(("current", v.to_string()));
        }
        if let Some(v) = &product_id {
            query.push(("productId", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &size {
            query.push(("size", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get Locked Product Position (USER_DATA)

Weight(IP): 150

Sends a `GET` request to `/sapi/v1/simple-earn/locked/position`

Arguments:
- `asset`
- `current`: Current querying page. Start from 1. Default:1
- `position_id`
- `project_id`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `size`: Default:10 Max:100
- `timestamp`: UTC timestamp in ms
*/
    pub async fn simple_earn_locked_position<'a>(
        &'a self,
        asset: Option<&'a str>,
        current: Option<i32>,
        position_id: Option<&'a str>,
        project_id: Option<&'a str>,
        recv_window: Option<i64>,
        signature: &'a str,
        size: Option<i32>,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::SimpleEarnLockedPositionResponse>,
        Error<types::Error>,
    > {
        let url = format!("{}/sapi/v1/simple-earn/locked/position", self.baseurl,);
        let mut query = Vec::with_capacity(8usize);
        if let Some(v) = &asset {
            query.push(("asset", v.to_string()));
        }
        if let Some(v) = &current {
            query.push(("current", v.to_string()));
        }
        if let Some(v) = &position_id {
            query.push(("positionId", v.to_string()));
        }
        if let Some(v) = &project_id {
            query.push(("projectId", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &size {
            query.push(("size", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Simple Account (USER_DATA)

Weight(IP): 150

Sends a `GET` request to `/sapi/v1/simple-earn/account`

Arguments:
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn simple_earn_account<'a>(
        &'a self,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<ResponseValue<types::SimpleEarnAccountResponse>, Error<types::Error>> {
        let url = format!("{}/sapi/v1/simple-earn/account", self.baseurl,);
        let mut query = Vec::with_capacity(3usize);
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get Flexible Subscription Record (USER_DATA)

Weight(IP): 150

Sends a `GET` request to `/sapi/v1/simple-earn/flexible/history/subscriptionRecord`

Arguments:
- `asset`
- `current`: Current querying page. Start from 1. Default:1
- `end_time`: UTC timestamp in ms
- `product_id`
- `purchase_id`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `size`: Default:10 Max:100
- `start_time`: UTC timestamp in ms
- `timestamp`: UTC timestamp in ms
*/
    pub async fn simple_earn_flexible_history_subscription_record<'a>(
        &'a self,
        asset: Option<&'a str>,
        current: Option<i32>,
        end_time: Option<i64>,
        product_id: Option<&'a str>,
        purchase_id: Option<&'a str>,
        recv_window: Option<i64>,
        signature: &'a str,
        size: Option<i32>,
        start_time: Option<i64>,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::SimpleEarnFlexibleHistorySubscriptionRecordResponse>,
        Error<types::Error>,
    > {
        let url = format!(
            "{}/sapi/v1/simple-earn/flexible/history/subscriptionRecord", self.baseurl,
        );
        let mut query = Vec::with_capacity(10usize);
        if let Some(v) = &asset {
            query.push(("asset", v.to_string()));
        }
        if let Some(v) = &current {
            query.push(("current", v.to_string()));
        }
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        if let Some(v) = &product_id {
            query.push(("productId", v.to_string()));
        }
        if let Some(v) = &purchase_id {
            query.push(("purchaseId", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &size {
            query.push(("size", v.to_string()));
        }
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get Locked Subscription Record (USER_DATA)

Weight(IP): 150

Sends a `GET` request to `/sapi/v1/simple-earn/locked/history/subscriptionRecord`

Arguments:
- `asset`
- `current`: Current querying page. Start from 1. Default:1
- `end_time`: UTC timestamp in ms
- `purchase_id`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `size`: Default:10 Max:100
- `start_time`: UTC timestamp in ms
- `timestamp`: UTC timestamp in ms
*/
    pub async fn simple_earn_locked_history_subscription_record<'a>(
        &'a self,
        asset: Option<&'a str>,
        current: Option<i32>,
        end_time: Option<i64>,
        purchase_id: Option<&'a str>,
        recv_window: Option<i64>,
        signature: &'a str,
        size: Option<i32>,
        start_time: Option<i64>,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::SimpleEarnLockedHistorySubscriptionRecordResponse>,
        Error<types::Error>,
    > {
        let url = format!(
            "{}/sapi/v1/simple-earn/locked/history/subscriptionRecord", self.baseurl,
        );
        let mut query = Vec::with_capacity(9usize);
        if let Some(v) = &asset {
            query.push(("asset", v.to_string()));
        }
        if let Some(v) = &current {
            query.push(("current", v.to_string()));
        }
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        if let Some(v) = &purchase_id {
            query.push(("purchaseId", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &size {
            query.push(("size", v.to_string()));
        }
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get Flexible Redemption Record (USER_DATA)

Weight(IP): 150

Sends a `GET` request to `/sapi/v1/simple-earn/flexible/history/redemptionRecord`

Arguments:
- `asset`
- `current`: Current querying page. Start from 1. Default:1
- `end_time`: UTC timestamp in ms
- `product_id`
- `redeem_id`
- `size`: Default:10 Max:100
- `start_time`: UTC timestamp in ms
*/
    pub async fn simple_earn_flexible_history_redemption_record<'a>(
        &'a self,
        asset: Option<&'a str>,
        current: Option<i32>,
        end_time: Option<i64>,
        product_id: Option<&'a str>,
        redeem_id: Option<&'a str>,
        size: Option<i32>,
        start_time: Option<i64>,
    ) -> Result<
        ResponseValue<types::SimpleEarnFlexibleHistoryRedemptionRecordResponse>,
        Error<types::Error>,
    > {
        let url = format!(
            "{}/sapi/v1/simple-earn/flexible/history/redemptionRecord", self.baseurl,
        );
        let mut query = Vec::with_capacity(7usize);
        if let Some(v) = &asset {
            query.push(("asset", v.to_string()));
        }
        if let Some(v) = &current {
            query.push(("current", v.to_string()));
        }
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        if let Some(v) = &product_id {
            query.push(("productId", v.to_string()));
        }
        if let Some(v) = &redeem_id {
            query.push(("redeemId", v.to_string()));
        }
        if let Some(v) = &size {
            query.push(("size", v.to_string()));
        }
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get Locked Redemption Record (USER_DATA)

Weight(IP): 150

Sends a `GET` request to `/sapi/v1/simple-earn/locked/history/redemptionRecord`

Arguments:
- `asset`
- `current`: Current querying page. Start from 1. Default:1
- `end_time`: UTC timestamp in ms
- `position_id`
- `recv_window`: The value cannot be greater than 60000
- `redeem_id`
- `signature`: Signature
- `size`: Default:10 Max:100
- `start_time`: UTC timestamp in ms
- `timestamp`: UTC timestamp in ms
*/
    pub async fn simple_earn_locked_history_redemption_record<'a>(
        &'a self,
        asset: Option<&'a str>,
        current: Option<i32>,
        end_time: Option<i64>,
        position_id: Option<&'a str>,
        recv_window: Option<i64>,
        redeem_id: Option<&'a str>,
        signature: &'a str,
        size: Option<i32>,
        start_time: Option<i64>,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::SimpleEarnLockedHistoryRedemptionRecordResponse>,
        Error<types::Error>,
    > {
        let url = format!(
            "{}/sapi/v1/simple-earn/locked/history/redemptionRecord", self.baseurl,
        );
        let mut query = Vec::with_capacity(10usize);
        if let Some(v) = &asset {
            query.push(("asset", v.to_string()));
        }
        if let Some(v) = &current {
            query.push(("current", v.to_string()));
        }
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        if let Some(v) = &position_id {
            query.push(("positionId", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        if let Some(v) = &redeem_id {
            query.push(("redeemId", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &size {
            query.push(("size", v.to_string()));
        }
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get Flexible Rewards History (USER_DATA)

Weight(IP): 150

Sends a `GET` request to `/sapi/v1/simple-earn/flexible/history/rewardsRecord`

Arguments:
- `asset`
- `end_time`: UTC timestamp in ms
- `product_id`
- `start_time`: UTC timestamp in ms
- `type_`: "BONUS", "REALTIME", "REWARDS"
*/
    pub async fn simple_earn_flexible_history_rewards_record<'a>(
        &'a self,
        asset: Option<&'a str>,
        end_time: Option<i64>,
        product_id: Option<&'a str>,
        start_time: Option<i64>,
        type_: &'a str,
    ) -> Result<
        ResponseValue<types::SimpleEarnFlexibleHistoryRewardsRecordResponse>,
        Error<types::Error>,
    > {
        let url = format!(
            "{}/sapi/v1/simple-earn/flexible/history/rewardsRecord", self.baseurl,
        );
        let mut query = Vec::with_capacity(5usize);
        if let Some(v) = &asset {
            query.push(("asset", v.to_string()));
        }
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        if let Some(v) = &product_id {
            query.push(("productId", v.to_string()));
        }
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        query.push(("type", type_.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get Locked Rewards History (USER_DATA)

Weight(IP): 150

Sends a `GET` request to `/sapi/v1/simple-earn/locked/history/rewardsRecord`

Arguments:
- `asset`
- `end_time`: UTC timestamp in ms
- `position_id`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `size`: Default:10 Max:100
- `start_time`: UTC timestamp in ms
- `timestamp`: UTC timestamp in ms
*/
    pub async fn simple_earn_locked_history_rewards_record<'a>(
        &'a self,
        asset: Option<&'a str>,
        end_time: Option<i64>,
        position_id: Option<&'a str>,
        recv_window: Option<i64>,
        signature: &'a str,
        size: Option<i32>,
        start_time: Option<i64>,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::SimpleEarnLockedHistoryRewardsRecordResponse>,
        Error<types::Error>,
    > {
        let url = format!(
            "{}/sapi/v1/simple-earn/locked/history/rewardsRecord", self.baseurl,
        );
        let mut query = Vec::with_capacity(8usize);
        if let Some(v) = &asset {
            query.push(("asset", v.to_string()));
        }
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        if let Some(v) = &position_id {
            query.push(("positionId", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &size {
            query.push(("size", v.to_string()));
        }
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Set Flexible Auto Subscribe (USER_DATA)

Weight(IP): 150

Sends a `POST` request to `/sapi/v1/simple-earn/flexible/setAutoSubscribe`

Arguments:
- `auto_subscribe`: true or false
- `product_id`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn simple_earn_flexible_set_auto_subscribe<'a>(
        &'a self,
        auto_subscribe: bool,
        product_id: &'a str,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::SimpleEarnFlexibleSetAutoSubscribeResponse>,
        Error<types::Error>,
    > {
        let url = format!(
            "{}/sapi/v1/simple-earn/flexible/setAutoSubscribe", self.baseurl,
        );
        let mut query = Vec::with_capacity(5usize);
        query.push(("autoSubscribe", auto_subscribe.to_string()));
        query.push(("productId", product_id.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Set Locked Auto Subscribe (USER_DATA)

Weight(IP): 150

Sends a `POST` request to `/sapi/v1/simple-earn/locked/setAutoSubscribe`

Arguments:
- `auto_subscribe`: true or false
- `position_id`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn simple_earn_locked_set_auto_subscribe<'a>(
        &'a self,
        auto_subscribe: bool,
        position_id: &'a str,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::SimpleEarnLockedSetAutoSubscribeResponse>,
        Error<types::Error>,
    > {
        let url = format!(
            "{}/sapi/v1/simple-earn/locked/setAutoSubscribe", self.baseurl,
        );
        let mut query = Vec::with_capacity(5usize);
        query.push(("autoSubscribe", auto_subscribe.to_string()));
        query.push(("positionId", position_id.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get Flexible Personal Left Quota (USER_DATA)

Weight(IP): 150

Sends a `GET` request to `/sapi/v1/simple-earn/flexible/personalLeftQuota`

Arguments:
- `product_id`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn simple_earn_flexible_personal_left_quota<'a>(
        &'a self,
        product_id: &'a str,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::SimpleEarnFlexiblePersonalLeftQuotaResponse>,
        Error<types::Error>,
    > {
        let url = format!(
            "{}/sapi/v1/simple-earn/flexible/personalLeftQuota", self.baseurl,
        );
        let mut query = Vec::with_capacity(4usize);
        query.push(("productId", product_id.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get Locked Personal Left Quota (USER_DATA)

Weight(IP): 150

Sends a `GET` request to `/sapi/v1/simple-earn/locked/personalLeftQuota`

Arguments:
- `project_id`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn simple_earn_locked_personal_left_quota<'a>(
        &'a self,
        project_id: &'a str,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::SimpleEarnLockedPersonalLeftQuotaResponse>,
        Error<types::Error>,
    > {
        let url = format!(
            "{}/sapi/v1/simple-earn/locked/personalLeftQuota", self.baseurl,
        );
        let mut query = Vec::with_capacity(4usize);
        query.push(("projectId", project_id.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get Flexible Subscription Preview (USER_DATA)

Weight(IP): 150

Sends a `GET` request to `/sapi/v1/simple-earn/flexible/subscriptionPreview`

Arguments:
- `amount`
- `product_id`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn simple_earn_flexible_subscription_preview<'a>(
        &'a self,
        amount: f64,
        product_id: &'a str,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::SimpleEarnFlexibleSubscriptionPreviewResponse>,
        Error<types::Error>,
    > {
        let url = format!(
            "{}/sapi/v1/simple-earn/flexible/subscriptionPreview", self.baseurl,
        );
        let mut query = Vec::with_capacity(5usize);
        query.push(("amount", amount.to_string()));
        query.push(("productId", product_id.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get Locked Subscription Preview (USER_DATA)

Weight(IP): 150

Sends a `GET` request to `/sapi/v1/simple-earn/locked/subscriptionPreview`

Arguments:
- `amount`
- `auto_subscribe`: true or false, default true.
- `project_id`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `timestamp`: UTC timestamp in ms
*/
    pub async fn simple_earn_locked_subscription_preview<'a>(
        &'a self,
        amount: f64,
        auto_subscribe: Option<bool>,
        project_id: &'a str,
        recv_window: Option<i64>,
        signature: &'a str,
        timestamp: i64,
    ) -> Result<
        ResponseValue<Vec<types::SimpleEarnLockedSubscriptionPreviewResponseItem>>,
        Error<types::Error>,
    > {
        let url = format!(
            "{}/sapi/v1/simple-earn/locked/subscriptionPreview", self.baseurl,
        );
        let mut query = Vec::with_capacity(6usize);
        query.push(("amount", amount.to_string()));
        if let Some(v) = &auto_subscribe {
            query.push(("autoSubscribe", v.to_string()));
        }
        query.push(("projectId", project_id.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get Rate History (USER_DATA)

Weight(IP): 150

Sends a `GET` request to `/sapi/v1/simple-earn/flexible/history/rateHistory`

Arguments:
- `current`: Current querying page. Start from 1. Default:1
- `end_time`: UTC timestamp in ms
- `product_id`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `size`: Default:10 Max:100
- `start_time`: UTC timestamp in ms
- `timestamp`: UTC timestamp in ms
*/
    pub async fn simple_earn_flexible_history_rate_history<'a>(
        &'a self,
        current: Option<i32>,
        end_time: Option<i64>,
        product_id: &'a str,
        recv_window: Option<i64>,
        signature: &'a str,
        size: Option<i32>,
        start_time: Option<i64>,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::SimpleEarnFlexibleHistoryRateHistoryResponse>,
        Error<types::Error>,
    > {
        let url = format!(
            "{}/sapi/v1/simple-earn/flexible/history/rateHistory", self.baseurl,
        );
        let mut query = Vec::with_capacity(8usize);
        if let Some(v) = &current {
            query.push(("current", v.to_string()));
        }
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        query.push(("productId", product_id.to_string()));
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &size {
            query.push(("size", v.to_string()));
        }
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    /**Get Collateral Record (USER_DATA)

Weight(IP): 150

Sends a `GET` request to `/sapi/v1/simple-earn/flexible/history/collateralRecord`

Arguments:
- `current`: Current querying page. Start from 1. Default:1
- `end_time`: UTC timestamp in ms
- `product_id`
- `recv_window`: The value cannot be greater than 60000
- `signature`: Signature
- `size`: Default:10 Max:100
- `start_time`: UTC timestamp in ms
- `timestamp`: UTC timestamp in ms
*/
    pub async fn simple_earn_flexible_history_collateral_record<'a>(
        &'a self,
        current: Option<i32>,
        end_time: Option<i64>,
        product_id: Option<&'a str>,
        recv_window: Option<i64>,
        signature: &'a str,
        size: Option<i32>,
        start_time: Option<i64>,
        timestamp: i64,
    ) -> Result<
        ResponseValue<types::SimpleEarnFlexibleHistoryCollateralRecordResponse>,
        Error<types::Error>,
    > {
        let url = format!(
            "{}/sapi/v1/simple-earn/flexible/history/collateralRecord", self.baseurl,
        );
        let mut query = Vec::with_capacity(8usize);
        if let Some(v) = &current {
            query.push(("current", v.to_string()));
        }
        if let Some(v) = &end_time {
            query.push(("endTime", v.to_string()));
        }
        if let Some(v) = &product_id {
            query.push(("productId", v.to_string()));
        }
        if let Some(v) = &recv_window {
            query.push(("recvWindow", v.to_string()));
        }
        query.push(("signature", signature.to_string()));
        if let Some(v) = &size {
            query.push(("size", v.to_string()));
        }
        if let Some(v) = &start_time {
            query.push(("startTime", v.to_string()));
        }
        query.push(("timestamp", timestamp.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        (crate::pre_hook)(&self.inner, &request);
        let result = self.client.execute(request).await;
        (crate::post_hook)(&self.inner, &result);
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            401u16 => {
                Err(Error::ErrorResponse(ResponseValue::from_response(response).await?))
            }
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
}
/// Items consumers will typically use such as the Client.
pub mod prelude {
    #[allow(unused_imports)]
    pub use super::Client;
}
